<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">導入</a></li><li class="chapter-item expanded "><a href="01-background/index.html"><strong aria-hidden="true">1.</strong> 背景</a></li><li class="chapter-item expanded "><a href="02-requirements/index.html"><strong aria-hidden="true">2.</strong> ハードウェア/知識の要求</a></li><li class="chapter-item expanded "><a href="03-setup/index.html"><strong aria-hidden="true">3.</strong> 開発環境の構築</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-setup/linux.html"><strong aria-hidden="true">3.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="03-setup/windows.html"><strong aria-hidden="true">3.2.</strong> Windows</a></li><li class="chapter-item expanded "><a href="03-setup/macos.html"><strong aria-hidden="true">3.3.</strong> macOS</a></li><li class="chapter-item expanded "><a href="03-setup/verify.html"><strong aria-hidden="true">3.4.</strong> インストールの確認</a></li></ol></li><li class="chapter-item expanded "><a href="04-meet-your-hardware/index.html"><strong aria-hidden="true">4.</strong> ハードウェアとの出会い</a></li><li class="chapter-item expanded "><a href="05-led-roulette/index.html"><strong aria-hidden="true">5.</strong> LEDルーレット</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-led-roulette/build-it.html"><strong aria-hidden="true">5.1.</strong> ビルド</a></li><li class="chapter-item expanded "><a href="05-led-roulette/flash-it.html"><strong aria-hidden="true">5.2.</strong> Flashへの書き込み</a></li><li class="chapter-item expanded "><a href="05-led-roulette/debug-it.html"><strong aria-hidden="true">5.3.</strong> デバッグ</a></li><li class="chapter-item expanded "><a href="05-led-roulette/the-led-and-delay-abstractions.html"><strong aria-hidden="true">5.4.</strong> ledとdelayの抽象化</a></li><li class="chapter-item expanded "><a href="05-led-roulette/the-challenge.html"><strong aria-hidden="true">5.5.</strong> 課題</a></li><li class="chapter-item expanded "><a href="05-led-roulette/my-solution.html"><strong aria-hidden="true">5.6.</strong> 解答例</a></li></ol></li><li class="chapter-item expanded "><a href="06-hello-world/index.html"><strong aria-hidden="true">6.</strong> Hello, world!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06-hello-world/panic.html"><strong aria-hidden="true">6.1.</strong> panic!</a></li></ol></li><li class="chapter-item expanded "><a href="07-registers/index.html"><strong aria-hidden="true">7.</strong> レジスタ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07-registers/rtrm.html"><strong aria-hidden="true">7.1.</strong> RTRM</a></li><li class="chapter-item expanded "><a href="07-registers/optimization.html"><strong aria-hidden="true">7.2.</strong> (誤った)最適化</a></li><li class="chapter-item expanded "><a href="07-registers/bad-address.html"><strong aria-hidden="true">7.3.</strong> 0xBAAAAAAD番地</a></li><li class="chapter-item expanded "><a href="07-registers/spooky-action-at-a-distance.html"><strong aria-hidden="true">7.4.</strong> 異なる場所での不気味な動作</a></li><li class="chapter-item expanded "><a href="07-registers/type-safe-manipulation.html"><strong aria-hidden="true">7.5.</strong> 型安全な操作</a></li></ol></li><li class="chapter-item expanded "><a href="08-leds-again/index.html"><strong aria-hidden="true">8.</strong> LED、再び</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08-leds-again/power.html"><strong aria-hidden="true">8.1.</strong> 電源</a></li><li class="chapter-item expanded "><a href="08-leds-again/configuration.html"><strong aria-hidden="true">8.2.</strong> 設定</a></li><li class="chapter-item expanded "><a href="08-leds-again/the-solution.html"><strong aria-hidden="true">8.3.</strong> 解答例</a></li></ol></li><li class="chapter-item expanded "><a href="09-clocks-and-timers/index.html"><strong aria-hidden="true">9.</strong> クロックと時間</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="09-clocks-and-timers/for-loop-delays.html"><strong aria-hidden="true">9.1.</strong> forループで遅延</a></li><li class="chapter-item expanded "><a href="09-clocks-and-timers/nop.html"><strong aria-hidden="true">9.2.</strong> NOP</a></li><li class="chapter-item expanded "><a href="09-clocks-and-timers/one-shot-timer.html"><strong aria-hidden="true">9.3.</strong> ワンショットタイマ</a></li><li class="chapter-item expanded "><a href="09-clocks-and-timers/initialization.html"><strong aria-hidden="true">9.4.</strong> 初期化</a></li><li class="chapter-item expanded "><a href="09-clocks-and-timers/busy-waiting.html"><strong aria-hidden="true">9.5.</strong> ビジーウェイト</a></li><li class="chapter-item expanded "><a href="09-clocks-and-timers/putting-it-all-together.html"><strong aria-hidden="true">9.6.</strong> 全てをまとめる</a></li></ol></li><li class="chapter-item expanded "><a href="10-serial-communication/index.html"><strong aria-hidden="true">10.</strong> シリアル通信</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10-serial-communication/nix-tooling.html"><strong aria-hidden="true">10.1.</strong> *nixのツール</a></li><li class="chapter-item expanded "><a href="10-serial-communication/windows-tooling.html"><strong aria-hidden="true">10.2.</strong> Windowsのツール</a></li><li class="chapter-item expanded "><a href="10-serial-communication/loopbacks.html"><strong aria-hidden="true">10.3.</strong> ループバック</a></li></ol></li><li class="chapter-item expanded "><a href="11-usart/index.html"><strong aria-hidden="true">11.</strong> USART</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="11-usart/send-a-single-byte.html"><strong aria-hidden="true">11.1.</strong> 1バイト送信</a></li><li class="chapter-item expanded "><a href="11-usart/send-a-string.html"><strong aria-hidden="true">11.2.</strong> 文字列送信</a></li><li class="chapter-item expanded "><a href="11-usart/buffer-overrun.html"><strong aria-hidden="true">11.3.</strong> バッファオーバーラン</a></li><li class="chapter-item expanded "><a href="11-usart/uprintln.html"><strong aria-hidden="true">11.4.</strong> uprintln!</a></li><li class="chapter-item expanded "><a href="11-usart/receive-a-single-byte.html"><strong aria-hidden="true">11.5.</strong> 1バイト受信</a></li><li class="chapter-item expanded "><a href="11-usart/echo-server.html"><strong aria-hidden="true">11.6.</strong> エコーサーバー</a></li><li class="chapter-item expanded "><a href="11-usart/reverse-a-string.html"><strong aria-hidden="true">11.7.</strong> 文字列の反転</a></li><li class="chapter-item expanded "><a href="11-usart/my-solution.html"><strong aria-hidden="true">11.8.</strong> 解答例</a></li></ol></li><li class="chapter-item expanded "><a href="12-bluetooth-setup/index.html"><strong aria-hidden="true">12.</strong> Bluetooth設定</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="12-bluetooth-setup/linux.html"><strong aria-hidden="true">12.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="12-bluetooth-setup/loopback.html"><strong aria-hidden="true">12.2.</strong> ループバック</a></li></ol></li><li class="chapter-item expanded "><a href="13-serial-over-bluetooth/index.html"><strong aria-hidden="true">13.</strong> Bluetooth経由のシリアル</a></li><li class="chapter-item expanded "><a href="14-i2c/index.html"><strong aria-hidden="true">14.</strong> I2C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="14-i2c/the-general-protocol.html"><strong aria-hidden="true">14.1.</strong> 一般的なプロトコル</a></li><li class="chapter-item expanded "><a href="14-i2c/lsm303dlhc.html"><strong aria-hidden="true">14.2.</strong> LSM303DLHC</a></li><li class="chapter-item expanded "><a href="14-i2c/read-a-single-register.html"><strong aria-hidden="true">14.3.</strong> 1つのレジスタを読む</a></li><li class="chapter-item expanded "><a href="14-i2c/the-solution.html"><strong aria-hidden="true">14.4.</strong> 解答例</a></li><li class="chapter-item expanded "><a href="14-i2c/read-several-registers.html"><strong aria-hidden="true">14.5.</strong> 複数のレジスタを読む</a></li></ol></li><li class="chapter-item expanded "><a href="15-led-compass/index.html"><strong aria-hidden="true">15.</strong> LEDコンパス</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="15-led-compass/take-1.html"><strong aria-hidden="true">15.1.</strong> 第一弾</a></li><li class="chapter-item expanded "><a href="15-led-compass/solution-1.html"><strong aria-hidden="true">15.2.</strong> 解答例1</a></li><li class="chapter-item expanded "><a href="15-led-compass/take-2.html"><strong aria-hidden="true">15.3.</strong> 第二弾</a></li><li class="chapter-item expanded "><a href="15-led-compass/solution-2.html"><strong aria-hidden="true">15.4.</strong> 解答例2</a></li><li class="chapter-item expanded "><a href="15-led-compass/magnitude.html"><strong aria-hidden="true">15.5.</strong> 大きさ</a></li><li class="chapter-item expanded "><a href="15-led-compass/calibration.html"><strong aria-hidden="true">15.6.</strong> キャリブレーション</a></li></ol></li><li class="chapter-item expanded "><a href="16-punch-o-meter/index.html"><strong aria-hidden="true">16.</strong> パンチングマシン</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="16-punch-o-meter/gravity-is-up.html"><strong aria-hidden="true">16.1.</strong> 重力は上を向いている？</a></li><li class="chapter-item expanded "><a href="16-punch-o-meter/the-challenge.html"><strong aria-hidden="true">16.2.</strong> 課題</a></li><li class="chapter-item expanded "><a href="16-punch-o-meter/my-solution.html"><strong aria-hidden="true">16.3.</strong> 解答例</a></li></ol></li><li class="chapter-item expanded "><a href="explore.html"><strong aria-hidden="true">17.</strong> もっと楽しむために</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="appendix/1-general-troubleshooting/index.html">トラブルシューティング</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#discovery" id="discovery">Discovery</a></h1>
<!-- > Discover the world of microcontrollers through [Rust]! -->
<blockquote>
<p><a href="https://www.rust-lang.org/en-US/">Rust</a>でマイクロコントローラの世界を楽しもう！</p>
</blockquote>
<!-- 
This book is an introductory course on microcontroller-based embedded systems that uses Rust as the
teaching language rather than the usual C/C++.
 -->
<p>この本は、よくあるC/C++ではなく、Rustを使ったマイクロコントローラの組込みシステム入門コースです。</p>
<!-- ## Scope -->
<h2><a class="header" href="#スコープ" id="スコープ">スコープ</a></h2>
<!-- The following topics will be covered (eventually, I hope): -->
<p>以下のトピックを取り上げます（ゆくゆくは、そうしたいです）</p>
<!-- - How to write, build, flash and debug an "embedded" (Rust) program. -->
<ul>
<li>「組込み」（Rust）プログラムの書き方、ビルド方法、フラッシュへの書き込み方法、デバッグ方法。</li>
</ul>
<!-- 
- Functionality ("peripherals") commonly found in microcontrollers: Digital input and output, Pulse
  Width Modulation (PWM), Analog to Digital Converters (ADC), common communication protocols like
  Serial, I2C and SPI, etc.
 -->
<ul>
<li>マイクロコントローラで一般的な機能（「ペリフェラル」）。デジタル入出力、パルス幅変調（PWM）、アナログデジタル変換（ADC）、
シリアル、I2C、SPIのような一般的な通信プロトコル、など。</li>
</ul>
<!-- - Multitasking concepts: cooperative vs preemptive multitasking, interrupts, schedulers, etc. -->
<ul>
<li>マルチタスク。協調的マルチタスク vs プリエンプティブマルチタスク、割り込み、スケジューラなど。</li>
</ul>
<!-- 
- Control systems concepts: sensors, calibration, digital filters, actuators, open loop control,
  closed loop control, etc.
 -->
<ul>
<li>制御システム。センサ、キャリブレーション、デジタルフィルタ、アクチュエータ、開ループ制御、閉ループ制御、など。</li>
</ul>
<!-- ## Approach -->
<h2><a class="header" href="#進め方" id="進め方">進め方</a></h2>
<!-- - Beginner friendly. No previous experience with microcontrollers or embedded systems is required. -->
<ul>
<li>初心者に優しく。マイクロコントローラや組込みシステムの開発経験は必要ありません。</li>
</ul>
<!-- 
- Hands on. Plenty of exercises to put the theory into practice. *You* will be doing most of the
  work here.
 -->
<ul>
<li>ハンズオン形式で。理論を実践するためにたくさんの演習をします。<em>あなた</em>はほとんどの作業をここで行います。</li>
</ul>
<!-- 
- Tool centered. We'll make plenty use of tooling to ease development. "Real" debugging, with GDB,
  and logging will be introduced early on. Using LEDs as a debugging mechanism has no place here.
 -->
<ul>
<li>ツール中心に。開発を容易にするツールをたくさん使用します。GDBを使った「実際の」デバッグとログ出力を早い段階で導入します。
デバッグ機能としてLEDを使用するようなことは、ここではやりません。</li>
</ul>
<!-- ## Non-goals -->
<h2><a class="header" href="#目標としないこと" id="目標としないこと">目標としないこと</a></h2>
<!-- What's out of scope for this book: -->
<p>この本でスコープ外のことは、以下の通りです。</p>
<!-- 
- Teaching Rust. There's plenty of material on that topic already. We'll focus on microcontrollers
  and embedded systems.
 -->
<ul>
<li>Rustを教えること。このトピックについては、既に多くの教材があります。マイクロコントローラと組込みシステムに集中します。</li>
</ul>
<!-- 
- Being a comprehensive text about electric circuit theory or electronics. We'll just cover the
  minimum required to understand how some devices work.
 -->
<ul>
<li>電気回路または電子機器の理論についての包括的なテキストであること。
いくつかのデバイスがどのように動くか、を理解するための最低限の情報を提供します。</li>
</ul>
<!-- 
- Covering Rustic, low level details. We won't be talking about linker scripts, the boot process or
  how to glue those two into a minimally working Rust program.
 -->
<ul>
<li>Rustの低レベルな詳細を説明すること。リンカスクリプトやブートプロセス、
また、最小限のRustプログラムにこれらの2つの要素を結合する方法については、説明しません。</li>
</ul>
<!-- 
Also I don't intend to port this material to other development boards; this book will make exclusive
use of the STM32F3DISCOVERY development board.
 -->
<p>また、この教材を他の開発ボードに移植するつもりもありません。この本は、STM32F3DISCOVERY開発ボード専用のものです。</p>
<!-- ## Reporting problems -->
<h2><a class="header" href="#問題の報告" id="問題の報告">問題の報告</a></h2>
<!-- 
The source of this book is in [this repository]. If you encounter any typo or problem with the code
report it on the [issue tracker].
 -->
<p>この本のソースは<a href="https://github.com/rust-embedded/discovery">このレポジトリ</a>にあります。誤植やコードに問題を発見した場合は、<a href="https://github.com/rust-embedded/discovery/issues">issueトラッカー</a>に報告して下さい。</p>
<!-- 
[this repository]: https://github.com/rust-embedded/discovery
[issue tracker]: https://github.com/rust-embedded/discovery/issues
 -->
<blockquote>
<p>訳注：和訳への問題報告は、下記にお願いいたします。</p>
</blockquote>
<p>和訳のソースは<a href="https://github.com/tomoyuki-nakabayashi/discovery">和訳レポジトリ</a>にあります。問題を発見した場合は、<a href="https://github.com/tomoyuki-nakabayashi/discovery/issues">和訳issue</a>に報告して下さい。</p>
<!-- ## Other embedded Rust resources -->
<h2><a class="header" href="#他の組込みrustの資料" id="他の組込みrustの資料">他の組込みRustの資料</a></h2>
<!-- 
This Discovery book is just one of several embedded Rust resources provided by the
[Embedded Working Group]. The full selection can be found at [The Embedded Rust Bookshelf]. This
includes the list of [Frequently Asked Questions].
 -->
<p>このDiscovery本は、<a href="https://github.com/rust-embedded/wg">組込みワーキンググループ</a>が提供する組込みRust資料の1つに過ぎません。
<a href="https://docs.rust-embedded.org">組込みRustの本棚</a>に、数多くの資料があります。そこには、<a href="https://docs.rust-embedded.org/faq.html">よくある質問と回答</a>のリストも有ります。</p>
<!-- 
[Embedded Working Group]: https://github.com/rust-embedded/wg
[The Embedded Rust Bookshelf]: https://docs.rust-embedded.org
[Frequently Asked Questions]: https://docs.rust-embedded.org/faq.html
 -->
<!-- スポンサー紹介のため、あえて和訳していません。 -->
<h2><a class="header" href="#sponsored-by" id="sponsored-by">Sponsored by</a></h2>
<p align="center">
<a href="http://integer32.com/">
<img style="width: 50%" title="integer 32" src="assets/integer32.svg">
</a>
</p>
<p>Many thanks to <a href="http://integer32.com/">integer 32</a> for sponsoring me to work on this book! Please
give them lots of work (they do Rust consulting!) so they'll have no choice but to hire more
Rustaceans &lt;3.</p>
<!-- # Background -->
<h1><a class="header" href="#背景" id="背景">背景</a></h1>
<!-- ## What's a microcontroller? -->
<h2><a class="header" href="#マイクロコントローラとは何でしょうか" id="マイクロコントローラとは何でしょうか">マイクロコントローラとは何でしょうか？</a></h2>
<!-- 
A microcontroller is a *system* on a chip. Whereas your laptop is made up of several discrete
components: a processor, RAM sticks, a hard drive, an ethernet port, etc.; a microcontroller has all
those components built into a single "chip" or package. This makes it possible to build systems with
minimal part count.
 -->
<p>マイクロコントローラは、1チップ上の<em>システム</em>です。
一方、あなたのノートPCは、プロセッサ、RAMスティック、ハードディスクドライブ、イーサーネットポートなど、いくつかの個別の部品で構成されています。
マイクロコントローラは、それらの構成部品を1つの「チップ」またはパッケージ内に組み込みます。
このことにより、最小限の部品数からなるシステムを構築することが可能になります。</p>
<!-- ## What can you do with a microcontroller? -->
<h2><a class="header" href="#マイクロコントローラで何ができるのでしょうか" id="マイクロコントローラで何ができるのでしょうか">マイクロコントローラで何ができるのでしょうか？</a></h2>
<!-- 
Lots of things! Microcontrollers are the central part of systems known as *embedded* systems. These
systems are everywhere but you don't usually notice them. These systems control the brakes of your
car, wash your clothes, print your documents, keep you warm, keep you cool, optimize the fuel
consumption of your car, etc.
 -->
<p>たくさんのことができます！マイクロコントローラは<em>組込み</em>システムとして知られるシステムの中心を担う部品です。
組込みシステムはどこにでもありますが、通常それらを意識することはありません。組込みシステムは車のブレーキを制御したり、
衣服を洗濯したり、ドキュメントを印刷したり、冷暖房を制御したり、車の燃料消費を最適化したりします。</p>
<!-- 
The main trait of these systems is that they operate without user intervention even if they expose a
user interface like a washing machine does; most of their operation is done on their own.
 -->
<p>組込みシステムの主な特徴は、洗濯機のようにユーザーインタフェースがある場合でさえ、ユーザーの介入なしに動作することです。
ほとんどの動作は、組込みシステム自身で完結します。</p>
<!-- 
The other common trait of these systems is that they *control* a process. And for that these systems
usually have one or more sensors and one or more actuators. For example, an HVAC system has several
sensors, thermometers and humidity sensors spread across some area, and several actuators as well,
heating elements and fans connected to ducts.
 -->
<p>組込みシステムの他の特徴としては、プロセスを<em>制御</em>することです。このために組込みシステムは、通常、1つ以上のセンサとアクチュエータを持ちます。
例えば、空調システムは、点在する温度計や湿度計といったセンサと、発熱体やダクトに接続されたファンのようなアクチュエータを持ちます。</p>
<!-- ## When should I use a microcontroller? -->
<h2><a class="header" href="#マイクロコントローラを使うべきなのはいつでしょうか" id="マイクロコントローラを使うべきなのはいつでしょうか">マイクロコントローラを使うべきなのはいつでしょうか？</a></h2>
<!-- 
All these application I've mentioned, you can probably implement with a Raspberry Pi, a computer
that runs Linux. Why should I bother with a microcontroller that operates without an OS? Sounds like
it would be harder to develop a program.
 -->
<p>上述した全てのアプリケーションを、Linuxが動作するRaspberry Piで実装することは可能でしょう。
わざわざOSなしで動作するマイクロコントローラを使うのはなぜでしょうか？
プログラムを開発するのは、容易ではなさそうです。</p>
<!-- 
The main reason is cost. A microcontroller is much cheaper than a general purpose computer. Not only
the microcontroller is cheaper; it also requires many fewer external electrical components to
operate. This makes Printed Circuit Boards (PCB) smaller and cheaper to design and manufacture.
 -->
<p>主な理由はコストです。マイクロコントローラは、汎用コンピュータより非常に安価です。マイクロコントローラ自体が安いだけではないです。
マイクロコントローラは、動作のための外部電気部品を少ししか必要としません。そのため、プリント基板（PCB）を小さく、安価に設計、製造できます。</p>
<!-- 
The other big reason is power consumption. A microcontroller consumes orders of magnitude less power
than a full blown processor. If your application will run on batteries that makes a huge difference.
 -->
<p>他の大きな理由は、消費電力です。マイクロコントローラは、本格的なプロセッサよりも数桁少ない電力しか消費しません。
アプリケーションがバッテリで動作するとき、この違いは大きいです。</p>
<!-- 
And last but not least: (hard) *real time* constraints. Some processes require their controllers to
respond to some events within some time interval (e.g. a quadcopter/drone hit by a wind gust). If
this *deadline* is not met, the process could end in catastrophic failure (e.g. the drone crashes to
the ground). A general purpose computer  running a general purpose OS has many services running in
the background. This makes it hard to guarantee execution of a program within tight time constraints.
 -->
<p>最後になりましたが、（ハード）<em>リアルタイム</em>制約があるためです。
プロセスによっては、ある時間間隔以内にイベントに応答する必要があります（例えば、クアッドコプター/ドローンが突風に襲われた場合）。
もし、<em>デッドライン</em>を満たさない場合、そのプロセスは悲惨な結末を迎えるでしょう（例えば、ドローンは地面に墜落します）。
汎用OSを実行している汎用コンピュータは、背後で多くのサービスが動作しています。
このことは、厳密な時間制約内でのプログラム実行の保証を難しくします。</p>
<!-- ## When should I *not* use a microcontroller? -->
<h2><a class="header" href="#マイクロコントローラを使うべきでない時はいつでしょうか" id="マイクロコントローラを使うべきでない時はいつでしょうか">マイクロコントローラを使うべきで<em>ない</em>時はいつでしょうか？</a></h2>
<!-- 
Where heavy computations are involved. To keep their power consumption low, microcontrollers have
very limited computational resources available to them. For example, some microcontrollers don't
even have hardware support for floating point operations. On those devices, performing a simple
addition of single precision numbers can take hundreds of CPU cycles.
 -->
<p>計算量が膨大な場合です。消費電力を低くするため、マイクロコントローラは非常に限られた計算資源しか持っていません。
例えば、マイクロコントローラによっては、浮動小数点演算のハードウェアすら搭載していません。
そのようなデバイスでは、単精度の単純な加算でさえも、実行に数百CPUサイクルかかるでしょう。</p>
<!-- ## Why use Rust and not C? -->
<h2><a class="header" href="#cではなくrustを使う理由はなんでしょうか" id="cではなくrustを使う理由はなんでしょうか">CではなくRustを使う理由はなんでしょうか？</a></h2>
<!-- 
Hopefully, I don't need to convince you here as you are probably familiar with the language
differences between Rust and C. One point I do want to bring up is package management. C lacks an
official, widely accepted package management solution whereas Rust has Cargo. This makes development
*much* easier. And, IMO, easy package management encourages code reuse because libraries can be
easily integrated into an application which is also a good thing as libraries get more "battle
testing".
 -->
<p>あなたはRustとCとの違いを知っており、ここで説得する必要がないことを願っています。
あえて、1つ強調すると、それはパッケージ管理です。RustにはCargoがある一方、Cは公式の広く普及しているパッケージ管理システムがありません。
Cargoは開発を<em>非常に</em>容易にします。私の意見としては、パッケージ管理が簡単であることは、コードの再利用を促進します。
なぜなら、ライブラリがアプリケーションに容易に結合できるからです。このことは、ライブラリがより「実戦で使われる」ことにも良い影響があります。</p>
<!-- ## Why should I not use Rust? -->
<h2><a class="header" href="#rustを使うべきでない理由は何でしょうか" id="rustを使うべきでない理由は何でしょうか">Rustを使うべきでない理由は何でしょうか？</a></h2>
<!-- Or why should I prefer C over Rust? -->
<p>もしくは、RustよりCを選ぶ理由はなんでしょうか？</p>
<!-- 
The C ecosystem is way more mature. Off the shelf solution for several problems already exist. If
you need to control a time sensitive process, you can grab one of the existing commercial Real Time
Operating Systems (RTOS) out there and solve your problem. There are no commercial, production-grade
RTOSes in Rust yet so you would have to either create one yourself or try one of the ones that are
in development.
 -->
<p>Cのエコシステムはより成熟しています。いくつもの問題に対する解決策が既に存在しています。
時間制約のあるプロセスを制御する必要がある場合、既存の商用リアルタイムOS（RTOS）を選び、問題を解決することができます。
Rustにはまだ、商用で製品レベルのRTOSがないため、自分自身で作るか、開発中のものを試す必要があります。</p>
<!-- # Hardware/knowledge requirements -->
<h1><a class="header" href="#ハードウェア知識の要求" id="ハードウェア知識の要求">ハードウェア/知識の要求</a></h1>
<!-- 
The only knowledge requirement to read this book is to know *some* Rust. It's
hard for me to quantify *some* but at least I can tell you that you don't need
to fully grok generics but you do need to know how to *use* closures. You also
need to be familiar with the idioms of the [2018 edition], in particular with
the fact that `extern crate` is not necessary in the 2018 edition.
 -->
<p>この本を読む上で必要な知識は、Rustを<em>ある程度</em>知っていることのみです。
<em>ある程度</em>を定量的に表現することは難しいです。
ジェネリクスを完全に理解している必要はありませんが、クロージャの<em>使い方</em>を知っている必要があります。
<a href="https://rust-lang-nursery.github.io/edition-guide/">2018 edition</a>のイディオムも知っている必要があります。特に、2018 editionでは<code>extern crate</code>は必要ありません。</p>
<!-- 何故かレンダリングが崩れるため、下記文章だけ原文の上の和訳を書いています。 -->
<p>また、資料を理解するために、次のハードウェアが必要でしょう。</p>
<p>（いくつかの部品はオプションですが、用意することを推奨します）</p>
<!-- 
Also, to follow this material you'll need the following hardware:

(Some components are optional but recommended)
 -->
<!-- - A [STM32F3DISCOVERY] board. -->
<ul>
<li><a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a>ボード1台</li>
</ul>
<!-- 
(You can purchase this board from "big" [electronics][0] [suppliers][1] or from [e-commerce][2]
[sites][3])
 -->
<p>（<a href="http://www.mouser.com/ProductDetail/STMicroelectronics/STM32F3DISCOVERY">電子機器販売業者</a>、<a href="http://www.digikey.com/product-detail/en/stmicroelectronics/STM32F3DISCOVERY/497-13192-ND">サプライヤ</a>、<a href="https://www.aliexpress.com/wholesale?SearchText=stm32f3discovery">通信販売</a><a href="http://www.ebay.com/sch/i.html?_nkw=stm32f3discovery">サイト</a>でボードを購入できます）</p>
<blockquote>
<p>訳注：2019/2/15現在、<a href="https://jp.rs-online.com/web/p/products/7692091/?grossPrice=Y&amp;cm_mmc=JP-PPC-DS3A-_-google-_-3_JP_JP_%E3%83%97%E3%83%AD%E3%82%BB%E3%83%83%E3%82%B5+%E3%83%BB%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E9%96%8B%E7%99%BA%E3%82%AD%E3%83%83%E3%83%88+%26+%E3%83%9C%E3%83%BC%E3%83%89_STMicroelectronics_-_-STMicroelectronics+-+%E3%83%97%E3%83%AD%E3%82%BB%E3%83%83%E3%82%B5+%E3%83%BB%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E9%96%8B%E7%99%BA%E3%82%AD%E3%83%83%E3%83%88+%26+%E3%83%9C%E3%83%BC%E3%83%89+-+7692-_-stm32f3discovery&amp;matchtype=e&amp;kwd-301592221375&amp;gclid=CjwKCAiAwJTjBRBhEiwA56V7qwO0gqwtq3vxhH_bzWGER_bq5El1h86TVm0RnA9eAImmbYf9zTG9dRoCDREQAvD_BwE&amp;gclsrc=aw.ds">RSオンライン</a>と<a href="https://www.mouser.jp/ProductDetail/STMicroelectronics/STM32F3DISCOVERY?qs=6ddF3R%2F6EV%2Fl7MfIrXy3BQ%3D%3D">MOUSER</a>での在庫を確認しています。</p>
</blockquote>
<p align="center">
<img title="STM32F3DISCOVERY" src="02-requirements/../assets/f3.jpg">
</p>
<!-- 
- OPTIONAL. A **3.3V** USB <-> Serial module. [This particular model][sparkfun] will be used
  throughout this material but you can use any other model as long as it operates at 3.3V.
 -->
<ul>
<li>オプション。<strong>3.3V</strong>USB &lt;-&gt; シリアルモジュール。<a href="https://www.sparkfun.com/products/9873">このモジュール</a>を資料では使います。
しかし、3.3Vで動作するモジュールであれば、他の物でも使用可能です。</li>
</ul>
<!-- 
(The (Chinese) CH340G module, which you can buy [e-commerce][4] sites, works too and it's probably
cheaper for you to get)
 -->
<p>((中国の)CH340Gモジュールが、<a href="https://www.aliexpress.com/wholesale?SearchText=CH340G">通信販売</a>サイトで購入できます。同じように動作し、より安価に入手できます。)</p>
<blockquote>
<p>訳注：<a href="https://www.amazon.co.jp/GAOHOU-ESA854-Raspberry-%E3%83%A9%E3%82%BA%E3%83%99%E3%83%AA%E3%83%BC%E3%83%91%E3%82%A4%E7%94%A8%E3%81%AE-USB%EF%BC%8DTTL%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%AB%E3%82%B3%E3%83%B3%E3%82%BD%E3%83%BC%E3%83%AB%E3%81%AEUSB%E5%A4%89%E6%8F%9BCOM%E3%82%B1%E3%83%BC%E3%83%96%E3%83%AB%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%81%AE%E3%82%B1%E3%83%BC%E3%83%96%E3%83%AB/dp/B00K7YYFNM">USB変換ケーブル</a>でも大丈夫です。</p>
</blockquote>
<p align="center">
<img title="A 3.3v USB <-> Serial module" src="../assets/serial.jpg">
</p>
<!-- - OPTIONAL. A HC-05 Bluetooth module (with headers!). A HC-06 would work too. -->
<ul>
<li>オプション。（ヘッダ付きの）HC-05 Bluetoothモジュール1つ。HC-06モジュールも使えます。</li>
</ul>
<!-- 
(As with other Chinese parts, you pretty much can only find these on [e-commerce][5] [sites][6].
(US) Electronics suppliers don't usually stock these for some reason)
 -->
<p>（他の中国部品と同様に、ほとんどを<a href="http://www.ebay.com/sch/i.html?_nkw=hc-05">通信販売</a><a href="https://www.aliexpress.com/wholesale?SearchText=hc-05">サイト</a>で見つけることができます。
(米国)電子機器サプライヤは通常、何らかの理由でこれらをストックしていません）</p>
<p align="center">
<img title="The HC-05 Bluetooth module" src="02-requirements/../assets/bluetooth.jpg">
</p>
<!-- 
- Two mini-B USB cables. One is required to make the STM32F3DISCOVERY board work. The other is only
  required if you have the Serial <-> USB module.
 -->
<ul>
<li>mini-B USBケーブル2本。1本はSTM32F3DISCOVERYボードを動かすのに必要です。
もう1本は、シリアル &lt;-&gt; USBモジュールがある時だけ、必要です。</li>
</ul>
<p align="center">
<img title="mini-B USB cable" src="02-requirements/../assets/usb-cable.jpg">
</p>
<!-- 
> **NOTE** These are **not** the USB cables that ship with pretty much every Android phone; those
> are *micro* USB cables. Make sure you have the right thing!
 -->
<blockquote>
<p><strong>注記</strong> mini-B USBケーブルは、Androidスマートフォンに付属するUSBケーブルとは<strong>別物</strong>です。
Android付属のUSBケーブルは<em>micro</em>USBケーブルです。正しいものを持っていることを確認して下さい！</p>
</blockquote>
<!-- 
- MOSTLY OPTIONAL. 5 female to female, 4 male to female and 1 Male to Male *jumper* (AKA Dupont)
  wires. You'll *very likely* need one female to female to get ITM working. The other wires are only
  needed if you'll be using the USB <-> Serial and Bluetooth modules.
 -->
<ul>
<li>ほぼオプション。5本のメス-メス、4本のオス-メス、1本のオス-オス<em>ジャンパ</em>（別名 Dupont）ワイヤ。
ITMを機能させるために、1本のメス-メスワイヤが必要になる可能性が非常に高いです。
他のワイヤは、USB &lt;-&gt; シリアルとBluetoothモジュールを使う場合のみ必要です。</li>
</ul>
<!-- 
(You can get these from electronics [suppliers][7] or from [e-commerce][8] [sites][9])
 -->
<p>（電子機器<a href="https://www.adafruit.com/categories/306">サプライヤ</a>や<a href="http://www.ebay.com/sch/i.html?_nkw=dupont+wire">通信販売</a><a href="https://www.aliexpress.com/wholesale?SearchText=dupont+wire">サイト</a>から入手できます。）</p>
<p align="center">
<img title="Jumper wires" src="02-requirements/../assets/jumper-wires.jpg">
</p>
<!-- > **FAQ**: Wait, why do I need this specific hardware? -->
<blockquote>
<p><strong>よくある質問と回答</strong>：なぜ、特定のハードウェアが必要なのですか？</p>
</blockquote>
<!-- It makes my life and yours much easier. -->
<p>私たちの人生をずっと簡単にします。</p>
<!-- 
The material is much, much more approachable if we don't have to worry about hardware differences.
Trust me on this one.
 -->
<p>ハードウェアの差異を気にしなくて良いのであれば、資料は非常に取っ付きやすいものになります。
このことについては、私を信じて下さい。</p>
<!-- > **FAQ**: Can I follow this material with a different development board? -->
<blockquote>
<p><strong>よくある質問と回答</strong>：別の開発ボードでこの資料を理解できますか？</p>
</blockquote>
<!-- 
Maybe? It depends mainly on two things: your previous experience with microcontrollers and/or
whether there already exists a high level crate, like the [`f3`], for your development board
somewhere.
 -->
<p>おそらく？2つの事項に依存します。あなたのこれまでのマイクロコントローラ開発経験と、
<a href="https://docs.rs/f3"><code>f3</code></a>のような高レベルのcrateが、あなたの開発ボードに既に存在しているかどうかです。</p>
<!-- 
With a different development board, this text would lose most if not all its beginner friendliness
and "easy to follow"-ness, IMO.
 -->
<p>私の意見としては、開発ボードが異なると、初心者向けで「話についていくのが容易」というこの文書の特徴をほとんど失うでしょう。</p>
<!-- 
If you have a different development board and you don't consider yourself a total beginner, you are
better off starting with the [quickstart] project template.
 -->
<p>異なる開発ボードを持っていたり、自分を初心者とは考えていない場合は、<a href="https://docs.rs/cortex-m-quickstart">quickstart</a>プロジェクトテンプレートから始めた方が良いでしょう。</p>
<!-- # Setting up a development environment -->
<h1><a class="header" href="#開発環境の構築" id="開発環境の構築">開発環境の構築</a></h1>
<!-- 
Dealing with microcontrollers involves several tools as we'll be dealing with an architecture
different than your laptop's and we'll have to run and debug programs on a "remote" device.
 -->
<p>開発をするPCとは異なるアーキテクチャを扱うことになるので、マイクロコントローラを扱うには、いくつかのツールが必要です。
私たちは、「リモート」デバイス上でプログラムを実行し、デバッグします。</p>
<!-- ## Documentation -->
<h2><a class="header" href="#ドキュメント" id="ドキュメント">ドキュメント</a></h2>
<!-- 
Tooling is not everything though. Without documentation it is pretty much impossible to work with
microcontrollers.
 -->
<p>ツールだけではありません。ドキュメントがなければ、マイクロコントローラを扱うことはほとんど不可能です。</p>
<!-- We'll be referring to all these documents throughout this book: -->
<p>この本を通して、次のドキュメントを参照します。</p>
<!-- 
*HEADS UP* All these links point to PDF files and some of them are hundreds of pages long and
several MBs in size.
 -->
<p><em>注意</em> これらはPDFファイルへのリンクです。数百ページの長さで数MBもあるファイルもあります。</p>
<ul>
<li><a href="http://www.st.com/resource/en/user_manual/dm00063382.pdf">STM32F3DISCOVERY User Manual</a></li>
<li><a href="http://www.st.com/resource/en/datasheet/stm32f303vc.pdf">STM32F303VC Datasheet</a></li>
<li><a href="http://www.st.com/resource/en/reference_manual/dm00043574.pdf">STM32F303VC Reference Manual</a></li>
<li><a href="http://www.st.com/resource/en/datasheet/lsm303dlhc.pdf">LSM303DLHC</a></li>
<li><a href="http://www.st.com/resource/en/datasheet/l3gd20.pdf">L3GD20</a></li>
</ul>
<!-- ## Tools -->
<h2><a class="header" href="#ツール" id="ツール">ツール</a></h2>
<!-- 
We'll use all the tools listed below. Where a minimum version is not specified, any recent version
should work but we have listed the version we have tested.
 -->
<p>下記リストのツールを利用します。最小バージョンが指定されていない場合、新しいバージョンであれば機能するはずです。
私たちがテストしたバージョンをリストに示しています。</p>
<!-- - Rust 1.31 or a newer toolchain. -->
<ul>
<li>
<p>Rust 1.31以上のツールチェイン</p>
</li>
<li>
<p><a href="https://crates.io/crates/itm"><code>itmdump</code></a> v0.2.1</p>
</li>
</ul>
<!-- - OpenOCD >=0.8. Tested versions: v0.9.0 and v0.10.0 -->
<ul>
<li>OpenOCD &gt;=0.8. テストしたバージョン: v0.9.0 and v0.10.0</li>
</ul>
<!-- 
- `arm-none-eabi-gdb`. Version 7.12 or newer highly recommended. Tested versions: 7.10, 7.11,
  7.12 and 8.1
 -->
<ul>
<li><code>arm-none-eabi-gdb</code>。バージョン7.12以上を強く推奨します。テストしたバージョン: 7.10, 7.11, 7.12, 8.1</li>
</ul>
<!-- - [`cargo-binutils`]. Version 0.1.4 or newer. -->
<ul>
<li><a href="https://github.com/rust-embedded/cargo-binutils"><code>cargo-binutils</code></a>. バージョン0.1.4以上</li>
</ul>
<!-- 
- `minicom` on Linux and macOS. Tested version: 2.7. Readers report that `picocom` also works but
  we'll use `minicom` in this text.
 -->
<ul>
<li>LinuxおよびmacOSでは<code>minicom</code>。テストしたバージョン: 2.7。読者の報告では<code>piocom</code>も動作しますが、このテキストでは<code>minicom</code>を使います。</li>
</ul>
<!-- - `PuTTY` on Windows. -->
<ul>
<li>Windoswでは<code>PuTTY</code>（訳注：TeraTermでもおそらく大丈夫です）</li>
</ul>
<!-- 
If your laptop has Bluetooth functionality and you have the Bluetooth module, you can additionally
install these tools to play with the Bluetooth module. All these are optional:
 -->
<p>あなたのノートPCがBluetooth機能を搭載していて、Bluetoothモジュールを持っている場合、Bluetoothモジュールを使うために、追加で次のツールをインストールして下さい。
これらは、全てオプションです。</p>
<!-- 
- Linux, only if you don't have a Bluetooth manager application like Blueman.
  - `bluez`
  - `hcitool`
  - `rfcomm`
  - `rfkill`
 -->
<ul>
<li>Linux。BluemanのようなBluetooth管理アプリケーションがない場合のみ、次のツールをインストールして下さい。
<ul>
<li><code>bluez</code></li>
<li><code>hcitool</code></li>
<li><code>rfcomm</code></li>
<li><code>rfkill</code></li>
</ul>
</li>
</ul>
<!-- macOS / OSX / Windows users only need the default bluetooth manager that ships with their OS. -->
<p>macOS / OSX / Windowsユーザーは、OS出荷時のデフォルトBluetoothマネージャだけが必要です。</p>
<!-- Next, follow OS-agnostic installation instructions for a few of the tools: -->
<p>次に、いくつかのOSに依存しないツールのインストール手順を掲載します。</p>
<h3><a class="header" href="#rustc--cargo" id="rustc--cargo"><code>rustc</code> &amp; Cargo</a></h3>
<!-- Install rustup by following the instructions at [https://rustup.rs](https://rustup.rs). -->
<p><a href="https://rustup.rs">https://rustup.rs</a>の手順に従って、rustupをインストールします。</p>
<!-- 
If you already have rustup installed double check that you are on the stable
channel and your stable toolchain is up to date. `rustc -V` should return a date
newer than the one shown below:
 -->
<p>既にrustupをインストールしてある場合、stableチャネルになっていて、stableツールチェインが最新であることを確認して下さい。
<code>rustc -V</code>は、下よりも新しい日付を返す必要が有ります。</p>
<pre><code class="language-console">$ rustc -V
rustc 1.31.0 (abe02cefd 2018-12-04)
</code></pre>
<h3><a class="header" href="#itmdump" id="itmdump"><code>itmdump</code></a></h3>
<pre><code class="language-console">$ cargo install itm --vers 0.3.1

$ itmdump -V
itmdump 0.3.1
</code></pre>
<h3><a class="header" href="#cargo-binutils" id="cargo-binutils"><code>cargo-binutils</code></a></h3>
<pre><code class="language-console">$ rustup component add llvm-tools-preview

$ cargo install cargo-binutils --vers 0.1.4

$ cargo size -- -version
LLVM (http://llvm.org/):
  LLVM version 8.0.0svn
  Optimized build.
  Default target: x86_64-unknown-linux-gnu
  Host CPU: skylake
</code></pre>
<!-- ### OS specific instructions -->
<h3><a class="header" href="#os固有の手順" id="os固有の手順">OS固有の手順</a></h3>
<!-- Now follow the instructions specific to the OS you are using: -->
<p>使用しているOSに固有の手順に従って下さい。</p>
<ul>
<li><a href="03-setup/linux.html">Linux</a></li>
<li><a href="03-setup/windows.html">Windows</a></li>
<li><a href="03-setup/macos.html">macOS</a></li>
</ul>
<h1><a class="header" href="#linux" id="linux">Linux</a></h1>
<!-- Here are the installation commands for a few Linux distributions. -->
<p>いくつかのLinuxディストリビューションのインストールコマンドを示します。</p>
<!-- ## REQUIRED packages -->
<h2><a class="header" href="#必須のパッケージ" id="必須のパッケージ">必須のパッケージ</a></h2>
<!-- - Ubuntu 18.04 or newer / Debian stretch or newer -->
<ul>
<li>Ubuntu 18.04以上 / Debian stretch以降</li>
</ul>
<!-- 
> **NOTE** `gdb-multiarch` is the GDB command you'll use to debug your ARM
> Cortex-M programs
 -->
<p><strong>注記</strong> <code>gdb-multiarch</code>は、ARM Cortex-Mプログラムをデバッグするために使用するGDBのコマンドです。</p>
<!-- Debian stretch -->
<!-- GDB 7.12 -->
<!-- OpenOCD 0.9.0 -->
<!-- Ubuntu 18.04 -->
<!-- GDB 8.1 -->
<!-- OpenOCD 0.10.0 -->
<pre><code class="language-console">$ sudo apt-get install \
  gdb-multiarch \
  minicom \
  openocd
</code></pre>
<!-- - Ubuntu 14.04 and 16.04 -->
<ul>
<li>Ubuntu 14.04と16.04</li>
</ul>
<!-- 
> **NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug your ARM
> Cortex-M programs
 -->
<p><strong>注記</strong> <code>arm-none-eabi-gdb</code>は、ARM Cortex-Mプログラムをデバッグするために使用するGDBのコマンドです。</p>
<!-- Ubuntu 14.04 -->
<!-- GDB 7.6 -->
<!-- OpenOCD 0.7.0 -->
<pre><code class="language-console">$ sudo apt-get install \
  gdb-arm-none-eabi \
  minicom \
  openocd
</code></pre>
<!-- - Fedora 23 or newer -->
<ul>
<li>Fedora 23以上</li>
</ul>
<!-- 
> **NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug your ARM
> Cortex-M programs
 -->
<p><strong>注記</strong> <code>arm-none-eabi-gdb</code>は、ARM Cortex-Mプログラムをデバッグするために使用するGDBのコマンドです。</p>
<pre><code class="language-console">$ sudo dnf install \
  arm-none-eabi-gdb \
  minicom \
  openocd
</code></pre>
<ul>
<li>Arch Linux</li>
</ul>
<!-- 
> **NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug ARM
> Cortex-M programs
 -->
<p><strong>注記</strong> <code>arm-none-eabi-gdb</code>は、ARM Cortex-Mプログラムをデバッグするために使用するGDBのコマンドです。</p>
<pre><code class="language-console">$ sudo pacman -S \
  arm-none-eabi-gdb \
  minicom
</code></pre>
<!-- 
`openocd` is not available in the official Arch repositories, but can be installed from the [AUR](https://aur.archlinux.org/packages/openocd/) or can be compiled from source as follows:
 -->
<p><code>openocd</code>は、公式のArchレポジトリから入手できません。しかし、<a href="https://aur.archlinux.org/packages/openocd/">AUR</a>からインストールするか、
次のようにソースからコンパイルすることができます。</p>
<pre><code class="language-console">git clone git://git.code.sf.net/p/openocd/code openocd-code
cd openocd-code
./bootstrap
./configure
make &amp;&amp; make install
</code></pre>
<!-- - `arm-none-eabi-gdb` for other distros -->
<ul>
<li>他ディストリビューションにおける<code>arm-none-eabi-gdb</code></li>
</ul>
<!-- 
For distros that don't have packages for [ARM's pre-built
toolchain](https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads),
download the "Linux 64-bit" file and put its `bin` directory on your path.
Here's one way to do it:
 -->
<p>パッケージが用意されていないディストリビューションについては、
<a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">ARM's pre-built toolchain</a>から「Linux 64-bit」ファイルをダウンロードして、
<code>bin</code>ディレクトリにパスを通して下さい。
下記は、やり方の1例です。</p>
<pre><code class="language-console">$ mkdir -p ~/local &amp;&amp; cd ~/local
$ tar xjf /path/to/downloaded/file/gcc-arm-none-eabi-7-2017-q4-major-linux.tar.bz2.tbz
</code></pre>
<!-- 
Then, use your editor of choice to append to your `PATH` in the appropriate
shell init file (e.g. `~/.zshrc` or `~/.bashrc`):
 -->
<p>次に、エディタを使って、適切なシェル初期化ファイル（例えば、<code>~/.zshrc</code>や<code>~/.bashrc</code>）の<code>PATH</code>を追加して下さい。</p>
<pre><code>PATH=$PATH:$HOME/local/gcc-arm-none-eabi-7-2017-q4-major/bin
</code></pre>
<!-- ## Optional packages -->
<h2><a class="header" href="#オプションのパッケージ" id="オプションのパッケージ">オプションのパッケージ</a></h2>
<ul>
<li>Ubuntu / Debian</li>
</ul>
<pre><code class="language-console">$ sudo apt-get install \
  bluez \
  rfkill
</code></pre>
<ul>
<li>Fedora</li>
</ul>
<pre><code class="language-console">$ sudo dnf install \
  bluez \
  rfkill
</code></pre>
<ul>
<li>Arch Linux</li>
</ul>
<pre><code class="language-console">$ sudo pacman -S \
  bluez \
  bluez-utils \
  rfkill
</code></pre>
<!-- ## udev rules -->
<h2><a class="header" href="#udevルール" id="udevルール">udevルール</a></h2>
<!-- 
These rules let you use USB devices like the F3 and the Serial module without root privilege, i.e.
`sudo`.
 -->
<p>このルールにより、ルート権限（つまり<code>sudo</code>）なしで、F3とシリアルモジュールのようなUSBデバイスを使えるようにします。</p>
<!-- Create these two files in `/etc/udev/rules.d` with the contents shown below. -->
<p>下記の内容で、<code>/etc/udev/rules.d</code>ディレクトリに2つのファイルを作成します。</p>
<pre><code class="language-console">$ cat /etc/udev/rules.d/99-ftdi.rules
</code></pre>
<pre><code class="language-text"># FT232 - USB &lt;-&gt; Serial Converter
ATTRS{idVendor}==&quot;0403&quot;, ATTRS{idProduct}==&quot;6001&quot;, MODE:=&quot;0666&quot;
</code></pre>
<pre><code class="language-console">$ cat /etc/udev/rules.d/99-openocd.rules
</code></pre>
<pre><code class="language-text"># STM32F3DISCOVERY rev A/B - ST-LINK/V2
ATTRS{idVendor}==&quot;0483&quot;, ATTRS{idProduct}==&quot;3748&quot;, MODE:=&quot;0666&quot;

# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1
ATTRS{idVendor}==&quot;0483&quot;, ATTRS{idProduct}==&quot;374b&quot;, MODE:=&quot;0666&quot;
</code></pre>
<!-- Then reload the udev rules with: -->
<p>その後、udevルールをリロードします。</p>
<pre><code class="language-console">$ sudo udevadm control --reload-rules
</code></pre>
<!-- If you had any board plugged to your laptop, unplug them and then plug them in again. -->
<p>既にボードをノートPCに接続している場合、一度抜いてから、もう一度接続します。</p>
<!-- Now, go to the [next section]. -->
<p>それでは、<a href="03-setup/verify.html">次のセクション</a>に進んで下さい。</p>
<!-- [next section]: verify.md -->
<h1><a class="header" href="#windows" id="windows">Windows</a></h1>
<h2><a class="header" href="#arm-none-eabi-gdb" id="arm-none-eabi-gdb"><code>arm-none-eabi-gdb</code></a></h2>
<!-- 
ARM provides `.exe` installers for Windows. Grab one from [here][gcc], and follow the instructions.
Just before the installation process finishes tick/select the "Add path to environment variable"
option. Then verify that the tools are in your `%PATH%`:
 -->
<p>ARMはWindows向けに<code>.exe</code>インストーラを提供しています。<a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">ここ</a>から1つを入手して、手順に従って下さい。
インストールプロセスが終了する直前に&quot;環境変数にパスを追加&quot;オプションを選択します。
その後、ツールが<code>%PATH%</code>にあることを確認します。</p>
<pre><code class="language-console">$ arm-none-eabi-gcc -v
(..)
gcc version 5.4.1 20160919 (release) (..)
</code></pre>
<h2><a class="header" href="#openocd" id="openocd">OpenOCD</a></h2>
<!-- 
There's no official binary release of OpenOCD for Windows but there are unofficial releases
available [here][openocd]. Grab the 0.10.x zipfile and extract it somewhere in your drive (I
recommend `C:\OpenOCD` but with the drive letter that makes sense to you) then update your `%PATH%`
environment variable to include the following path: `C:\OpenOCD\bin` (or the path that you used
before).
 -->
<p>Windows用のOpenOCDの公式バイナリはありませんが、<a href="https://github.com/gnu-mcu-eclipse/openocd/releases">こちら</a>の非公式なリリースが利用可能です。
0.10.xのzipファイルを入手し、ハードディスクのどこかに展開して下さい(<code>C:\OpenOCD</code>をお勧めしますが、あなたが分かるドライブ名を使用してください)。
その後、<code>%PATH%</code>環境変数が<code>C:\OpenOCD\bin</code>(もしくはあなたがOpenOCDのzipファイルを展開したパス)を含むように更新します。</p>
<!-- 
Verify that OpenOCD is in yout `%PATH%` with: -->
<p>OpenOCDが<code>%PATH%</code>にあることを確認します。</p>
<pre><code class="language-console">$ openocd -v
Open On-Chip Debugger 0.10.0
(..)
</code></pre>
<h2><a class="header" href="#putty" id="putty">PuTTY</a></h2>
<!-- Download the latest `putty.exe` from [this site] and place it somewhere in your `%PATH%`. -->
<p><a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/download.html">このサイト</a>から最新の<code>putty.exe</code>をダウンロードし、<code>%PATH%</code>が通っているどこかに置いて下さい。</p>
<!-- [this site]: http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html -->
<h2><a class="header" href="#st-link-usb-driver" id="st-link-usb-driver">ST-LINK USB driver</a></h2>
<!-- 
You'll also need to install [this USB driver] or OpenOCD won't work. Follow the installer
instructions and make sure you install the right (32-bit or 64-bit) version of the driver.
 -->
<p><a href="http://www.st.com/en/embedded-software/stsw-link009.html">このUSBドライバ</a>もインストールする必要があります。そうでなければOpenOCDは動きません。インストーラの手順に従って下さい。
そして、正しいドライバのバージョン(32ビットか64ビット)をインストールすることを確認して下さい。</p>
<!-- [this USB driver]: http://www.st.com/en/embedded-software/stsw-link009.html -->
<!-- That's all! Go to the [next section]. -->
<p>以上です！<a href="03-setup/verify.html">次のセクション</a>に進んで下さい。</p>
<!-- [next section]: verify.md -->
<h1><a class="header" href="#macos" id="macos">macOS</a></h1>
<!-- All the tools can be install using [Homebrew]: -->
<p>全てのツールは、<a href="http://brew.sh/">Homebrew</a>を使ってインストールできます。</p>
<pre><code class="language-console">$ brew cask install gcc-arm-embedded

$ brew install minicom openocd
</code></pre>
<!-- 
If the `brew cask` command doesn't work (`Error: Unknown command: cask`), then run `brew tap
Caskroom/tap` first and try again.
 -->
<p><code>brew cask</code>コマンドがうまく動かない場合(例えば、<code>error: unknown command: cask</code>)、最初に<code>brew tap Caskroom/tap</code>を実行してから再実行して下さい。</p>
<!-- That's all! Go to the [next section]. -->
<p>以上です！<a href="03-setup/verify.html">次のセクション</a>に進んで下さい。</p>
<!-- [next section]: verify.md -->
<!-- # Verify the installation -->
<h1><a class="header" href="#インストールの確認" id="インストールの確認">インストールの確認</a></h1>
<!-- Let's verify that all the tools were installed correctly. -->
<p>全てのツールが正しくインストールされているか、確認しましょう。</p>
<!-- ## Linux only -->
<h2><a class="header" href="#linuxのみ実行" id="linuxのみ実行">Linuxのみ実行</a></h2>
<!-- ### Verify permissions -->
<h3><a class="header" href="#パーミッションの確認" id="パーミッションの確認">パーミッションの確認</a></h3>
<!-- 
Connect the F3 to your laptop using an USB cable. Be sure to connect the cable to the "USB ST-LINK"
port, the USB port in the center of the edge of the board.
 -->
<p>USBケーブルを使って、ノートPCをF3に接続して下さい。
ボード端の中央にある「USB ST-LINK」とラベルが付いたものにケーブルを接続して下さい。</p>
<!-- 
The F3 should now appear as a USB device (file) in `/dev/bus/usb`. Let's find out how it got
enumerated:
 -->
<p>これで、F3が<code>/dev/bus/usb</code>にUSBデバイス（ファイル）として現れるはずです。
どのように番号付けされるか調べてみましょう。</p>
<pre><code class="language-console">$ lsusb | grep -i stm
Bus 003 Device 004: ID 0483:374b STMicroelectronics ST-LINK/V2.1
$ # ^^^        ^^^
</code></pre>
<!-- 
In my case, the F3 got connected to the bus #3 and got enumerated as the device #4. This means the
file `/dev/bus/usb/003/004` *is* the F3. Let's check its permissions:
 -->
<p>私の場合、F3は、3番目のバスに接続されて、4番目のデバイスとして番号付けされています。
これは、<code>/dev/bus/usb/003/004</code><em>が</em>F3であることを意味します。パーミッションを確認しましょう。</p>
<pre><code class="language-console">$ ls -l /dev/bus/usb/003/004
crw-rw-rw- 1 root root 189, 20 Sep 13 00:00 /dev/bus/usb/003/004
</code></pre>
<!-- 
The permissions should be `crw-rw-rw-`. If it's not ... then check your [udev
rules] and try re-loading them with:
 -->
<p>パーミッションは、<code>crw-rw-rw-</code>でなければなりません。もし違う場合、<a href="03-setup/linux.html#udev-rules">udevルール</a>を確認し、次のコマンドでリロードしてみて下さい。</p>
<!-- [udev rules]: linux.md#udev-rules -->
<pre><code class="language-console">$ sudo udevadm control --reload-rules
</code></pre>
<!-- Now let's repeat the procedure for the Serial module. -->
<p>上記の手順をシリアルモジュールについても繰り返します。</p>
<!-- Unplug the F3 and plug the Serial module. Now, figure out what's its associated file: -->
<p>F3を抜いて、シリアルモジュールを接続します。すると、関連するファイルが見つかります。</p>
<pre><code class="language-console">$ lsusb | grep -i ft232
Bus 003 Device 005: ID 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC
</code></pre>
<!-- In my case, it's the `/dev/bus/usb/003/005`. Now, check its permissions: -->
<p>私の場合、<code>/dev/bus/usb/003/005</code>です。パーミッションを確認します。</p>
<pre><code class="language-console">$ ls -l /dev/bus/usb/003/005
crw-rw-r-- 1 root root 189, 21 Sep 13 00:00 /dev/bus/usb/003/005
</code></pre>
<!-- As before, the permissions should be `crw-rw-r--`. -->
<p>前回同様、パーミッションは、<code>crw-rw-r--</code>でなければなりません。</p>
<!-- ## All -->
<h2><a class="header" href="#全てのos" id="全てのos">全てのOS</a></h2>
<!-- ### First OpenOCD connection -->
<h3><a class="header" href="#初めてのopenocd接続" id="初めてのopenocd接続">初めてのOpenOCD接続</a></h3>
<!-- 
First, connect the F3 to your laptop using an USB cable. Connect the cable to the USB port in the
center of edge of the board, the one that's labeled "USB ST-LINK".
 -->
<p>USBケーブルを使って、ノートPCをF3に接続して下さい。
ボード端の中央にある「USB ST-LINK」とラベルが付いたものにケーブルを接続して下さい。</p>
<!-- Two *red* LEDs should turn on right after connecting the USB cable to the board. -->
<p>ボードにUSBケーブルを接続した直後、2つの<em>赤い</em>LEDが点灯するはずです。</p>
<!-- Next, run this command: -->
<p>次に、このコマンドを実行して下さい。</p>
<pre><code class="language-console">$ # *nix
$ openocd -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg

$ # Windows
$ # 注記 cygwinユーザーは、-sフラグで問題があったと報告しています。もし、問題に遭遇した場合、
$ # `C:\OpenOCD\share\scripts`ディレクトリからopenocdを呼ぶことができます。
$ openocd -s C:\OpenOCD\share\scripts -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg
</code></pre>
<!-- > **NOTE** Windows users: `C:\OpenOCD` is the directory where you installed OpenOCD to. -->
<blockquote>
<p><strong>注記</strong> Windowsユーザーへ。<code>C:\OpenOCD</code>は、OpenOCDをインストールしたディレクトリです。</p>
</blockquote>
<!-- 
> **IMPORTANT** There is more than one hardware revision of the STM32F3DISCOVERY board. For older
> revisions, you'll need to change the "interface" argument to `-f interface/stlink-v2.cfg` (note:
> no `-1` at the end). Alternatively, older revisions can use `-f board/stm32f3discovery.cfg`
> instead of `-f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg`.
 -->
<blockquote>
<p><strong>重要</strong> STM32F3DISCOVERYボードには、2つ以上のハードウェアリビジョンが存在します。古いリビジョンのハードウェアについては、
「interface」引数を<code>-f interface/stlink-v2.cfg</code>に変更する必要が有ります（<code>-1</code>が最後についていないことに留意して下さい）
代わりに、古いリビジョンでは、<code>-f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg</code>の代わりに
<code>-f board/stm32f3discovery.cfg</code>を使用できます。</p>
</blockquote>
<!-- You should see output like this: -->
<p>次のような出力が確認できるはずです。</p>
<pre><code class="language-console">Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport &quot;hla_swd&quot;. To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.915608
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<!-- (If you don't ... then check the [general troubleshooting] instructions.) -->
<p>（確認できない場合、<a href="03-setup/../appendix/1-general-troubleshooting/index.html">トラブルシューティング</a>の手順を確認して下さい。）</p>
<!-- [general troubleshooting]: ../appendix/1-general-troubleshooting/index.html -->
<!-- `openocd` will block the terminal. That's fine. -->
<p><code>openocd</code>は端末をブロックします。それで問題ありません。</p>
<!-- 
Also, one of the red LEDs, the one closest to the USB port, should start oscillating between red
light and green light.
 -->
<p>また、赤いLEDの1つ（USBポートに一番近いもの）が、周期的に赤と緑に点灯し始めるはずです。</p>
<!-- That's it! It works. You can now close/kill `openocd`. -->
<p>これでおしまいです！ボードは動いています。それでは、<code>openocd</code>を終了できます。</p>
<!-- # Meet your hardware -->
<h1><a class="header" href="#ハードウェアとの出会い" id="ハードウェアとの出会い">ハードウェアとの出会い</a></h1>
<!-- Let's get familiar with the hardware we'll be working with. -->
<p>これから使用するハードウェアについて詳しくなりましょう。</p>
<!-- ## STM32F3DISCOVERY (the "F3") -->
<h2><a class="header" href="#stm32f3discoveryf3" id="stm32f3discoveryf3">STM32F3DISCOVERY（「F3」）</a></h2>
<p align="center">
<img title="F3" src="04-meet-your-hardware/../assets/f3.jpg">
</p>
<!-- We'll refer to this board as "F3" throughout this book. -->
<p>この本では、このボードを「F3」と呼びます。</p>
<!-- What does this board contain? -->
<p>このボードには何が搭載されているか見てみましょう。</p>
<!--
- A STM32F303VCT6 microcontroller. This microcontroller has
  - A single core ARM Cortex-M4F processor with hardware support for single precision floating point
    operations and a maximum clock frequency of 72 MHz.
 -->
<!--   - 256 KiB of "Flash" memory. (1 KiB = 10**24** bytes) -->
<!--   - 48 KiB of RAM. -->
<!--   - many "peripherals": timers, GPIO, I2C, SPI, USART, etc. -->
<!--   - lots of "pins" that are exposed in the two lateral "headers". -->
<!--   - **IMPORTANT** This microcontroller operates at (around) 3.3V. -->
<ul>
<li>STM32F303VCT6マイクロコントローラが1つ。このマイクロコントローラは次のものを搭載しています。
<ul>
<li>
<p>シングルコアのARM Cortex-M4Fプロセッサ。このプロセッサは単精度浮動小数点演算を行うハードウェアを搭載し、
最大72MHzのクロック周波数で動作します。</p>
</li>
<li>
<p>256 KiBの「Flash」メモリ（1 KiB = 10<strong>24</strong>バイト）</p>
</li>
<li>
<p>48 KiBのRAM</p>
</li>
<li>
<p>多くの「ペリフェラル」。タイマ、GPIO、I2C、SPI、USARTなど。</p>
</li>
<li>
<p>2つの横方向の「ヘッダー」に露出しているたくさんの「ピン」</p>
</li>
<li>
<p><strong>重要</strong> このマイクロコントローラは、（おおよそ）3.3Vで動作します。</p>
</li>
</ul>
</li>
</ul>
<!-- - An [accelerometer] and a [magnetometer][] (in a single package). -->
<ul>
<li><a href="https://en.wikipedia.org/wiki/Accelerometer">加速度計</a>1つと<a href="https://en.wikipedia.org/wiki/Magnetometer">磁力計</a>1つ（1つのパッケージ内にまとめられています）。</li>
</ul>
<!-- 
[accelerometer]: https://en.wikipedia.org/wiki/Accelerometer
[magnetometer]: https://en.wikipedia.org/wiki/Magnetometer
 -->
<!-- - A [gyroscope]. -->
<ul>
<li><a href="https://en.wikipedia.org/wiki/Gyroscope">ジャイロスコープ</a>が1つ</li>
</ul>
<!-- [gyroscope]: https://en.wikipedia.org/wiki/Gyroscope -->
<!-- - 8 user LEDs arranged in the shape of a compass -->
<ul>
<li>円形に配置された8個のユーザLED</li>
</ul>
<!-- 
- A second microcontroller: a STM32F103CBT. This microcontroller is actually part of an on-board
  programmer and debugger named ST-LINK and is connected to the USB port named "USB ST-LINK".
 -->
<ul>
<li>第2のマイクロコントローラ: STM32F103CBT。このマイクロコントローラは、実際には、ST-LINKというオンボードプログラマおよびデバッガの一部であり、
「USB ST-LINK」という名前のUSBポートに接続されています。</li>
</ul>
<!-- 
- There's a second USB port, labeled "USB USER" that is connected to the main microcontroller, the
  STM32F303VCT6, and can be used in applications.
 -->
<ul>
<li>「USB USER」というラベルが付いている第2のUSBポート。
このUSBポートは、メインマイクロコントローラ（STM32F303VCT6）に接続されており、アプリケーションで利用できます。</li>
</ul>
<!-- ## The Serial module -->
<h2><a class="header" href="#シリアルモジュール" id="シリアルモジュール">シリアルモジュール</a></h2>
<p align="center">
<img title="Serial module" src="04-meet-your-hardware/../assets/serial.jpg">
</p>
<!-- 
We'll use this module to exchange data between the microcontroller in the F3 and your laptop. This
module will be connected to your laptop using an USB cable. I won't say more at this point.
 -->
<p>このモジュールは、F3のマイクロコントローラとノートPCとの間でデータをやり取りするために使います。
このモジュールは、USBケーブルを使ってノートPCに接続されます。ここでは、これ以上言及しません。</p>
<!-- ## The Bluetooth module -->
<h2><a class="header" href="#bluetoothモジュール" id="bluetoothモジュール">Bluetoothモジュール</a></h2>
<p align="center">
<img title="The HC-05 Bluetooth module" src="04-meet-your-hardware/../assets/bluetooth.jpg">
</p>
<!-- 
This module has the exact same purpose as the serial module but it sends the data over Bluetooth
instead of over USB.
 -->
<p>このモジュールは、シリアルモジュールと全く同じ目的で使いますが、データはUSBの代わりにBluetooth経由で送信します。</p>
<!-- # LED roulette -->
<h1><a class="header" href="#ledルーレット" id="ledルーレット">LEDルーレット</a></h1>
<!-- Alright, let's start by building the following application: -->
<p>さて、次のアプリケーションをビルドするところから始めましょう。</p>
<p align="center">
<img src="https://i.imgur.com/0k1r2Lc.gif">
</p>
<!-- 
I'm going to give you a high level API to implement this app but don't worry we'll do low level
stuff later on. The main goal of this chapter is to get familiar with the *flashing* and debugging
process.
 -->
<p>私は、このアプリケーションを実装するための高レベルなAPIを提供します。しかし、心配しないで下さい。低レベルな事項も、後ほど扱います。
この章の主な目的は、<em>Flashに書き込むこと</em>とデバッグプロセスに慣れることです。</p>
<!-- 
Throughout this text we'll be using the starter code that's in the [discovery] repository. Make sure
you always have the latest version of the master branch because this website tracks that branch.
 -->
<p>この文書を通して、<a href="https://github.com/rust-embedded/discovery">discovery</a>レポジトリにあるスターターコードを使います。
常に手元のコードが、最新バージョンのmasterブランチであることを確かめて下さい。このウェブサイトは、masterブランチに追従しています。</p>
<!-- 
The starter code is in the `src` directory of that repository. Inside that directory there are more
directories named after each chapter of this book. Most of those directories are starter Cargo
projects.
 -->
<p>スターターコードは、discoveryレポジトリの<code>src</code>ディレクトリ内にあります。このディレクトリ内には、この本の各章の名前がついたディレクトリがあります。
ほとんどのこれらのディレクトリは、Cargoプロジェクトの開始地点です。</p>
<!-- Now, jump into the `src/05-led-roulette` directory. Check the `src/main.rs` file: -->
<p>それでは、<code>src/05-led-roulette</code>ディレクトリに飛び込みましょう。<code>src/main.rs</code>ファイルを確認して下さい。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use aux5::entry;

#[entry]
fn main() -&gt; ! {
    let _y;
    let x = 42;
    _y = x;

    // 無限ループ。このスタックフレームから抜けないためのものです。
    loop {}
}
</code></pre></pre>
<!-- 
Microcontroller programs are different from standard programs in two aspects: `#![no_std]` and
`#![no_main]`.
 -->
<p>マイクロコントローラのプログラムは2つの点で通常のプログラムとは異なります。<code>#![no_std]</code>と<code>#![no_main]</code>です。</p>
<!-- 
The `no_std` attribute says that this program won't use the `std` crate, which assumes an underlying
OS; the program will instead use the `core` crate, a subset of `std` that can run on bare metal
systems (i.e., systems without OS abstractions like files and sockets).
 -->
<p><code>no_std</code>アトリビュートは、プログラムが<code>std</code>クレートを使わないことを意味しています。stdクレートはOSが基盤として存在していることを前提としています。
マイクロコントローラのプログラムは、代わりに、<code>core</code>クレートを使います。
coreクレートは<code>std</code>のサブセットで、ベアメタルシステム（つまり、ファイルやソケットと言ったOSの抽象化なしに動作するシステム）で動作することができます。</p>
<!-- 
The `no_main` attribute says that this program won't use the standard `main` interface, which is
tailored for command line applications that receive arguments. Instead of the standard `main` we'll
use the `entry` attribute from the [`cortex-m-rt`] crate to define a custom entry point. In this
program we have named the entry point "main", but any other name could have been used. The entry
point function must have signature `fn() -> !`; this type indicates that the function can't return
-- this means that the program never terminates.
 -->
<p><code>no_main</code>アトリビュートは、このプログラムが標準の<code>main</code>インタフェースを使わないことを意味します。標準の<code>main</code>インタフェースは、
引数を受け取るコマンドラインアプリケーション向けに作られています。
カスタムエントリーポイントを定義するために、標準の<code>main</code>の代わりに、<a href="https://crates.io/crates/cortex-m-rt"><code>cortex-m-rt</code></a>から<code>entry</code>アトリビュートを使います。
このプログラムでは、「main」という名前のエントリーポイントを持ちますが、どのような名前でも使えます。
エントリーポイントの関数は<code>fn() -&gt; !</code>のシグネチャを持つ必要があります。このシグネチャ型は、関数が返らないことを示しています。
これは、このプログラムが停止しないことを意味します。</p>
<!-- 
If you are a careful observer, you'll also notice there is a `.cargo` directory in the Cargo project
as well. This directory contains a Cargo configuration file (`.cargo/config`) that tweaks the
linking process to tailor the memory layout of the program to the requirements of the target device.
This modified linking process is a requirement of the `cortex-m-rt` crate.
 -->
<p>注意深く観察すると、Cargoプロジェクトに<code>.cargo</code>ディレクトリがあることに気づくでしょう。
このディレクトリはCargoの設定ファイル（<code>.cargo/config</code>）を含んでいます。この設定ファイルは、
ターゲットデバイスで要求されるプログラムのメモリレイアウトに合わせて、リンクプロセスを微調整します。
この修正が加えられたリンクプロセスは、<code>cortex-m-rt</code>クレートで求められます。</p>
<!-- Alright, let's start by building this program. -->
<p>では、プログラムをビルドするところから始めましょう。</p>
<!-- # Build it -->
<h1><a class="header" href="#ビルド" id="ビルド">ビルド</a></h1>
<!-- 
The first step is to build our "binary" crate. Because the microcontroller has a different
architecture than your laptop we'll have to cross compile. Cross compiling in Rust land is as simple
as passing an extra `--target` flag to `rustc`or Cargo. The complicated part is figuring out the
argument of that flag: the *name* of the target.
 -->
<p>最初の一歩は、「バイナリ」クレートをビルドすることです。マイクロコントローラは、あなたのノートPCとアーキテクチャが異なるため、クロスコンパイルする必要が有ります。
Rustでのクロスコンパイルは、<code>rustc</code>かCargoに追加の<code>--target</code>フラグを渡すだけです。
複雑な部分は、フラグの引数、つまりターゲットの<em>名前</em>を見つけ出すことです。</p>
<!-- 
The microcontroller in the F3 has a Cortex-M4F processor in it. `rustc` knows how to cross compile
to the Cortex-M architecture and provides 4 different targets that cover the different processor
families within that architecture:
 -->
<p>F3のマイクロコントローラは、Cortex-M4Fプロセッサを搭載しています。
<code>rustc</code>は、Cortex-Mアーキテクチャ向けにクロスコンパイルする方法を知っており、4つの異なるターゲットを提供しています。
これらのターゲットは、Cortex-Mアーキテクチャの異なるプロセッサファミリを対象としています。</p>
<!-- 
- `thumbv6m-none-eabi`, for the Cortex-M0 and Cortex-M1 processors
- `thumbv7m-none-eabi`, for the Cortex-M3 processor
- `thumbv7em-none-eabi`, for the Cortex-M4 and Cortex-M7 processors
- `thumbv7em-none-eabihf`, for the Cortex-M4**F** and Cortex-M7**F** processors
 -->
<ul>
<li><code>thumbv6m-none-eabi</code>, Cortex-M0とCortex-M1プロセッサ向け</li>
<li><code>thumbv7m-none-eabi</code>, Cortex-M3プロセッサ向け</li>
<li><code>thumbv7em-none-eabi</code>, Cortex-M4とCortex-M7プロセッサ向け</li>
<li><code>thumbv7em-none-eabihf</code>, Cortex-M4<strong>F</strong>とCortex-M7<strong>F</strong>プロセッサ向け</li>
</ul>
<!-- 
For the F3, we'll to use the `thumbv7em-none-eabihf` target. Before cross compiling you have to
download pre-compiled version of the standard library (a reduced version of it actually) for your
target. That's done using `rustup`:
 -->
<p>F3に対しては、<code>thumbv7em-none-eabihf</code>ターゲットを使います。
クロスコンパイルする前に、あらかじめターゲット向けにコンパイルされた標準ライブラリ（実際にはその縮小版）をダウンロードしなければなりません。
<code>rustup</code>を使ってダウンロードできます。</p>
<pre><code class="language-console">$ rustup target add thumbv7em-none-eabihf
</code></pre>
<!-- 
You only need to do the above step once; `rustup` will re-install a new standard library
(`rust-std` component) whenever you update your toolchain.
 -->
<p>上記のコマンドは一度だけ実行する必要が有ります。<code>rustup</code>は、ツールチェインをアップデートするときに、
新しい標準ライブラリ（<code>rust-std</code>コンポーネント）を再インストールしてくれます。</p>
<!-- 
With the `rust-std` component in place you can now cross compile the program using Cargo:
 -->
<p><code>rust-std</code>コンポーネントがあれば、Cargoを使ってプログラムをクロスコンパイルできます。</p>
<pre><code class="language-console">$ # `src/05-led-roulette`ディレクトリにいることを確認して下さい
$ cargo build --target thumbv7em-none-eabihf
   Compiling semver-parser v0.7.0
   Compiling aligned v0.1.1
   Compiling libc v0.2.35
   Compiling bare-metal v0.1.1
   Compiling cast v0.2.2
   Compiling cortex-m v0.4.3
   (..)
   Compiling stm32f30x v0.6.0
   Compiling stm32f30x-hal v0.1.2
   Compiling aux5 v0.1.0 (file://$PWD/aux)
   Compiling led-roulette v0.1.0 (file://$PWD)
    Finished dev [unoptimized + debuginfo] target(s) in 35.84 secs
</code></pre>
<!-- 
> **NOTE** Be sure to compile this crate *without* optimizations. The provided Cargo.toml file and build command above will ensure optimizations are off. 
 -->
<blockquote>
<p><strong>注記</strong> このクレートを必ず最適化<em>なしで</em>コンパイルして下さい。提供しているCargo.tomlと上記のビルドコマンドは、最適化をオフにしています。</p>
</blockquote>
<!-- 
OK, now we have produced an executable. This executable won't blink any leds, it's just a simplified version that we will build upon later in the chapter. As a sanity check, let's verify that the produced executable is actually an ARM binary:
 -->
<p>OK、これで実行ファイルが作成されました。この実行ファイルは、LEDを点滅させません。これは、この章の後半でビルドする単純なものです。
正当性検査のため、作成した実行ファイルが本当にARMのバイナリかどうか確認してみましょう。</p>
<pre><code class="language-console">$ # `readelf -h target/thumbv7em-none-eabihf/debug/led-roulette`と同じです
$ cargo readobj --target thumbv7em-none-eabihf --bin led-roulette -- -file-headers
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0x0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x8000197
  Start of program headers:          52 (bytes into file)
  Start of section headers:          740788 (bytes into file)
  Flags:                             0x5000400
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         20
  Section header string table index: 18
</code></pre>
<!-- Next, we'll flash the program into our microcontroller. -->
<p>次は、このプログラムをマイクロコントローラのFlashに書き込みます。</p>
<!-- # Flash it -->
<h1><a class="header" href="#flashへの書き込み" id="flashへの書き込み">Flashへの書き込み</a></h1>
<!-- 
Flashing is the process of moving our program into the microcontroller's (persistent) memory. Once
flashed, the microcontroller will execute the flashed program every time it is powered on.
 -->
<p>Flashへの書き込みとは、マイクロコントローラの（永続）メモリにプログラムを移動するプロセスのことです。
一度、Flashへ書き込むと、マイクロコントローラは、電源が入るたびに書き込まれたプログラムを実行します。</p>
<!-- 
In this case, our `led-roulette` program will be the *only* program in the microcontroller memory.
By this I mean that there's nothing else running on the microcontroller: no OS, no "daemon",
nothing. `led-roulette` has full control over the device.
 -->
<p>今回の場合、<code>led-roulette</code>プログラムが、マイクロコントローラのメモリ内にある<em>唯一の</em>プログラムになります。
これは、マイクロコントローラ上で他には何も実行されないことを意味します。OSも「デーモン」もありません。
<code>led-roulette</code>は、デバイスを完全に制御できます。</p>
<!-- 
Onto the actual flashing. First thing we need is to do is launch OpenOCD. We did that in the
previous section but this time we'll run the command inside a temporary directory (`/tmp` on *nix;
`%TEMP%` on Windows).
 -->
<p>実際にFlashへ書き込みましょう。まず始めに、OpenOCDを起動する必要が有ります。これは、前のセクションで行いました。
しかし、今回はこのコマンドを一時ディレクトリ（*nixでは<code>/tmp</code>、Windowsでは<code>%TEMP%</code>）の中で実行します。</p>
<!-- 
Make sure the F3 is connected to your laptop and run the following commands on a new terminal.
 -->
<p>F3がノートPCに接続されていることを確認し、新しい端末で次のコマンドを実行して下さい。</p>
<pre><code class="language-console">$ # *nix
$ cd /tmp

$ # Windows
$ cd %TEMP%

$ # Windowsでは、追加で`-s %PATH_TO_OPENOCD%\share\scripts`が必要なことを思い出して下さい。
$ openocd \
  -f interface/stlink-v2-1.cfg \
  -f target/stm32f3x.cfg
</code></pre>
<!-- 
> **NOTE** Older revisions of the board need to pass slightly different arguments to
> `openocd`. Review [this section] for the details.
 -->
<blockquote>
<p><strong>注記</strong> ボードが古いリビジョンの場合、<code>openocd</code>に若干異なる引数を渡す必要があります。
詳細は<a href="05-led-roulette/../03-setup/verify.html#first-openocd-connection">このセクション</a>を見返して下さい。</p>
</blockquote>
<!-- [this section]: ../03-setup/verify.md#first-openocd-connection -->
<!-- The program will block; leave that terminal open. -->
<p>このプログラムは端末をブロックします。端末を開いたままにしておいて下さい。</p>
<!-- Now it's a good time to explain what this command is actually doing. -->
<p>さて、このコマンドが実際に何をやっているのか、説明するのに良いタイミングです。</p>
<!-- 
I mentioned that the F3 actually has two microcontrollers. One of them is used as a
programmer/debugger. The part of the board that's used as a programmer is called ST-LINK (that's what
STMicroelectronics decided to call it). This ST-LINK is connected to the target microcontroller
using a Serial Wire Debug (SWD) interface (this interface is an ARM standard so you'll run into it
when dealing with other Cortex-M based microcontrollers). This SWD interface can be used to flash
and debug a microcontroller. The ST-LINK is connected to the "USB ST-LINK" port and will appear as
a USB device when you connect the F3 to your laptop.
 -->
<p>F3が実際には2つのマイクロコントローラを搭載していると述べました。1つはプログラマ/デバッガとして使用されます。
プログラマとして使用されるボードの一部をST-LINKと呼びます（STマイクロエレクトロニクスがそう呼ぶと決めたからです）。
ST-LINKは、Serial Wire Debug (SWD) インタフェースを使ってターゲットのマイクロコントローラと接続されます
（SWDインタフェースはARMの標準なので、他のCortex-Mベースのマイクロコントローラを扱う時でも使うでしょう）。
SWDインタフェースは、マイクロコントローラのFlashに書き込み、デバッグするために使用されます。
ST-LINKは「USB ST-LINK」ポートに接続されています。そのため、F3をノートPCに接続した時に、USBデバイスとして現れます。</p>
<p align="center">
<img height=640 title="On-board ST-LINK" src="05-led-roulette/../assets/st-link.png">
</p>
<!-- 
As for OpenOCD, it's software that provides some services like a *GDB server* on top of USB
devices that expose a debugging protocol like SWD or JTAG.
 -->
<p>OpenOCDについては、SWDやJTAGのようなデバッグプロトコルを公開するUSBデバイスに、<em>GDBサーバー</em>のようなサービスを提供するソフトウェアです。</p>
<!-- 
Onto the actual command: those `.cfg` files we are using instruct OpenOCD to look for a ST-LINK USB
device (`interface/stlink-v2-1.cfg`) and to expect a STM32F3XX microcontroller
(`target/stm32f3x.cfg`) to be connected to the ST-LINK.
 -->
<p>実際のコマンドで、<code>.cfg</code>ファイルは、OpenOCDにST-LINK USBデバイスを探させて（<code>interface/stlink-v2-1.cfg</code>）、
STM32F3XXマイクロコントローラがST-LINKに接続されているのを求めています(<code>target/stm32f3x.cfg</code>)。</p>
<!-- The OpenOCD output looks like this: -->
<p>OpenOCDの出力は次のようになります。</p>
<pre><code class="language-console">Open On-Chip Debugger 0.9.0 (2016-04-27-23:18)
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport &quot;hla_swd&quot;. To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.919073
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<!-- 
The "6 breakpoints, 4 watchpoints" part indicates the debugging features the processor has
available.
 -->
<p>「6 breakpoints, 4 watchpoints」の部分は、プロセッサで利用可能なデバッグ機能を示しています。</p>
<!-- I mentioned that OpenOCD provides a GDB server so let's connect to that right now: -->
<p>OpenOCDはGDBサーバーの機能を提供すると言いました。それでは、早速接続してみましょう。</p>
<pre><code class="language-console">$ &lt;gdb&gt; -q target/thumbv7em-none-eabihf/debug/led-roulette
Reading symbols from target/thumbv7em-none-eabihf/debug/led-roulette...done.
(gdb)
</code></pre>
<!-- 
**NOTE**: `<gdb>` represents a GDB program capable of debugging ARM binaries.
This could be `arm-none-eabi-gdb`, `gdb-multiarch` or `gdb` depending on your
system -- you may have to try all three.
 -->
<p><strong>注記</strong> <code>&lt;gdb&gt;</code>は、ARMバイナリをデバッグできるGDBプログラムを意味しています。
これは、<code>arm-none-eabi-gdb</code>か<code>gdb-multiarch</code>か<code>gdb</code>です。
あなたのシステムに依存しているため、3つ全てを試してみる必要があるでしょう。</p>
<!-- 
This only opens a GDB shell. To actually connect to the OpenOCD GDB server, use the following
command within the GDB shell:
 -->
<p>まだGDBシェルを開いただけです。OpenOCDのGDBサーバーに実際に接続するためには、GDBシェル内で次のコマンドを実行します。</p>
<pre><code>(gdb) target remote :3333
Remote debugging using :3333
0x00000000 in ?? ()
</code></pre>
<!-- 
By default OpenOCD's GDB server listens on TCP port 3333 (localhost). This command is connecting to
that port.
 -->
<p>デフォルトでは、OpenOCDのGDBサーバーは3333番のTCPポート（localhost）で待ち受けています。
上記コマンドはこのポートへと接続します。</p>
<!-- After entering this command, you'll see new output in the OpenOCD terminal: -->
<p>上記コマンドを実行した後、次のような出力が、OpenOCDの端末に現れるでしょう。</p>
<pre><code class="language-diff"> Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
+Info : accepting 'gdb' connection on tcp/3333
+Info : device id = 0x10036422
+Info : flash size = 256kbytes
</code></pre>
<!-- Almost there. To flash the device, we'll use the `load` command inside the GDB shell: -->
<p>もう一歩です。デバイスのFlashに書き込むには、<code>load</code>コマンドをGDBシェル内で使います。</p>
<pre><code>(gdb) load
Loading section .vector_table, size 0x188 lma 0x8000000
Loading section .text, size 0x38a lma 0x8000188
Loading section .rodata, size 0x8 lma 0x8000514
Start address 0x8000188, load size 1306
Transfer rate: 6 KB/sec, 435 bytes/write.
</code></pre>
<!-- And that's it. You'll also see new output in the OpenOCD terminal. -->
<p>これで終わりです。OpenOCDの端末に新しい出力が見られるでしょう。</p>
<pre><code class="language-diff"> Info : flash size = 256kbytes
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+adapter speed: 950 kHz
+target state: halted
+target halted due to debug-request, current mode: Thread
+xPSR: 0x01000000 pc: 0x08000194 msp: 0x2000a000
+Info : Unable to match requested speed 8000 kHz, using 4000 kHz
+Info : Unable to match requested speed 8000 kHz, using 4000 kHz
+adapter speed: 4000 kHz
+target state: halted
+target halted due to breakpoint, current mode: Thread
+xPSR: 0x61000000 pc: 0x2000003a msp: 0x2000a000
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+Info : Unable to match requested speed 1000 kHz, using 950 kHz
+adapter speed: 950 kHz
+target state: halted
+target halted due to debug-request, current mode: Thread
+xPSR: 0x01000000 pc: 0x08000194 msp: 0x2000a000
</code></pre>
<!-- Our program is loaded, let's debug it! -->
<p>プログラムはロードされました。デバッグしてみましょう！</p>
<!-- # Debug it -->
<h1><a class="header" href="#デバッグ" id="デバッグ">デバッグ</a></h1>
<!-- We are already inside a debugging session so let's debug our program. -->
<p>既にデバッグセッションの中に居ます。プログラムをデバッグしてみましょう。</p>
<!-- 
After the `load` command, our program is stopped at its *entry point*. This is indicated by the
"Start address 0x8000XXX" part of GDB's output. The entry point is the part of a program that a
processor / CPU will execute first.
 -->
<p><code>load</code>コマンドの後、プログラムは、<em>エントリポイント</em>で停止しています。このことは、GDB出力の「Start address 0x8000XXX」という部分からわかります。
エントリポイントは、プロセッサ / CPUが最初に実行するプログラムの一部です。</p>
<!-- 
The starter project I've provided to you has some extra code that runs *before* the `main` function.
At this time, we are not interested in that "pre-main" part so let's skip right to the beginning of
the `main` function. We'll do that using a breakpoint:
 -->
<p>スタータープロジェクトでは、<code>main</code>関数の<em>前に</em>実行する追加のコードを提供しています。
ここでは、「mainの前の」部分には興味がないので、<code>main</code>関数の直前までスキップします。ブレイクポイントを使って、これができます。</p>
<pre><code>(gdb) break main
Breakpoint 1 at 0x800018c: file src/05-led-roulette/src/main.rs, line 10.

(gdb) continue
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, main () at src/05-led-roulette/src/main.rs:10
10          let x = 42;
</code></pre>
<!-- 
Breakpoints can be used to stop the normal flow of a program. The `continue` command will let the
program run freely *until* it reaches a breakpoint. In this case, until it reaches the `main`
function because there's a breakpoint there.
 -->
<p>ブレイクポイントは、プログラムの通常フローを停止するために使います。<code>continue</code>コマンドは、ブレイクポイントに到達する<em>まで</em>プログラムを実行します。
今回の場合、<code>main</code>関数に到達するまでです。なぜなら、そこにブレイクポイントがあるからです。</p>
<!-- 
Note that GDB output says "Breakpoint 1". Remember that our processor can only use six of these
breakpoints so it's a good idea to pay attention to these messages.
 -->
<p>GDBが「Breakpoint 1」と出力していることに留意して下さい。今回のプロセッサでは、6個のブレイクポイントしか使えないことを思い出して下さい。
これらのメッセージに注意を払うことは大事なことです。</p>
<!-- 
For a nicer debugging experience, we'll be using GDB's Text User Interface (TUI). To enter into that
mode, on the GDB shell enter the following command:
 -->
<p>より良いデバッグ経験のために、GDBのテキストユーザーインタフェース（TUI）を使います。
このモードに入るには、次のコマンドをGDBシェルに入力します。</p>
<pre><code>(gdb) layout src
</code></pre>
<!-- 
> **NOTE** Apologies Windows users. The GDB shipped with the GNU ARM Embedded Toolchain doesn't
> support this TUI mode `:-(`.
 -->
<blockquote>
<p><strong>注記</strong> Windowsユーザーの方はごめんなさい。GNU ARM Embedded Toolchainで配布されているGDBはTUIモードをサポートしていません<code>:-(</code>。</p>
</blockquote>
<p><img src="05-led-roulette/../assets/gdb-layout-src.png" alt="GDB session" title="GDB TUI" /></p>
<!-- At any point you can leave the TUI mode using the following command: -->
<p>次のコマンドで、いつでもTUIモードから抜けることができます。</p>
<pre><code>(gdb) tui disable
</code></pre>
<!-- 
OK. We are now at the beginning of `main`. We can advance the program statement by statement using
the `step` command. So let's use that twice to reach the `_y = x` statement. Once you've typed `step`
once you can just hit enter to run it
again.
 -->
<p>今、<code>main</code>の最初に居ます。<code>step</code>コマンドを使って、プログラムをステートメントごとに実行することができます。
<code>_y = x</code>ステートメントに到達するために、コマンドを2回使います。一度、<code>step</code>を入力すると、エンターを押すだけで、同じコマンドを再び実行できます。</p>
<pre><code>(gdb) step
14           _y = x;
</code></pre>
<!-- 
If you are not using the TUI mode, on each `step` call GDB will print back the current statement
along with its line number.
 -->
<p>TUIモードを使っていない場合、各<code>step</code>を呼ぶごとに、GDBは現在のステートメントを行番号と一緒に出力します。</p>
<!-- 
We are now "on" the `_y = x` statement; that statement hasn't been executed yet. This means that `x`
is initialized but `_y` is not. Let's inspect those stack/local variables using the `print` command:
 -->
<p>現在、<code>_y = x</code>ステートメントの「上」に居て、まだこのステートメントは実行されていません。
つまり、<code>x</code>は初期化されていますが、<code>_y</code>は初期化されていません。<code>print</code>コマンドを使って、スタック/ローカルな変数を調べてみましょう。</p>
<pre><code>(gdb) print x
$1 = 42

(gdb) print &amp;x
$2 = (i32 *) 0x10001ff4

(gdb) print _y
$3 = -536810104

(gdb) print &amp;_y
$4 = (i32 *) 0x10001ff0
</code></pre>
<!-- 
As expected, `x` contains the value `42`. `_y`, however, contains the value `-536810104` (?). Because
`_y` has not been initialized yet, it contains some garbage value.
 -->
<p>予想通り、<code>x</code>は<code>42</code>という値を格納しています。しかし、<code>_y</code>は、<code>-536810104</code> (?)という値を格納しています。
<code>_y</code>は、まだ初期化されていないため、ゴミが入っています。</p>
<!-- 
The command `print &x` prints the address of the variable `x`. The interesting bit here is that GDB
output shows the type of the reference: `i32*`, a pointer to an `i32` value. Another interesting
thing is that the addresses of `x` and `_y` are very close to each other: their addresses are just
`4` bytes apart.
 -->
<p><code>print &amp;x</code>コマンドは、変数<code>x</code>のアドレスを出力します。ここで興味深いことは、GDBが参照の型を出力することです。<code>i32*</code>は、<code>i32</code>のポインタ値です。
他におもしろい点は、<code>x</code>と<code>_y</code>のアドレスがお互いに非常に近いことです。これらのアドレスは、ちょうど<code>4</code>バイトだけ離れています。</p>
<!-- Instead of printing the local variables one by one, you can also use the `info locals` command: -->
<p>ローカル変数を1つずつ出力する代わりに、<code>info locals</code>コマンドを使うこともできます。</p>
<pre><code>(gdb) info locals
x = 42
_y = -536810104
</code></pre>
<!-- OK. With another `step`, we'll be on top of the `loop {}` statement: -->
<p>では、もう一度<code>step</code>を実行すると、<code>loop {}</code>ステートメントに到達します。</p>
<pre><code>(gdb) step
17          loop {}
</code></pre>
<!-- And `_y` should now be initialized. -->
<p>そして、<code>_y</code>は初期化されているはずです。</p>
<pre><code>(gdb) print _y
$5 = 42
</code></pre>
<!-- 
If we use `step` again on top of the `loop {}` statement, we'll get stuck because the program will
never pass that statement. Instead, we'll switch to the disassemble view with the `layout asm`
command and advance one instruction at a time using `stepi`. You can always switch back into Rust
source code view later by issuing the `layout src` command again.
 -->
<p><code>loop {}</code>ステートメント上で再度<code>step</code>を使うと、プログラムがそのステートメントを抜けることがないため、動けなくなります。
代わりに、<code>layout asm</code>コマンドで逆アセンブル画面に切り替えます。その上で、<code>stepi</code>を使って、1命令ずつ前に進めます。
<code>layout src</code>コマンドを使うことで、いつでもRustソースコード画面に戻ることができます。</p>
<!-- > **NOTE** If you used the `step` command by mistake and GDB got stuck, you can get unstuck by hitting `Ctrl+C`. -->
<blockquote>
<p><strong>注記</strong> 間違って<code>step</code>を使ってしまい、GDBが動かなくなった場合、<code>Ctrl+C</code>を打つことで、動けるようになります。</p>
</blockquote>
<pre><code>(gdb) layout asm
</code></pre>
<p><img src="05-led-roulette/../assets/gdb-layout-asm.png" alt="GDB session" title="GDB disassemble" /></p>
<!-- 
If you are not using the TUI mode, you can use the `disassemble /m` command to disassemble the
program around the line you are currently at.
 -->
<p>TUIモードを使っていない場合、<code>disassemble /m</code>コマンドを使うことで、現在実行中の行周辺のプログラムを逆アセンブルできます。</p>
<pre><code>(gdb) disassemble /m
Dump of assembler code for function main:
7       #[entry]
   0x08000188 &lt;+0&gt;:     sub     sp, #8
   0x0800018a &lt;+2&gt;:     movs    r0, #42 ; 0x2a

8       fn main() -&gt; ! {
9           let _y;
10          let x = 42;
   0x0800018c &lt;+4&gt;:     str     r0, [sp, #4]

11          _y = x;
   0x0800018e &lt;+6&gt;:     ldr     r0, [sp, #4]
   0x08000190 &lt;+8&gt;:     str     r0, [sp, #0]

12
13          // 無限ループ。このスタックフレームから抜けないためのものです。
14          loop {}
=&gt; 0x08000192 &lt;+10&gt;:    b.n     0x8000194 &lt;main+12&gt;
   0x08000194 &lt;+12&gt;:    b.n     0x8000194 &lt;main+12&gt;

End of assembler dump.
</code></pre>
<!-- See the fat arrow `=>` on the left side? It shows the instruction the processor will execute next. -->
<p>左側にある太矢印<code>=&gt;</code>が見えますか？これは、プロセッサが次に実行する命令を示しています。</p>
<!-- 
If not inside the TUI mode on each `stepi` command GDB will print the statement, the line number
*and* the address of the instruction the processor will execute next.
 -->
<p>TUIモードではない場合、各<code>stepi</code>コマンドにより、GDBはステートメントと、行番号、<em>および</em>プロセッサが次に実行する命令のアドレスを表示します。</p>
<pre><code>(gdb) stepi
0x08000194      14          loop {}

(gdb) stepi
0x08000194      14          loop {}
</code></pre>
<!-- One last trick before we move to something more interesting. Enter the following commands into GDB: -->
<p>さらに興味深いものに行く前に、最後のトリックがあります。GDBに次のコマンドを入力して下さい。</p>
<pre><code>(gdb) monitor reset halt
Unable to match requested speed 1000 kHz, using 950 kHz
Unable to match requested speed 1000 kHz, using 950 kHz
adapter speed: 950 kHz
target halted due to debug-request, current mode: Thread
xPSR: 0x01000000 pc: 0x08000196 msp: 0x10002000

(gdb) continue
Continuing.

Breakpoint 1, main () at src/05-led-roulette/src/main.rs:10
10          let x = 42;
</code></pre>
<!-- We are now back at the beginning of `main`! -->
<p><code>main</code>の最初に戻ってきます！</p>
<!-- 
`monitor reset halt` will reset the microcontroller and stop it right at the program entry point.
The following `continue` command will let the program run freely until it reaches the `main`
function that has a breakpoint on it.
 -->
<p><code>monitor reset halt</code>は、マイクロコントローラをリセットし、プログラムのエントリポイントで停止します。
続く<code>continue</code>コマンドは、ブレイクポイントがある<code>main</code>関数に到達するまで、プログラムを実行します。</p>
<!-- 
This combo is handy when you, by mistake, skipped over a part of the program that you were
interested in inspecting. You can easily roll back the state of your program back to its very
beginning.
 -->
<p>このコンボは、間違って調査の対象とするプログラムの一部をスキップしてしまったときに便利です。
プログラムの状態を、最初の状態に、簡単にロールバックすることができます。</p>
<!-- 
> **The fine print**: This `reset` command doesn't clear or touch RAM. That memory will retain its
> values from the previous run. That shouldn't be a problem though, unless your program behavior
> depends of the value of *uninitialized* variables but that's the definition of Undefined Behavior
> (UB).
 -->
<blockquote>
<p><strong>ただし書き</strong>：<code>reset</code>コマンドは、RAMをクリアしたり、触ったりしません。メモリは、前回実行した時の値を持ち続けています。
プログラムが、未定義動作の定義である<em>初期化されていない</em>変数の値に依存しない限り、このことは問題になりません。</p>
</blockquote>
<!-- We are done with this debug session. You can end it with the `quit` command. -->
<p>このデバッグセッションは完了です。<code>quit</code>コマンドでデバッグセッションを終了できます。</p>
<pre><code>(gdb) quit
A debugging session is active.

        Inferior 1 [Remote target] will be detached.

Quit anyway? (y or n) y
Detaching from program: $PWD/target/thumbv7em-none-eabihf/debug/led-roulette, Remote target
Ending remote debugging.
</code></pre>
<!-- 
> **NOTE** If the default GDB CLI is not to your liking check out [gdb-dashboard]. It uses Python to
> turn the default GDB CLI into a dashboard that shows registers, the source view, the assembly view
> and other things.
 -->
<blockquote>
<p><strong>注記</strong> デフォルトのGDBコマンドラインインタフェースが好みでない場合、<a href="https://github.com/cyrus-and/gdb-dashboard#gdb-dashboard">gdb-dashboard</a>を確認して下さい。
このツールは、Pythonを使用して、デフォルトのGDBコマンドラインインタフェースを、レジスタやソースコード、アセンブリなどを表示するダッシュボードに変換します。</p>
</blockquote>
<!-- 
Don't close OpenOCD though! We'll use it again and again later on. It's better
just to leave it running.
 -->
<p>ただし、OpenOCDは、終了しないで下さい！OpenOCDは、この後繰り返し使用します。
動作したままにしておくほうが良いです。</p>
<!-- What's next? The high level API I promised. -->
<p>次は何でしょうか？約束した高レベルのAPIです。</p>
<!-- # The `Led` and `Delay` abstractions -->
<h1><a class="header" href="#ledとdelayの抽象化" id="ledとdelayの抽象化"><code>Led</code>と<code>Delay</code>の抽象化</a></h1>
<!-- 
Now, I'm going to introduce two high level abstractions that we'll use to implement the LED roulette
application.
 -->
<p>これから、LEDルーレットアプリケーションを実装するための、2つの高レベルな抽象化を紹介します。</p>
<!-- 
The auxiliary crate, `aux5`, exposes an initialization function called `init`. When called this
function returns two values packed in a tuple: a `Delay` value and a `Leds` value.
 -->
<p>補助クレートの<code>aux5</code>は、<code>init</code>という初期化関数を公開しています。
この関数を呼び出すと、<code>Delay</code>と<code>Leds</code>の値からなるタプルが返ってきます。</p>
<!-- `Delay` can be used to block your program for a specified amount of milliseconds. -->
<p><code>Delay</code>は、ミリ秒単位で指定された時間の間、プログラムをブロックします。</p>
<!-- 
`Leds` is actually an array of eight `Led`s. Each `Led` represents one of the LEDs on the F3 board,
and exposes two methods: `on` and `off` which can be used to turn the LED on or off, respectively.
 -->
<p><code>Leds</code>は、8個の<code>Led</code>からなる配列です。各<code>Led</code>は、F3ボード上のLEDの1つを表しています。
そして、<code>on</code>と<code>off</code>という2つのメソッドを公開しており、それぞれ、LEDをオンまたはオフにします。</p>
<!-- Let's try out these two abstractions by modifying the starter code to look like this: -->
<p>スターターコードを次のように修正して、2つの抽象化を試してみましょう。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use aux5::{entry, prelude::*, Delay, Leds};

#[entry]
fn main() -&gt; ! {
    let (mut delay, mut leds): (Delay, Leds) = aux5::init();

    let half_period = 500_u16;

    loop {
        leds[0].on();
        delay.delay_ms(half_period);

        leds[0].off();
        delay.delay_ms(half_period);
    }
}
</code></pre></pre>
<!-- Now build it: -->
<p>ビルドします。</p>
<pre><code class="language-console">$ cargo build --target thumbv7em-none-eabihf
</code></pre>
<!-- 
> **NOTE** It's possible to forget to rebuild the program *before* starting a GDB session; this
> omission can lead to very confusing debug sessions. To avoid this problem you can call `cargo run`
> instead of `cargo build`; `cargo run` will build *and* start a debug session ensuring you never
> forget to recompile your program.
 -->
<blockquote>
<p><strong>注記</strong> GDBセッションを開始する<em>前</em>に、プログラムを再ビルドすることを忘れることがあります。このうっかりミスは、非常に混乱するデバッグセッションを作り上げます。
この問題を避けるために、<code>cargo build</code>ではなく<code>cargo run</code>を呼び出すことができます。
<code>cargo run</code>は、ビルド<em>と</em>デバッグセッションの開始を行い、プログラムの再コンパイル忘れが起きないようにしてくれます。</p>
</blockquote>
<!-- Now, we'll repeat the flashing procedure that we did in the previous section: -->
<p>次に、前のセクションで行ったとおり、Flashへの書き込み手順を繰り返します。</p>
<pre><code class="language-console">$ # これはプログラムのGDBセッションを開始します。バイナリのパスを指定する必要はありません。
$ arm-none-eabi-gdb -q target/thumbv7em-none-eabihf/debug/led-roulette
Reading symbols from target/thumbv7em-none-eabihf/debug/led-roulette...done.
(gdb) target remote :3333
Remote debugging using :3333
(..)

(gdb) load
Loading section .vector_table, size 0x188 lma 0x8000000
Loading section .text, size 0x3fc6 lma 0x8000188
Loading section .rodata, size 0xa0c lma 0x8004150
Start address 0x8000188, load size 19290
Transfer rate: 19 KB/sec, 4822 bytes/write.

(gdb) break main
Breakpoint 1 at 0x800018c: file src/05-led-roulette/src/main.rs, line 9.

(gdb) continue
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, main () at src/05-led-roulette/src/main.rs:9
9           let (mut delay, mut leds): (Delay, Leds) = aux5::init();
</code></pre>
<!-- 
OK. Let's step through the code. This time, we'll use the `next` command instead of `step`. The
difference is that the `next` command will step *over* function calls instead of going inside them.
 -->
<p>では、コードをステップ実行していきましょう。今回は、<code>step</code>の代わりに、<code>next</code>コマンドを使います。
<code>next</code>は、関数呼び出し時、関数内に入らずに、ステップ<em>オーバー</em>します。</p>
<pre><code>(gdb) next
11          let half_period = 500_u16;

(gdb) next
13          loop {

(gdb) next
14              leds[0].on();

(gdb) next
15              delay.delay_ms(half_period);
</code></pre>
<!-- 
After executing the `leds[0].on()` statement, you should see a red LED, the one pointing North,
turn on.
 -->
<p><code>leds[0].on()</code>ステートメント実行後、北を指し示す赤いLEDが点灯するはずです。</p>
<!-- Let's continue stepping over the program: -->
<p>プログラムのステップオーバー実行を続けます。</p>
<pre><code>(gdb) next
17              leds[0].off();

(gdb) next
18              delay.delay_ms(half_period);
</code></pre>
<!-- 
The `delay_ms` call will block the program for half a second but you may not notice because the
`next` command also takes some time to execute. However, after stepping over the `leds[0].off()`
statement you should see the red LED turn off.
 -->
<p><code>delay_ms</code>の呼び出しは、0.5秒の間プログラムをブロックしますが、それに気づかないかもしれません。
<code>next</code>コマンドの実行にいくらか時間がかかるためです。
しかし、<code>leds[0].off()</code>ステートメントをステップオーバーすると、赤いLEDが消灯するでしょう。</p>
<!-- You can already guess what this program does. Let it run uninterrupted using the `continue` command. -->
<p>すでに、このプログラムが何をするか、予測できているでしょう。<code>continue</code>コマンドを使って、中断せずに実行しましょう。</p>
<pre><code>(gdb) continue
Continuing.
</code></pre>
<!-- 
Now, let's do something more interesting. We are going to modify the behavior of our program using
GDB.
 -->
<p>次は、もっと面白いことをやります。GDBを使って、プログラムの動作を変更します。</p>
<!-- 
First, let's stop the infinite loop by hitting `Ctrl+C`. You'll probably end up somewhere inside
`Led::on`, `Led::off` or `delay_ms`:
 -->
<p>まずは、<code>Ctrl+C</code>を入力し、無限ループを停止します。<code>Led::on</code>か、<code>Led::off</code>か<code>delay_ms</code>内のどこかに居るでしょう。</p>
<pre><code>Program received signal SIGINT, Interrupt.
0x080033f6 in core::ptr::read_volatile (src=0xe000e010) at /checkout/src/libcore/ptr.rs:472
472     /checkout/src/libcore/ptr.rs: No such file or directory.
</code></pre>
<!-- 
In my case, the program stopped its execution inside a `read_volatile` function. GDB output shows
some interesting information about that: `core::ptr::read_volatile (src=0xe000e010)`. This means
that the function comes from the `core` crate and that it was called with argument `src =
0xe000e010`.
 -->
<p>私の場合、<code>read_volatile</code>関数の中で、プログラムの実行が停止していました。
GDBの出力は、<code>core::ptr::read_volatile (src=0xe000e010)</code>という面白い情報を示しています。
これは、この関数が<code>core</code>クレートから来ており、<code>src = 0xe000e010</code>という引数で呼び出されていることを意味します。</p>
<!-- 
Just so you know, a more explicit way to show the arguments of a function is to use the `info args`
command:
 -->
<p>ご存知の通り、関数の引数を表示するための、より明確な方法は、<code>info args</code>コマンドを使うことです。</p>
<pre><code>(gdb) info args
src = 0xe000e010
</code></pre>
<!-- 
Regardless of where your program may have stopped you can always look at the output of the
`backtrace` command (`bt` for short) to learn how it got there:
 -->
<p>どこでプログラムが停止したかに関わらず、<code>backtrace</code>コマンド（<code>bt</code>という省略形があります）を使って、
どのようにそこに到達したか、を見ることができます。</p>
<pre><code>(gdb) backtrace
#0  0x080033f6 in core::ptr::read_volatile (src=0xe000e010)
    at /checkout/src/libcore/ptr.rs:472
#1  0x08003248 in &lt;vcell::VolatileCell&lt;T&gt;&gt;::get (self=0xe000e010)
    at $REGISTRY/vcell-0.1.0/src/lib.rs:43
#2  &lt;volatile_register::RW&lt;T&gt;&gt;::read (self=0xe000e010)
    at $REGISTRY/volatile-register-0.2.0/src/lib.rs:75
#3  cortex_m::peripheral::syst::&lt;impl cortex_m::peripheral::SYST&gt;::has_wrapped (self=0x10001fbc)
    at $REGISTRY/cortex-m-0.5.7/src/peripheral/syst.rs:124
#4  0x08002d9c in &lt;stm32f30x_hal::delay::Delay as embedded_hal::blocking::delay::DelayUs&lt;u32&gt;&gt;::delay_us (self=0x10001fbc, us=500000)
    at $REGISTRY/stm32f30x-hal-0.2.0/src/delay.rs:58
#5  0x08002cce in &lt;stm32f30x_hal::delay::Delay as embedded_hal::blocking::delay::DelayMs&lt;u32&gt;&gt;::delay_ms (self=0x10001fbc, ms=500)
    at $REGISTRY/stm32f30x-hal-0.2.0/src/delay.rs:32
#6  0x08002d0e in &lt;stm32f30x_hal::delay::Delay as embedded_hal::blocking::delay::DelayMs&lt;u16&gt;&gt;::delay_ms (self=0x10001fbc, ms=500)
    at $REGISTRY/stm32f30x-hal-0.2.0/src/delay.rs:38
#7  0x080001ee in main () at src/05-led-roulette/src/main.rs:18
</code></pre>
<!-- `backtrace` will print a trace of function calls from the current function down to main. -->
<p><code>backtrace</code>は、現在の関数からmainまでの関数呼び出しのトレースを表示します。</p>
<!-- 
Back to our topic. To do what we are after, first, we have to return to the `main` function. We can
do that using the `finish` command. This command resumes the program execution and stops it again
right after the program returns from the current function. We'll have to call it several times.
 -->
<p>トピックに戻ります。やりたいことをやるためには、まず、<code>main</code>関数に戻る必要が有ります。
<code>finish</code>コマンドを使うことで、これができます。このコマンドは、プログラムの実行を再開し、プログラムが現在の関数から戻った直後に停止します。
複数回、このコマンドを呼び出します。</p>
<pre><code>(gdb) finish
cortex_m::peripheral::syst::&lt;impl cortex_m::peripheral::SYST&gt;::has_wrapped (self=0x10001fbc)
    at $REGISTRY/cortex-m-0.5.7/src/peripheral/syst.rs:124
124             self.csr.read() &amp; SYST_CSR_COUNTFLAG != 0
Value returned is $1 = 5

(gdb) finish
Run till exit from #0  cortex_m::peripheral::syst::&lt;impl cortex_m::peripheral::SYST&gt;::has_wrapped (
    self=0x10001fbc)
    at $REGISTRY/cortex-m-0.5.7/src/peripheral/syst.rs:124
0x08002d9c in &lt;stm32f30x_hal::delay::Delay as embedded_hal::blocking::delay::DelayUs&lt;u32&gt;&gt;::delay_us (
    self=0x10001fbc, us=500000)
    at $REGISTRY/stm32f30x-hal-0.2.0/src/delay.rs:58
58              while !self.syst.has_wrapped() {}
Value returned is $2 = false

(..)

(gdb) finish
Run till exit from #0  0x08002d0e in &lt;stm32f30x_hal::delay::Delay as embedded_hal::blocking::delay::DelayMs&lt;u16&gt;&gt;::delay_ms (self=0x10001fbc, ms=500)
    at $REGISTRY/stm32f30x-hal-0.2.0/src/delay.rs:38
0x080001ee in main () at src/05-led-roulette/src/main.rs:18
18              delay.delay_ms(half_period);
</code></pre>
<!-- We are back in `main`. We have a local variable in here: `half_period` -->
<p><code>main</code>に戻ってきました。<code>half_period</code>というローカル変数があります。</p>
<pre><code>(gdb) info locals
half_period = 500
delay = (..)
leds = (..)
</code></pre>
<!-- Now, we are going to modify this variable using the `set` command: -->
<p>次に、<code>set</code>コマンドを使って、この変数を書き換えます。</p>
<pre><code>(gdb) set half_period = 100

(gdb) print half_period
$1 = 100
</code></pre>
<!-- 
If you let program run free again using the `continue` command, you should see that the LED will
blink at a much faster rate now!
 -->
<p><code>continue</code>コマンドを使って、プログラムの実行すると、LEDが前より速く点滅するはずです！</p>
<!-- 
Question! What happens if you keep lowering the value of `half_period`? At what value of
`half_period` you can no longer see the LED blink?
 -->
<p>質問です！<code>half_period</code>の値を下げ続けるとどうなるでしょうか？
<code>half_period</code>の値がいくつになると、LEDの点滅が見えなくなるでしょうか？</p>
<!-- Now, it's your turn to write a program. -->
<p>次は、あなたがプログラムを書く番です。</p>
<!-- # The challenge -->
<h1><a class="header" href="#課題" id="課題">課題</a></h1>
<!-- 
You are now well armed to face a challenge! Your task will be to implement the application I showed
you at the beginning of this chapter.
 -->
<p>あなたは今、課題に取り組むための準備ができています！
あなたのタスクは、この章の初めに見せたアプリケーションを実装することです。</p>
<!-- Here's the GIF again: -->
<p>GIF画像を再掲載します。</p>
<p align="center">
<img src="https://i.imgur.com/0k1r2Lc.gif">
</p>
<!-- Also, this may help: -->
<p>こちらも助けになるでしょう。</p>
<p align="center">
<img src="05-led-roulette/../assets/timing-diagram.png">
</p>
<!-- 
This is a timing diagram. It indicates which LED is on at any given instant of time and for how long
each LED should be on. On the X axis we have the time in milliseconds. The timing diagram shows a
single period. This pattern will repeat itself every 800 ms. The Y axis labels each LED with a
cardinal point: North, East, etc. As part of the challenge you'll have to figure out how each
element in the `Leds` array maps to these cardinal points (hint: `cargo doc --open` `;-)`).
 -->
<p>これはタイミング図です。この図は、どのLEDがどの時点で点灯しているか、および、各LEDを点灯させる時間を示しています。
X軸はミリ秒単位です。このタイミング図は、1周期を示しています。このパターンを、800ミリ秒ごとに繰り返します。
Y軸は、各LEDのラベルを北、東、などの方位で名づけています。
課題の一部として、<code>Leds</code>配列のどの要素が、これらの方位点にマッピングされるかを見つけ出す必要が有ります（ヒント：<code>cargo doc --open</code> <code>;-)</code>）。</p>
<!-- 
Before you attempt this challenge, let me give you one last tip. Our GDB sessions always involve
entering the same commands at the beginning. We can use a `.gdb` file to execute some commands
right after GDB is started. This way you can save yourself the effort of having to enter them
manually on each GDB session.
 -->
<p>この課題に取り組む前に、最後の助言です。GDBセッションでは、常に同じコマンドを最初に入力することになります。
GDBを起動した直後に、いくつかのコマンドを実行するために、<code>.gdb</code>ファイルを使うことができます。
この方法により、各GDBセッションごとに手動でコマンド入力する労力を、減らすことができます。</p>
<!-- Place this `openocd.gdb` file in the root of the Cargo project, right next to the `Cargo.toml`: -->
<p>次の<code>openocd.gdb</code>ファイルをCargoプロジェクトのルート、つまり<code>Cargo.toml</code>のすぐ隣に、置いて下さい。。</p>
<pre><code class="language-console">$ cat openocd.gdb
</code></pre>
<pre><code class="language-text">target remote :3333
load
break main
continue
</code></pre>
<!-- Then modify the second line of the `.cargo/config` file: -->
<p>次に、<code>.cargo/config</code>ファイルの2行めを修正します。</p>
<pre><code class="language-console">$ cat .cargo/config
</code></pre>
<pre><code class="language-toml">[target.thumbv7em-none-eabihf]
runner = &quot;arm-none-eabi-gdb -q -x openocd.gdb&quot; # &lt;-
rustflags = [
  &quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;,
]
</code></pre>
<!-- 
With that in place, you should now be able to start a `gdb` session that will automatically flash
the program and jump to the beginning of `main`:
 -->
<p>これで、自動的にプログラムをFlashに書き込んで、<code>main</code>の先頭にジャンプする<code>gdb</code>セッションを開始できるはずです。</p>
<pre><code class="language-console">$ cargo run --target thumbv7em-none-eabihf
     Running `arm-none-eabi-gdb -q -x openocd.gdb target/thumbv7em-none-eabihf/debug/led-roulette`
Reading symbols from target/thumbv7em-none-eabihf/debug/led-roulette...done.
(..)
Loading section .vector_table, size 0x188 lma 0x8000000
Loading section .text, size 0x3b20 lma 0x8000188
Loading section .rodata, size 0xb0c lma 0x8003cc0
Start address 0x8003b1c, load size 18356
Transfer rate: 20 KB/sec, 6118 bytes/write.
Breakpoint 1 at 0x800018c: file src/05-led-roulette/src/main.rs, line 9.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, main () at src/05-led-roulette/src/main.rs:9
9           let (mut delay, mut leds): (Delay, Leds) = aux5::init();
(gdb)
</code></pre>
<!-- # My solution -->
<h1><a class="header" href="#解答例" id="解答例">解答例</a></h1>
<!-- What solution did you come up with? -->
<p>あなたの解答は、どのようになりましたか？</p>
<!-- Here's mine: -->
<p>私の解答は、次の通りです。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use aux5::{entry, prelude::*, Delay, Leds};

#[entry]
fn main() -&gt; ! {
    let (mut delay, mut leds): (Delay, Leds) = aux5::init();

    let ms = 50_u8;
    loop {
        for curr in 0..8 {
            let next = (curr + 1) % 8;

            leds[next].on();
            delay.delay_ms(ms);
            leds[curr].off();
            delay.delay_ms(ms);
        }
    }
}

</code></pre></pre>
<!-- One more thing! Check that your solution also works when compiled in "release" mode: -->
<p>もうひとつ！あなたの解答が「release」モードでコンパイルしても動作するか、確認して下さい。</p>
<pre><code class="language-console">$ cargo build --target thumbv7em-none-eabihf --release
</code></pre>
<!-- You can test it with this `gdb` command: -->
<p>次の<code>gdb</code>コマンドでテスト可能です。</p>
<pre><code class="language-console">$ # or, you could simply call `cargo run --target thumbv7em-none-eabihf --release`
$ arm-none-eabi-gdb target/thumbv7em-none-eabihf/release/led-roulette
$ #                                              ~~~~~~~
</code></pre>
<!-- 
Binary size is something we should always keep an eye on! How big is your solution? You can check
that using the `size` command on the release binary:
 -->
<p>バイナリサイズは、常に注意を払う必要があります！あなたの解答では、どの程度の大きさになりましたか？
リリースバイナリに<code>size</code>コマンドを使うことで、確認できます。</p>
<pre><code class="language-console">$ # size target/thumbv7em-none-eabihf/debug/led-rouletteと等価です
$ cargo size --target thumbv7em-none-eabihf --bin led-roulette -- -A
led-roulette  :
section               size        addr
.vector_table          392   0x8000000
.text                16404   0x8000188
.rodata               2924   0x80041a0
.data                    0  0x20000000
.bss                     4  0x20000000
.debug_str          602185         0x0
.debug_abbrev        24134         0x0
.debug_info         553143         0x0
.debug_ranges       112744         0x0
.debug_macinfo          86         0x0
.debug_pubnames      56467         0x0
.debug_pubtypes      94866         0x0
.ARM.attributes         58         0x0
.debug_frame        174812         0x0
.debug_line         354866         0x0
.debug_loc             534         0x0
.comment                75         0x0
Total              1993694

$ cargo size --target thumbv7em-none-eabihf --bin led-roulette --release -- -A
led-roulette  :
section              size        addr
.vector_table         392   0x8000000
.text                1826   0x8000188
.rodata                84   0x80008ac
.data                   0  0x20000000
.bss                    4  0x20000000
.debug_str          23334         0x0
.debug_loc           6964         0x0
.debug_abbrev        1337         0x0
.debug_info         40582         0x0
.debug_ranges        2936         0x0
.debug_macinfo          1         0x0
.debug_pubnames      5470         0x0
.debug_pubtypes     10016         0x0
.ARM.attributes        58         0x0
.debug_frame          164         0x0
.debug_line          9081         0x0
.comment               18         0x0
Total              102267
</code></pre>
<!-- > **NOTE** The Cargo project is already configured to build the release binary using LTO. -->
<blockquote>
<p><strong>注記</strong> このCargoプロジェクトは、LTOを使ってリリースバイナリをビルドするように設定されています。</p>
</blockquote>
<!-- 
Know how to read this output? The `text` section contains the program instructions. It's around 2KB
in my case. On the other hand, the `data` and `bss` sections contain variables statically allocated
in RAM (`static` variables). A `static` variable is being used in `aux5::init`; that's why it shows 4
bytes of `bss`.
 -->
<p>この出力をどう読めばよいか知っていますか？<code>text</code>セクションは、プログラムの命令を含んでいます。私の場合、約2KBです。
一方、<code>data</code>と<code>bss</code>セクションは、RAMに静的に割り当てられた変数（<code>static</code>変数）を含みます。
<code>aux5::init</code>で<code>static</code>変数を1つ使っています。そのため、<code>bss</code>のサイズは4バイトとなっています。</p>
<!-- 
One final thing! We have been running our programs from within GDB but our programs don't depend on
GDB at all. You can confirm this be closing both GDB and OpenOCD and then resetting the board by
pressing the black button on the board. The LED roulette application will run without intervention
of GDB.
 -->
<p>最後にもうひとつ！プログラムをGDB内で実行していますが、プログラムはGDBに全く依存していません。
GDBとOpenOCDを両方とも終了して、ボード上の黒いボタンを押してボードをリセットすることで、このことを確認できます。
LEDルーレットアプリケーションは、GDBの介入なしに動作します。</p>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, world!</a></h1>
<!-- 
> **HEADS UP** Several readers have reported that the "solder bridge" SB10 (see back of the board)
> on the STM32F3DISCOVERY, which is required to use the ITM and the `iprint!` macros shown below, is
> **not** soldered even though the [User Manual][] (page 21) says that it **should be**.
 -->
<blockquote>
<p><strong>注意</strong> <a href="http://www.st.com/resource/en/user_manual/dm00063382.pdf">ユーザーマニュアル</a>（page 21）ではんだ付け<strong>しなければならない</strong>と書いてあるにも関わらず、
STM32F3DISCOVERY上のSB10「はんだブリッジ」（ボードの裏を見て下さい）がはんだ付け<strong>されていない</strong>、と複数の読者が報告しています。
これは、後ほど出てくるITMと<code>iprint!</code>マクロを使うために必要です。</p>
</blockquote>
<!-- 
> **TL;DR** You have two options to fix this: Either **solder** the solder bridge SB10 or connect a
> wire between SWO and PB3 as shown in the picture below.
 -->
<blockquote>
<p><strong>TL;DR</strong> 2つの選択肢があります。SB10はんだブリッジを<strong>はんだ付けする</strong>か、下記写真の通りSW0とPB3の間をワイヤで接続するか、です。</p>
</blockquote>
<!-- [User Manual]: http://www.st.com/resource/en/user_manual/dm00063382.pdf -->
<p align="center">
<img height=640 title="Manual SWD connection" src="06-hello-world/../assets/f3-swd.png">
</p>
<hr />
<!-- Just a little more of helpful magic before we start doing low level stuff. -->
<p>低レベルのことを始める前に、もう少しだけ役立つ魔法を学んで下さい。</p>
<!-- Blinking an LED is like the "Hello, world" of the embedded world. -->
<p>LEDを点滅させることは、組込みの世界の「Hello, world」です。</p>
<!-- 
But in this section, we'll run a proper "Hello, world" program that prints stuff to your laptop
console.
 -->
<p>しかし、このセクションでは、ラップトップのコンソールに出力するちゃんとした「Hello, world」プログラムを実行します。</p>
<!-- 
Go to the `06-hello-world` directory. There's some starter code in it:
 -->
<p><code>06-hello-world</code>ディレクトリに移動して下さい。その中にスターターコードがあります。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux6::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let mut itm = aux6::init();

    iprintln!(&amp;mut itm.stim[0], &quot;Hello, world!&quot;);

    loop {}
}
</code></pre></pre>
<!-- 
The `iprintln` macro will format messages and output them to the microcontroller's *ITM*. ITM stands
for Instrumentation Trace Macrocell and it's a communication protocol on top of SWD (Serial Wire
Debug) which can be used to send messages from the microcontroller to the debugging host. This
communication is only *one way*: the debugging host can't send data to the microcontroller.
 -->
<p><code>iprintln</code>マクロは、メッセージを整え、マイクロコントローラの<em>ITM</em>に出力します。ITMは、Instrumentation Trace Macrocellの略であり、
SWD（Serial Wire Debug）の上で通信するプロトコルです。これは、マイクロコントローラからデバッグしているホストにメッセージを送るために使います。
この通信は、<em>一方向</em>だけです。デバッグしているホストは、マイクロコントローラにデータを送ることができません。</p>
<!-- 
OpenOCD, which is managing the debug session, can receive data sent through this ITM *channel* and
redirect it to a file.
 -->
<p>OpenOCDは、デバッグセッションを管理し、ITM<em>チャネル</em>を通して送信されたデータを受信し、ファイルにリダイレクトします。</p>
<!-- 
The ITM protocol works with *frames* (you can think of them as Ethernet frames). Each frame has a
header and a variable length payload. OpenOCD will receive these frames and write them directly to a
file without parsing them. So, if the microntroller sends the string "Hello, world!" using the
`iprintln` macro, OpenOCD's output file won't exactly contain that string.
 -->
<p>ITMプロトコルは、<em>フレーム</em>（イーサネットフレートのようなものだと考えて下さい）で動作します。各フレームは、ヘッダと可変長のペイロードを持ちます。
OpenOCDは、フレームを受信し、フレームを解析せずに、直接ファイルに書き込みます。
マイクロコントローラが、<code>iprintln</code>マクロを使用して「Hello, world!」という文字列を送信した場合、
OpenOCDの出力ファイルは、その文字列をそのまま含んでいるわけではありません。</p>
<!-- 
To retrieve the original string, OpenOCD's output file will have to be parsed. We'll use the
`itmdump` program to perform the parsing as new data arrives.
 -->
<p>元の文字列を復元するために、OpenOCDの出力ファイルを解析しなければなりません。
届いた新しいデータの解析を行うために、<code>itmdump</code>プログラムを使用します。</p>
<!-- 
You should have already installed the `itmdump` program during the [installation chapter].
 -->
<p>既に<code>itmdump</code>プログラムを<a href="06-hello-world/../03-setup/index.html#itmdump">インストールの章</a>でインストールしているはずです。</p>
<!-- [installation chapter]: ../03-setup/index.html#itmdump -->
<!-- 
In a new terminal, run this command inside the `/tmp` directory, if you are using a *nix OS, or from
within the `%TEMP%` directory, if you are running Windows. This should be the same directory from
where you are running OpenOCD.
 -->
<p>*nix OSを使っている場合、新しい端末の<code>/tmp</code>ディレクトリ下で、Windowsを使っている場合、<code>%TEMP%</code>ディレクトリ下で、
次のコマンドを実行して下さい。これはOpenOCDを実行しているのと、同じディレクトリである必要があります。</p>
<!-- 
> **NOTE** It's very important that both `itmdump` and `openocd` are running
from the same directory!
 -->
<blockquote>
<p><strong>注記</strong> <code>itmdump</code>と<code>openocd</code>との両方が、同じディレクトリで実行していることが、非常に重要です。</p>
</blockquote>
<pre><code class="language-console">$ # itmdumpする端末

$ # *nix
$ cd /tmp &amp;&amp; touch itm.txt

$ # Windows
$ cd %TEMP% &amp;&amp; type nul &gt;&gt; itm.txt

$ # 両方
$ itmdump -F -f itm.txt
</code></pre>
<!-- 
This command will block as `itmdump` is now watching the `itm.txt` file. Leave this terminal open.
 -->
<p>このコマンドは、<code>itmdump</code>が<code>itm.txt</code>を監視している間、ブロックします。この端末は開いたままにしておきます。</p>
<!-- Alright. Now, let's build the starter code and flash it into the microcontroller. -->
<p>では、スターターコードをビルドして、マイクロコントローラのFlashに書き込みましょう。</p>
<!-- 
To avoid passing the `--target thumbv7em-none-eabihf` flag to every Cargo invocation we can set a
default target in .cargo/config:
 -->
<p><code>--target thumbv7em-none-eabihf</code>フラグをCargo呼び出しごとに渡さなくて済むように、.cargo/configにデフォルトターゲットを設定できます。</p>
<pre><code class="language-diff"> [target.thumbv7em-none-eabihf]
 runner = &quot;arm-none-eabi-gdb -q -x openocd.gdb&quot;
 rustflags = [
   &quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;,
 ]

+[build]
+target = &quot;thumbv7em-none-eabihf&quot;
</code></pre>
<!-- Now if `--target` is not specified Cargo will assume that the target is `thumbv7em-none-eabihf`. -->
<p>これで、<code>--target</code>が指定されない場合、Cargoは、ターゲットが<code>thumbv7em-none-eabihf</code>だと想定しましす。</p>
<pre><code class="language-console">$ cargo run
Reading symbols from target/thumbv7em-none-eabihf/debug/hello-world...done.
(..)
Loading section .vector_table, size 0x400 lma 0x8000000
Loading section .text, size 0x27c4 lma 0x8000400
Loading section .rodata, size 0x744 lma 0x8002be0
Start address 0x8002980, load size 13064
Transfer rate: 18 KB/sec, 4354 bytes/write.
Breakpoint 1 at 0x8000402: file src/06-hello-world/src/main.rs, line 10.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, main () at src/06-hello-world/src/main.rs:10
10          let mut itm = aux6::init();
</code></pre>
<!-- 
Note that there's a `.gdbinit` at the root of the Cargo project. It's pretty similar to the one we
used in the previous section.
 -->
<p>Cargoプロジェクトのルートディレクトリに<code>.gdbinit</code>があることに留意して下さい。
これは、前のセクションで使ったものと非常によく似ています。</p>
<!-- 
Before we execute the `iprintln!` statement. We have to instruct OpenOCD to redirect the ITM output
into the same file that `itmdump` is watching.
 -->
<p><code>iprintln!</code>ステートメントを実行する前に、<code>itmdump</code>が監視しているファイルと同じファイルに対して、OpenOCDがITM出力をリダイレクトするように指示しなければなりません。</p>
<pre><code>(gdb) # ITMをグローバルに有効化し、itm.txtに全ての出力をリダイレクトします
(gdb) monitor tpiu config internal itm.txt uart off 8000000

(gdb) # ITMポート0を有効にします
(gdb) monitor itm port 0 on
</code></pre>
<!-- All should be ready! Now execute the `iprintln!` statement. -->
<p>全ての準備が整ったはずです！では、<code>iprintln</code>ステートメントを実行します。</p>
<pre><code>(gdb) next
12          iprintln!(&amp;mut itm.stim[0], &quot;Hello, world!&quot;);

(gdb) next
14          loop {}
</code></pre>
<!-- You should see some output in the `itmdump` terminal: -->
<p><code>itmdump</code>端末に、何らかの出力が見られるはずです。</p>
<pre><code class="language-console">$ itmdump -F -f itm.txt
(..)
Hello, world!
</code></pre>
<!-- Awesome, right? Feel free to use `iprintln` as a logging tool in the coming sections. -->
<p>素晴らしい、そう思いませんか？以降のセクションで<code>iprintln</code>をロギングツールとして、自由に活用して下さい。</p>
<!-- Next: That's not all! The `iprint!` macros are not the only thing that uses the ITM. `:-)` -->
<p>次：これで全てではありません！ITMを使うのは、<code>iprint!</code>マクロはだけではありません。<code>:-)</code></p>
<h1><a class="header" href="#panic" id="panic"><code>panic!</code></a></h1>
<!-- The `panic!` macro also sends its output to the ITM! -->
<p><code>panic!</code>マクロも出力をITMに送信します！</p>
<!-- Change the `main` function to look like this: -->
<p><code>main</code>関数を次のように変更して下さい。</p>
<pre><pre class="playground"><code class="language-rust">#[entry]
fn main() -&gt; ! {
    panic!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!-- 
Let's try this program. But before that let's update `openocd.gdb` to run that `monitor` stuff for
us during GDB startup:
 -->
<p>上のプログラムを試してみましょう。ただ、その前に、<code>monitor</code>に関連する処理をGDB起動時に実行するように、<code>openocd.gdb</code>を更新しましょう。</p>
<pre><code class="language-diff"> target remote :3333
 set print asm-demangle on
 set print pretty on
 load
+monitor tpiu config internal itm.txt uart off 8000000
+monitor itm port 0 on
 break main
 continue
</code></pre>
<!-- OK, now run it. -->
<p>それでは、実行します。</p>
<pre><code class="language-console">$ cargo run
(..)
Breakpoint 1, main () at src/06-hello-world/src/main.rs:10
10          panic!(&quot;Hello, world!&quot;);

(gdb) next
</code></pre>
<!-- You'll see some new output in the `itmdump` terminal. -->
<p><code>itmdump</code>端末に新しい出力が見えるでしょう。</p>
<pre><code class="language-console">$ # itmdump terminal
(..)
panicked at 'Hello, world!', src/06-hello-world/src/main.rs:10:5
</code></pre>
<!-- FIXME backtraces appear to be broken? -->
<!-- You won't get a `RUST_BACKTRACE` style backtrace in `itmdump`'s output, *but* -->
<!-- you can get the equivalent inside GDB. You already know the command: -->
<!-- ``` -->
<!-- (gdb) backtrace -->
<!-- #0  __bkpt () at asm/bkpt.s:3 -->
<!-- #1  0x08000224 in cortex_m::asm::bkpt () -->
<!--     at $REGISTRY/cortex-m-0.5.2/src/asm.rs:19 -->
<!-- #2  rust_begin_unwind (info=0x10001f84) at src/06-hello-world/auxiliary/src/lib.rs:31 -->
<!-- #3  0x08002548 in core::panicking::panic_fmt () at libcore/panicking.rs:92 -->
<!-- #4  0x080024d8 in core::panicking::panic () at libcore/panicking.rs:53 -->
<!-- #5  0x08000194 in hello_world::main () at src/06-hello-world/src/main.rs:14 -->
<!-- ``` -->
<!-- Ultimately, `panic!` is just another function call so you can see it leaves behind a trace of -->
<!-- function calls. -->
<!-- 
Another thing you can do is catch the panic *before* it does the logging by
putting a breakpoint on the `rust_begin_unwind` symbol.
 -->
<p>他にも、<code>rust_begin_unwind</code>シンボルにブレイクポイントを置くことで、ログ出力する<em>前</em>にパニックを捕捉することができます。</p>
<pre><code>(gdb) monitor reset halt
(..)
target halted due to debug-request, current mode: Thread
xPSR: 0x01000000 pc: 0x080026ba msp: 0x10002000

(gdb) break rust_begin_unwind
Breakpoint 2 at 0x80011d2: file $REGISTRY/panic-itm-0.4.0/src/lib.rs, line 46.

(gdb) continue
Continuing.

Breakpoint 2, rust_begin_unwind (info=0x10001fac) at $REGISTRY/panic-itm-0.4.0/src/lib.rs:46
46          interrupt::disable();
</code></pre>
<!-- 
You'll notice that nothing got printed on the `itmdump` console this time. If
you resume the program using `continue` then a new line will be printed.
 -->
<p>今回は、<code>itmdump</code>コンソールに何も表示されないことに気づくでしょう。
<code>continue</code>を使ってプログラムを再開すると、新しい行が表示されます。</p>
<!-- In a later section we'll look into other simpler communication protocols. -->
<p>後のセクションでは、他のより簡単な通信プロトコルを検討します。</p>
<!-- # Registers -->
<h1><a class="header" href="#レジスタ" id="レジスタ">レジスタ</a></h1>
<!-- It's time to explore what the `Led` API does under the hood. -->
<p><code>Led</code>のAPIが水面下で何をやっているか、を知る時が来ました。</p>
<!-- 
In a nutshell, it just writes to some special memory regions. Go into the `07-registers` directory
and let's run the starter code statement by statement.
 -->
<p>一言で言えば、いくつかの特別なメモリ領域に書き込みしているだけです。<code>07-registers</code>ディレクトリに移動し、スターターコードをステートメントごとに実行しましょう。</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux7::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    aux7::init();

    unsafe {
        // 魔法のアドレス！
        const GPIOE_BSRR: u32 = 0x48001018;

        // 「北」のLED（赤）を点灯します
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 9;

        // 「東」のLED（緑）を点灯します
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 11;

        // 「北」のLEDを消灯します
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (9 + 16);

        // 「東」のLEDを消灯します
        *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);
    }

    loop {}
}
</code></pre></pre>
<!-- What's this magic? -->
<p>この魔法は何でしょうか？</p>
<!-- 
The address `0x48001018` points to a *register*. A register is a special region of memory that
controls a *peripheral*. A peripheral is a piece of electronics that sits right next to the
processor within the microcontroller package and provides the processor with extra functionality.
After all, the processor, on its own, can only do math and logic.
 -->
<p><code>0x48001018</code>番地は、あるレジスタを指しています。レジスタは、メモリの特別な領域で、<em>ペリフェラル</em>を制御します。
ペリフェラルは電子部品で、マイクロコントローラパッケージ内のプロセッサのすぐ近くに配置され、プロセッサに追加機能を提供します。
結局のところ、プロセッサ単独では、計算と論理演算しかできません。</p>
<!-- 
This particular register controls General Purpose Input/Output (GPIO) *pins* (GPIO *is* a
peripheral) and can be used to *drive* each of those pins *low* or *high*.
 -->
<p><code>0x48001018</code>番地のレジスタは、汎用入出力（GPIO）<em>ピン</em>（GPIO<em>は</em>1つのペリフェラルです）を制御します。
そして、そのレジスタは、各ピンを<em>low</em>か<em>high</em>に駆動するために使用できます。</p>
<!-- ## An aside: LEDs, digital outputs and voltage levels -->
<h2><a class="header" href="#余談ledデジタル出力と電圧レベル" id="余談ledデジタル出力と電圧レベル">余談：LED、デジタル出力と電圧レベル</a></h2>
<!-- Drive? Pin? Low? High? -->
<p>駆動？ピン？Low？High？</p>
<!-- 
A pin is a electrical contact. Our microcontroller has several of them and some of them are
connected to LEDs. An LED, a Light Emitting Diode, will only emit light when voltage is applied to
it with a certain polarity.
 -->
<p>ピンは電気的な接点です。マイクロコントローラは、いくつものピンを持っており、そのうちのいくつかがLEDをに接続されています。
LED（Light Emitting Diode）は、所定の極性で電圧を供給した時のみ、光ります。</p>
<p align="center">
<img height=180 title="LED circuit" src="https://upload.wikimedia.org/wikipedia/commons/c/c9/LED_circuit.svg">
</p>
<!-- 
Luckily for us, the microcontroller's pins are connected to the LEDs with the right polarity. All
that we have to do is *output* some non-zero voltage through the pin to turn the LED on. The pins
attached to the LEDs are configured as *digital outputs* and can only output two different voltage
levels: "low", 0 Volts, or "high", 3 Volts. A "high" (voltage) level will turn the LED on whereas
a "low" (voltage) level will turn it off.
 -->
<p>幸運なことに、マイクロコントローラのピンは、正しい極性でLEDに接続されています。いくらかの電圧を、ピンを通じて<em>出力</em>するだけで、LEDを点灯できます。
LEDに接続されたピンは、<em>デジタル出力</em>として設定されており、2つの異なる電圧レベル（「low」が0ボルト、「high」が3ボルト）だけを出力できます。
「high」（電圧）レベルは、LEDを点灯します。一方、「low」（電圧）レベルは、LEDを消灯します。</p>
<!-- 
These "low" and "high" states map directly to the concept of digital logic. "low" is `0` or `false`
and "high" is `1` or `true`. This is why this pin configuration is known as digital output.
 -->
<p>これらの「low」と「high」状態は、デジタル論理の概念に直接結びつきます。「low」は<code>0</code>または<code>false</code>で
「high」は<code>1</code>または<code>true</code>です。これが、このピン設定がデジタル出力と呼ばれる理由です。</p>
<hr />
<!-- OK. But how can one find out what this register does? Time to RTRM (Read the Reference Manual)! -->
<p>このレジスタが何をするのか、はどのようにして見つければ良いのでしょうか？リファレンスマニュアルを読む時（RTRM; Read the Reference Manual）が来ました！</p>
<!-- # RTRM: Reading The Reference Manual -->
<h1><a class="header" href="#rtrm-リファレンスマニュアルを読む" id="rtrm-リファレンスマニュアルを読む">RTRM: リファレンスマニュアルを読む</a></h1>
<!-- 
I mentioned that the microcontroller has several pins. For convenience, these pins are grouped in
*ports* of 16 pins. Each port is named with a letter: Port A, Port B, etc. and the pins within each
port are named with numbers from 0 to 15.
 -->
<p>マイクロコントローラはいくつものピンがあると書きました。利便性のために、これらのピンは16ピンからなる<em>ポート</em>でグループ化されています。
各ポートは、ポートA、ポートBなどと呼ばれます。そして、各ポート内のピンは、0から15の数字で識別されます。</p>
<!-- 
The first thing we have to find out is which pin is connected to which LED. This information is in
the STM32F3DISCOVERY [User Manual] (You downloaded a copy, right?). In this particular section:
 -->
<p>まず最初に見つけなければならないことは、どのピンがどのLEDに接続されているか、です。
この情報は、STM32F3DISCOVERY <a href="http://www.st.com/resource/en/user_manual/dm00063382.pdf">ユーザーマニュアル</a>（コピーをダウンロードしましたね？）の次のセクションにあります。</p>
<!-- [User Manual]: http://www.st.com/resource/en/user_manual/dm00063382.pdf -->
<blockquote>
<p>Section 6.4 LEDs - Page 18</p>
</blockquote>
<!-- The manual says: -->
<p>マニュアルには次のように書いてあります。</p>
<!-- 
- `LD3`, the North LED, is connected to the pin `PE9`. `PE9` is the short form of: Pin 9 on Port E.
- `LD7`, the East LED, is connected to the pin `PE11`.
 -->
<ul>
<li><code>LD3</code>（北のLED）は<code>PE9</code>ピンに接続されています。<code>PE9</code>は、ポートEの9番ピンを省略した呼び方です。</li>
<li><code>LD7</code>（東のLED）は<code>PE11</code>に接続されています。</li>
</ul>
<!-- 
Up to this point, we know that we want to change the state of the pins PE9 and PE11 to turn the
North/East LEDs on/off. These pins are part of Port E so we'll have to deal with the `GPIOE`
peripheral.
 -->
<p>ここまでで、北/東のLEDをオン/オフするためには、PE9ピンとPE11ピンの状態を変えたいことがわかります。
これらのピンはポートEの一部であり。<code>GPIOE</code>ペリフェラルを制御しなければなりません。</p>
<!-- 
Each peripheral has a register *block* associated to it. A register block is a collection of
registers allocated in contiguous memory. The address at which the register block starts is known as
its base address. We need to figure out what's the base address of the `GPIOE` peripheral. That
information is in the following section of the microcontroller [Reference Manual]:
 -->
<p>各ペリフェラルは、関連するレジスタ<em>ブロック</em>を持っています。レジスタブロックは、連続したメモリに割り当てられたレジスタの集まりです。
レジスタブロックの開始アドレスは、ベースアドレスと呼ばれます。<code>GPIOE</code>ペリフェラルのベースアドレスが何か、を見つけ出す必要があります。
この情報は。マイクロコントローラの<a href="http://www.st.com/resource/en/reference_manual/dm00043574.pdf">リファレンスマニュアル</a>の次のセクションにあります。</p>
<!-- [Reference Manual]: http://www.st.com/resource/en/reference_manual/dm00043574.pdf -->
<blockquote>
<p>Section 3.2.2 Memory map and register boundary addresses - Page 51</p>
</blockquote>
<!-- The table says that base address of the `GPIOE` register block is `0x4800_1000`. -->
<p>この表では、<code>GPIOE</code>レジスタブロックのベースアドレスは<code>0x4800_1000</code>であると書いてあります。</p>
<!-- 
Each peripheral also has its own section in the documentation. Each of these sections ends with a
table of the registers that the peripheral's register block contains. For the `GPIO` family of
peripheral, that table is in:
 -->
<p>各ペリフェラルは、ドキュメント内にそのペリフェラルのセクションがあります。これらの各セクションは、ペリフェラルのレジスタブロックが内包するレジスタの表が最後に掲載されています。
ペリフェラルの<code>GPIO</code>については、その表は次の場所にあります。</p>
<blockquote>
<p>Section 11.4.12 GPIO register map - Page 243</p>
</blockquote>
<!-- 
We are interested in the register that's at an offset of `0x18` from the base address of the `GPIOE`
peripheral. According to the table, that would be the register `BSRR`.
 -->
<p><code>GPIOE</code>ペリフェラルのベースアドレスから<code>0x18</code>のオフセットにあるレジスタに関心が有ります。
表によると、そのレジスタは<code>BSRR</code>です。</p>
<!-- Now we need to jump to the documentation of that particular register. It's a few pages above in: -->
<p>続いて、下記ページにある<code>BSRR</code>レジスタのドキュメントに移ります。</p>
<blockquote>
<p>Section 11.4.7 GPIO port bit set/reset register (GPIOx_BSRR) - Page 240</p>
</blockquote>
<!-- Finally! -->
<p>ようやく！</p>
<!-- 
This is the register we were writing to. The documentation says some interesting things. First, this
register is write only ... so let's try reading its value `:-)`.
 -->
<p>このレジスタは、私たちが書き込みをしたレジスタです。ドキュメントは、いくつかの興味深いことを示しています。
第一に、このレジスタは書き込み専用です。試しに値を読んでみましょう<code>:-)</code>。</p>
<!-- 
We'll use GDB's `examine` command: `x`.
 -->
<p>GDBの<code>examine</code>コマンドである<code>x</code>を使います。</p>
<pre><code>(gdb) next
16              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 9;

(gdb) x 0x48001018
0x48001018:     0x00000000

(gdb) # nextコマンドは、北のLEDを点灯します
(gdb) next
19              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 11;

(gdb) x 0x48001018
0x48001018:     0x00000000
</code></pre>
<!-- Reading the register returns `0`. That matches what the documentation says. -->
<p>レジスタを読み込んだ結果は、<code>0</code>です。この結果は、ドキュメントに書かれていることと一致します。</p>
<!-- 
The other thing that the documentation says is that the bits 0 to 15 can be used to *set* the
corresponding pin. That is bit 0 sets the pin 0. Here, *set* means outputting a *high* value on
the pin.
 -->
<p>他のおもしろい点は、ドキュメントに、ビット0から15が関連するピンを<em>設定</em>するのに使うことができる、と書いてあることです。
<em>設定</em>は、<em>high</em>の値をピンに出力することを意味します。</p>
<!-- 
The documentation also says that bits 16 to 31 can be used to *reset* the corresponding pin. In this
case, the bit 16 resets the pin number 0. As you may guess, *reset* means outputting a *low* value
on the pin.
 -->
<p>ドキュメントは、ビット16から31はが関連するピンを<em>リセット</em>するために使用できる、とも書いてあります。この場合、ビット16は0番ピンをリセットします。
推測通り、<em>リセット</em>は、<em>low</em>の値をピンに出力することを意味します。</p>
<!-- Correlating that information with our program, all seems to be in agreement: -->
<p>この情報をプログラムと関連付けると、全てが合致しているようです。</p>
<!-- 
- Writing `1 << 9` (`BS9 = 1`)  to `BSRR`  sets `PE9` *high*. That turns the North LED *on*.

- Writing `1 << 11` (`BS11 = 1`) to `BSRR` sets `PE11` *high*. That turns the East LED *on*.

- Writing `1 << 25` (`BR9 = 1`) to `BSRR` sets `PE9` *low*. That turns the North LED *off*.

- Finally, writing `1 << 27` (`BR11 = 1`) to `BSRR` sets `PE11` *low*. That turns the East LED *off*.
 -->
<ul>
<li>
<p><code>1 &lt;&lt; 9</code> (<code>BS9 = 1</code>)を<code>BSRR</code>に書き込むことは、<code>PE9</code>に<em>high</em>を設定します。これは、北のLEDを<em>点灯</em>します。</p>
</li>
<li>
<p><code>1 &lt;&lt; 11</code> (<code>BS11 = 1</code>)を<code>BSRR</code>に書き込むことは、<code>PE11</code>に<em>high</em>を設定します。これは、東のLEDのを<em>点灯</em>します。</p>
</li>
<li>
<p><code>1 &lt;&lt; 25</code> (<code>BR9 = 1</code>)を<code>BSRR</code>に書き込むことは、<code>PE9</code>に<em>low</em>を設定します。これは、北のLEDをを<em>消灯</em>します。</p>
</li>
<li>
<p>最後に、<code>1 &lt;&lt; 27</code> (<code>BR11 = 1</code>)を<code>BSRR</code>に書き込むことは、<code>PE11</code>に<em>low</em>を設定します。これは、東のLEDのを<em>消灯</em>します。</p>
</li>
</ul>
<!-- # (mis)Optimization -->
<h1><a class="header" href="#誤った最適化" id="誤った最適化">（誤った）最適化</a></h1>
<!-- 
Reads/writes to registers are quite special. I may even dare to say that they are embodiment of side
effects. In the previous example we wrote four different values to the same register. If you didn't
know that address was a register, you may have simplified the logic to just write the final value `1
<< (11 + 16)` into the register.
 -->
<p>レジスタへの読み書きは、非常に特殊です。レジスタへの読み書きが、副作用の化身であることを、あえて明言することもあります。
前回のサンプルでは、4つの異なる値を同じレジスタに書き込みました。
そのアドレスがレジスタであることを知らなければ、最後の値である<code>1 &lt;&lt; (11 + 16)</code>だけをレジスタに書き込むように、ロジックを単純化するかもしれません。</p>
<!-- 
Actually, LLVM, the compiler's backend / optimizer, does not know we are dealing with a register and
will merge the writes thus changing the behavior of our program. Let's check that really quick.
 -->
<p>実際に、コンパイラのバックエンド/最適化であるLLVMは、レジスタを取り扱っていることを知りません。
そして、レジスタへの書き込みを結合し、プログラムの動作を変更します。このことを手軽にチェックします。</p>
<pre><code class="language-console">$ cargo run --release
(..)
Breakpoint 1, main () at src/07-registers/src/main.rs:9
9           aux7::init();

(gdb) next
25              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);

(gdb) disassemble /m
Dump of assembler code for function main:
7       #[entry]

8       fn main() -&gt; ! {
9           aux7::init();
   0x08000188 &lt;+0&gt;:     bl      0x800019c &lt;aux7::init&gt;
   0x0800018c &lt;+4&gt;:     movw    r0, #4120       ; 0x1018
   0x08000190 &lt;+8&gt;:     mov.w   r1, #134217728  ; 0x8000000
   0x08000194 &lt;+12&gt;:    movt    r0, #18432      ; 0x4800

10
11          unsafe {
12              // 魔法のアドレス！
13              const GPIOE_BSRR: u32 = 0x48001018;
14
15              // 「北」のLED（赤）を点灯します
16              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 9;
17
18              // 「東」のLED（緑）を点灯します
19              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 11;
20
21              // 「北」のLEDを消灯します
22              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (9 + 16);
23
24              // 「東」のLEDを消灯します
25              *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);
=&gt; 0x08000198 &lt;+16&gt;:    str     r1, [r0, #0]

26          }
27
28          loop {}
   0x0800019a &lt;+18&gt;:    b.n     0x800019a &lt;main+18&gt;

End of assembler dump.
</code></pre>
<!-- 
The state of the LEDs didn't change this time! The `str` instruction is the one that writes a value
to the register. Our *debug* (unoptimized) program had four of them, one for each write to the
register, but the *release* (optimized) program only has one.
 -->
<p>この場合、LEDの状態は変わりません！<code>str</code>命令は、値をレジスタに書き込み命令の1つです。
<em>debug</em>（最適化されていない）プログラムには、4つのstr命令があります。各命令は、レジスタに書き込みします。
しかし、<em>release</em>（最適化された）プログラムは、1つしかstr命令がありません。</p>
<!-- We can check that using `objdump`: -->
<p><code>objdump</code>を使って、このことを確認できます。</p>
<pre><code class="language-console">$ # cargo objdump -- -d -no-show-raw-insn -print-imm-hex -source target/thumbv7em-none-eabihf/debug/registersと同じです
$ cargo objdump --bin registers -- -d -no-show-raw-insn -print-imm-hex -source
registers:      file format ELF32-arm-little

Disassembly of section .text:
main:
; #[entry]
 8000188:       sub     sp, #0x18
; aux7::init();
 800018a:       bl      #0xbc
 800018e:       str     r0, [sp, #0x14]
 8000190:       b       #-0x2 &lt;main+0xa&gt;
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 9;
 8000192:       b       #-0x2 &lt;main+0xc&gt;
 8000194:       movw    r0, #0x1018
 8000198:       movt    r0, #0x4800
 800019c:       mov.w   r1, #0x200
 80001a0:       str     r1, [r0]
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; 11;
 80001a2:       b       #-0x2 &lt;main+0x1c&gt;
 80001a4:       movw    r0, #0x1018
 80001a8:       movt    r0, #0x4800
 80001ac:       mov.w   r1, #0x800
 80001b0:       str     r1, [r0]
 80001b2:       movs    r0, #0x19
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (9 + 16);
 80001b4:       mov     r1, r0
 80001b6:       cmp     r0, #0x9
 80001b8:       str     r1, [sp, #0x10]
 80001ba:       bvs     #0x54 &lt;main+0x8a&gt;
 80001bc:       b       #-0x2 &lt;main+0x36&gt;
 80001be:       ldr     r0, [sp, #0x10]
 80001c0:       and     r1, r0, #0x1f
 80001c4:       movs    r2, #0x1
 80001c6:       lsl.w   r1, r2, r1
 80001ca:       lsrs    r2, r0, #0x5
 80001cc:       cmp     r2, #0x0
 80001ce:       str     r1, [sp, #0xc]
 80001d0:       bne     #0x4c &lt;main+0x98&gt;
 80001d2:       b       #-0x2 &lt;main+0x4c&gt;
 80001d4:       movw    r0, #0x1018
 80001d8:       movt    r0, #0x4800
 80001dc:       ldr     r1, [sp, #0xc]
 80001de:       str     r1, [r0]
 80001e0:       movs    r0, #0x1b
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);
 80001e2:       mov     r2, r0
 80001e4:       cmp     r0, #0xb
 80001e6:       str     r2, [sp, #0x8]
 80001e8:       bvs     #0x42 &lt;main+0xa6&gt;
 80001ea:       b       #-0x2 &lt;main+0x64&gt;
 80001ec:       ldr     r0, [sp, #0x8]
 80001ee:       and     r1, r0, #0x1f
 80001f2:       movs    r2, #0x1
 80001f4:       lsl.w   r1, r2, r1
 80001f8:       lsrs    r2, r0, #0x5
 80001fa:       cmp     r2, #0x0
 80001fc:       str     r1, [sp, #0x4]
 80001fe:       bne     #0x3a &lt;main+0xb4&gt;
 8000200:       b       #-0x2 &lt;main+0x7a&gt;
 8000202:       movw    r0, #0x1018
 8000206:       movt    r0, #0x4800
 800020a:       ldr     r1, [sp, #0x4]
 800020c:       str     r1, [r0]
; loop {}
 800020e:       b       #-0x2 &lt;main+0x88&gt;
 8000210:       b       #-0x4 &lt;main+0x88&gt;
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (9 + 16);
 8000212:       movw    r0, #0x41bc
 8000216:       movt    r0, #0x800
 800021a:       bl      #0x3b28
 800021e:       trap
 8000220:       movw    r0, #0x4204
 8000224:       movt    r0, #0x800
 8000228:       bl      #0x3b1a
 800022c:       trap
; *(GPIOE_BSRR as *mut u32) = 1 &lt;&lt; (11 + 16);
 800022e:       movw    r0, #0x421c
 8000232:       movt    r0, #0x800
 8000236:       bl      #0x3b0c
 800023a:       trap
 800023c:       movw    r0, #0x4234
 8000240:       movt    r0, #0x800
 8000244:       bl      #0x3afe
 8000248:       trap
</code></pre>
<!-- 
How do we prevent LLVM from misoptimizing our program? We use *volatile* operations instead of plain
reads/writes:
 -->
<p>LLVMがプログラムに誤った最適化を行うのを、どのようにすれば防げるのでしょうか？通常の読み書きの代わりに、<em>volatile</em>操作を使います。</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use aux7::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    aux7::init();

    unsafe {
        // 魔法のアドレス！
        const GPIOE_BSRR: u32 = 0x48001018;

        // 「北」のLED（赤）を点灯します
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 9);

        // 「東」のLED（緑）を点灯します
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 11);

        // 「北」のLEDを消灯します
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (9 + 16));

        // 「東」のLEDを消灯します
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (11 + 16));
    }

    loop {}
}
</code></pre></pre>
<!-- If we look at the disassembly of this new program compiled in release mode: -->
<p>リリースモードでコンパイルされた新しいプログラムの逆アセンブルを見てみます。</p>
<pre><code class="language-console">$ cargo objdump --bin registers --release -- -d -no-show-raw-insn -print-imm-hex -source
registers:      file format ELF32-arm-little

Disassembly of section .text:
main:
; #[entry]
 8000188:       bl      #0x22
; aux7::init();
 800018c:       movw    r0, #0x1018
 8000190:       mov.w   r1, #0x200
 8000194:       movt    r0, #0x4800
 8000198:       str     r1, [r0]
 800019a:       mov.w   r1, #0x800
 800019e:       str     r1, [r0]
 80001a0:       mov.w   r1, #0x2000000
 80001a4:       str     r1, [r0]
 80001a6:       mov.w   r1, #0x8000000
 80001aa:       str     r1, [r0]
; loop {}
 80001ac:       b       #-0x4 &lt;main+0x24&gt;
</code></pre>
<!-- 
We see that the four writes (`str` instructions) are preserved. If you run it (use `stepi`), you'll
also see that behavior of the program is preserved.
 -->
<p>4つの書き込み（<code>str</code>命令）が、保たれていることがわかります。（<code>stepi</code>）を使って、これを実行すると、
プログラムの動作も保たれていることがわかります。</p>
<!-- # `0xBAAAAAAD` address -->
<h1><a class="header" href="#0xbaaaaaad番地" id="0xbaaaaaad番地"><code>0xBAAAAAAD</code>番地</a></h1>
<!-- Not all the peripheral memory can be accessed. Look at this program. -->
<p>全てのペリフェラルメモリがアクセスできるわけではありません。次のプログラムを見て下さい。</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use aux7::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    aux7::init();

    unsafe {
        ptr::read_volatile(0x4800_1800 as *const u32);
    }

    loop {}
}
</code></pre></pre>
<!-- 
This address is close to the `GPIOE_BSRR` address we used before but this address is *invalid*.
Invalid in the sense that there's no register at this address.
 -->
<p>このアドレスは、以前に使用した<code>GPIOE_BSRR</code>番地に近いですが、<em>不正</em>なアドレスです。
ここで言う不正とは、そのアドレスにレジスタがないことを意味します。</p>
<!-- Now, let's try it. -->
<p>では、次を試してみましょう。</p>
<pre><code class="language-console">$ cargo run
Breakpoint 3, main () at src/07-registers/src/main.rs:9
9           aux7::init();

(gdb) continue
Continuing.

Breakpoint 2, UserHardFault_ (ef=0x10001fc0)
    at $REGISTRY/cortex-m-rt-0.6.3/src/lib.rs:535
535         loop {
</code></pre>
<!-- 
We tried to do an invalid operation, reading memory that doesn't exist, so the processor raised an
*exception*, a *hardware* exception.
 -->
<p>不正な操作を試しました。存在していないメモリを読み込んだ結果、プロセッサは<em>例外</em>、つまり<em>ハードウェア例外</em>を発生させました。</p>
<!-- 
In most cases, exceptions are raised when the processor attempts to perform an invalid operation.
Exceptions break the normal flow of a program and force the processor to execute an *exception
handler*, which is just a function/subroutine.
 -->
<p>多くの場合、例外はプロセッサが不正な操作を実行しようとした時に発生します。
例外はプログラムの通常実行フローを停止し、プロセッサに<em>例外ハンドラ</em>を実行させます。
例外ハンドラは、1つの関数/サブルーチンです。</p>
<!-- 
There are different kind of exceptions. Each kind of exception is raised by different conditions and
each one is handled by a different exception handler.
 -->
<p>異なる種類の例外が存在します。各種の例外は、異なる条件で発生し、各々が異なる例外ハンドラで処理されます。</p>
<!-- 
The `aux7` crate depends on the `cortex-m-rt` crate which defines a default
*hard fault* handler, named `UserHardFault`, that handles the "invalid memory
address" exception. `openocd.gdb` placed a breakpoint on `HardFault`; that's why
the debugger halted your program while it was executing the exception handler.
We can get more information about the exception from the debugger. Let's see:
 -->
<p><code>aux7</code>クレートは、<code>cortex-m-rt</code>クレートに依存しています。<code>cortex-m-rt</code>クレートは、
<code>UserHardFault</code>と言うデフォルトの<em>ハードフォルトハンドラ</em>を定義しており、「不正なメモリアドレス」例外を処理します。
<code>openocd.gdb</code>は、<code>HardFault</code>にブレークポイントを設置しています。
そのため、デバッガは、例外ハンドラを実行するところでプログラムを停止しました。
デバッガから、例外に関するさらなる情報を得ることができます。見ていきましょう。</p>
<pre><code>(gdb) list
530
531     #[allow(unused_variables)]
532     #[doc(hidden)]
533     #[no_mangle]
534     pub unsafe extern &quot;C&quot; fn UserHardFault_(ef: &amp;ExceptionFrame) -&gt; ! {
535         loop {
536             // add some side effect to prevent this from turning into a UDF instruction
537             // see rust-lang/rust#28728 for details
538             atomic::compiler_fence(Ordering::SeqCst);
539         }
</code></pre>
<!-- 
`ef` is a snapshot of the program state right before the exception occurred. Let's inspect it:
 -->
<p><code>ef</code>は、例外が発生する直前のプログラムの状態のスナップショットです。中身を調べてみましょう。</p>
<pre><code>(gdb) print/x *ef
$1 = cortex_m_rt::ExceptionFrame {
  r0: 0x48001800,
  r1: 0x48001800,
  r2: 0xb,
  r3: 0xc,
  r12: 0xd,
  lr: 0x800019f,
  pc: 0x80028d6,
  xpsr: 0x1000000
}
</code></pre>
<!-- 
There are several fields here but the most important one is `pc`, the Program Counter register.
The address in this register points to the instruction that generated the exception. Let's
disassemble the program around the bad instruction.
 -->
<p>いくつかのフィールドがありますが、最も重要なものはプログラムカウンタレジスタの<code>pc</code>です。
このレジスタのアドレスは、例外を発生させた命令を指しています。
不正な命令の周辺プログラムを逆アセンブルしてみましょう。</p>
<pre><code>(gdb) disassemble /m ef.pc
Dump of assembler code for function core::ptr::read_volatile:
471     /checkout/src/libcore/ptr.rs: No such file or directory.
   0x080028ce &lt;+0&gt;:     sub     sp, #16
   0x080028d0 &lt;+2&gt;:     mov     r1, r0
   0x080028d2 &lt;+4&gt;:     str     r0, [sp, #8]

472     in /checkout/src/libcore/ptr.rs
   0x080028d4 &lt;+6&gt;:     ldr     r0, [sp, #8]
   0x080028d6 &lt;+8&gt;:     ldr     r0, [r0, #0]
   0x080028d8 &lt;+10&gt;:    str     r0, [sp, #12]
   0x080028da &lt;+12&gt;:    ldr     r0, [sp, #12]
   0x080028dc &lt;+14&gt;:    str     r1, [sp, #4]
   0x080028de &lt;+16&gt;:    str     r0, [sp, #0]
   0x080028e0 &lt;+18&gt;:    b.n     0x80028e2 &lt;core::ptr::read_volatile+20&gt;

473     in /checkout/src/libcore/ptr.rs
   0x080028e2 &lt;+20&gt;:    ldr     r0, [sp, #0]
   0x080028e4 &lt;+22&gt;:    add     sp, #16
   0x080028e6 &lt;+24&gt;:    bx      lr

End of assembler dump.
</code></pre>
<!-- 
The exception was caused by the `ldr r0, [r0, #0]` instruction, a read instruction. The instruction
tried to read the memory at the address indicated by the `r0` register. By the way, `r0` is a CPU
(processor) register not a memory mapped register; it doesn't have an associated address like, say,
`GPIO_BSRR`.
 -->
<p>例外は、読み込み命令の<code>ldr r0, [r0, #0]</code>が原因です。この命令は、<code>r0</code>レジスタが指しているアドレスのメモリを読もうとします。
ところで、<code>r0</code>は、CPU（プロセッサ）レジスタで、メモリマップドレジスタではありません。
つまり、このレジスタは、<code>GPIO_BSRR</code>のようなアドレスとは、関係がありません。</p>
<!-- 
Wouldn't it be nice if we could check what the value of the `r0` register was right at the instant
when the exception was raised? Well, we already did! The `r0` field in the `ef` value we printed
before is the value of `r0` register had when the exception was raised. Here it is again:
 -->
<p>例外が発生した時の<code>r0</code>レジスタの値が確認できると、良いと思いませんか？
既に確認できています！
ここまでに表示した<code>ef</code>の<code>r0</code>フィールドの値が、例外発生時の<code>r0</code>レジスタの値です。再掲載します。</p>
<pre><code>(gdb) p/x *ef
$1 = cortex_m_rt::ExceptionFrame {
  r0: 0x48001800,
  r1: 0x48001800,
  r2: 0xb,
  r3: 0xc,
  r12: 0xd,
  lr: 0x800019f,
  pc: 0x80028d6,
  xpsr: 0x1000000
}
</code></pre>
<!-- 
`r0` contains the value `0x4800_1800` which is the invalid address we called the `read_volatile`
function with.
 -->
<p><code>r0</code>は、<code>0x4800_1800</code>という値になっています。これは、<code>read_volatile</code>関数を呼ぶ時に指定した不正なアドレスです。</p>
<!-- # Spooky action at a distance -->
<h1><a class="header" href="#異なる場所での不気味な動作" id="異なる場所での不気味な動作">異なる場所での不気味な動作</a></h1>
<!-- 
`BSRR` is not the only register that can control the pins of Port E. The `ODR` register also lets
you change the value of the pins. Furthermore, `ODR` also lets you retrieve the current output
status of Port E.
 -->
<p>ポートEのピンを制御できるレジスタは、<code>BSRR</code>だけではありません。<code>ODR</code>レジスタもピンの値を変更できます。
さらに、<code>ODR</code>を使って、ポートEの現在の出力状態を取得できます。</p>
<!-- `ODR` is documented in: -->
<p><code>ODR</code>については、下記に書かれています。</p>
<blockquote>
<p>Section 11.4.6 GPIO port output data register - Page 239</p>
</blockquote>
<!-- Let's try this program: -->
<p>次のプログラムを試してみましょう。</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::ptr;

#[allow(unused_imports)]
use aux7::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let mut itm = aux7::init().0;

    unsafe {
        const GPIOE_BSRR: u32 = 0x4800_1018;
        const GPIOE_ODR: u32 = 0x4800_1014;

        iprintln!(
            &amp;mut itm.stim[0],
            &quot;ODR = 0x{:04x}&quot;,
            ptr::read_volatile(GPIOE_ODR as *const u16)
        );

        // 北のLEDの（赤）を点灯
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 9);

        iprintln!(
            &amp;mut itm.stim[0],
            &quot;ODR = 0x{:04x}&quot;,
            ptr::read_volatile(GPIOE_ODR as *const u16)
        );

        // 東のLEDの（緑）を点灯
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; 11);

        iprintln!(
            &amp;mut itm.stim[0],
            &quot;ODR = 0x{:04x}&quot;,
            ptr::read_volatile(GPIOE_ODR as *const u16)
        );

        // 北のLEDのを消灯
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (9 + 16));

        iprintln!(
            &amp;mut itm.stim[0],
            &quot;ODR = 0x{:04x}&quot;,
            ptr::read_volatile(GPIOE_ODR as *const u16)
        );

        // 東のLEDのを消灯
        ptr::write_volatile(GPIOE_BSRR as *mut u32, 1 &lt;&lt; (11 + 16));
    }

    loop {}
}
</code></pre></pre>
<!-- If you run this program, you'll see: -->
<p>このプログラムを実行すると、次の出力が得られます。</p>
<pre><code class="language-console">$ # itmdump's console
(..)
ODR = 0x0000
ODR = 0x0200
ODR = 0x0a00
ODR = 0x0800
</code></pre>
<!-- 
Side effects! Although we are reading the same address multiple times without actually modifying it,
we still see its value change every time `BSRR` is written to.
 -->
<p>副作用！実際の値を変更することなしに、複数回同じアドレスを読み込んでいるにも関わらず、毎回<code>BSRR</code>に書き込んだ値に変化していることがわかります。</p>
<!-- # Type safe manipulation -->
<h1><a class="header" href="#型安全な操作" id="型安全な操作">型安全な操作</a></h1>
<!-- The last register we were working with, `ODR`, had this in its documentation: -->
<p>前回の最後に取り扱った<code>ODR</code>レジスタは、ドキュメント内で次のように書かれています。</p>
<!-- > Bits 16:31 Reserved, must be kept at reset value -->
<blockquote>
<p>ビット16:31 予約済み, リセット値を保持しなければなりません</p>
</blockquote>
<!-- We are not supposed to write to those bits of the register or Bad Stuff May Happen. -->
<p>レジスタのこれらのビットには書き込んではいけないようです。そうでなければ、悪いことが起こるでしょう。</p>
<!-- 
There's also the fact the registers have different read/write permissions. Some of them are write
only, others can be read and wrote to and there must be others that are read only.
 -->
<p>レジスタは、異なる読み書きのパーミッションを持っている、という事実もあります。
書き込み専用のものもあれば、読み書き可能なものもあり、読み込み専用のものもあるはずです。</p>
<!-- 
Finally, directly working with hexadecimal addresses is error prone. You already saw that trying to
access an invalid memory address causes an exception which disrupts the execution of our program.
 -->
<p>最後に、16進数のアドレスを直接扱うことは、間違いを犯しやすいです。
既に不正なメモリアドレスへのアクセスが、プログラムの実行を中断する例外の原因になることを実験しました。</p>
<!-- 
Wouldn't it be nice if we had an API to manipulate registers in a "safe" manner? Ideally, the API
should encode these three points I've mentioned: No messing around with the actual addresses, should
respect read/write permissions and should prevent modification of the reserved parts of a register.
 -->
<p>「安全」な方法でレジスタを操作できるAPIがあると、良いと思いませんか？理想的には、そのAPIは、これまでに述べた3つの点をエンコードするべきです。
実際のアドレスを取り扱わない、読み/書きのパーミッションを守る、レジスタの予約済み部分を修正できないようにする。</p>
<!-- 
Well, we do! `aux7::init()` actually returns a value that provides a type safe API to manipulate the
registers of the  `GPIOE` peripheral.
 -->
<p>やりましょう！実は<code>aux7::init()</code>は、<code>GPIOE</code>ペリフェラルのレジスタを操作する、型安全なAPIを提供する値を返しています。</p>
<!-- 
As you may remember: a group of registers associated to a peripheral is called register block, and
it's located in a contiguous region of memory. In this type safe API each register block is modeled
as a `struct` where each of its fields represents a register. Each register field is a different
newtype over e.g. `u32` that exposes a combination of the following methods: `read`, `write` or
`modify` according to its read/write permissions. Finally, these methods don't take primitive values
like `u32`, instead they take yet another newtype that can be constructed using the builder pattern
and that prevent the modification of the reserved parts of the register.
 -->
<p>覚えているかもしれませんが、ペリフェラルに関連するレジスタのグループは、レジスタブロックと呼ばれており、連続したメモリ領域に位置しています。
この型安全なAPIでは、各レジスタブロックは、各フィールドがレジスタを表現する<code>struct</code>としてモデル化されています。
各レジスタのフィールドは、例えば<code>u32</code>の、異なる新しい型で、次のメソッドの組み合わせを提供します。
読み/書きのパーミッションに応じた<code>read</code>、<code>write</code>、または、<code>modify</code>です。
最後に、これらのメソッドは、<code>u32</code>のようなプリミティブな値を受け取りません。代わりに、ビルダーパターンを使って構築された、別の新しい型を受け付けます。
このことにより、レジスタの予約済み部分を修正できないようにしています。</p>
<!-- The best way to get familiar with this API is to port our running example to it. -->
<p>このAPIに慣れるための最善の方法は、プログラムを次のように移植することです。</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux7::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let gpioe = aux7::init().1;

    //　北のLEDを点灯
    gpioe.bsrr.write(|w| w.bs9().set_bit());

    // 東のLEDを点灯
    gpioe.bsrr.write(|w| w.bs11().set_bit());

    // 北のLEDのを消灯
    gpioe.bsrr.write(|w| w.br9().set_bit());

    // 東のLEDを消灯
    gpioe.bsrr.write(|w| w.br11().set_bit());

    loop {}
}
</code></pre></pre>
<!-- 
First thing you notice: There are no magic addresses involved. Instead we use a more human friendly
way, for example `gpioe.bsrr`, to refer to the `BSRR` register in the `GPIOE` register block.
 -->
<p>最初に気がつくことは、魔法のアドレスがないことです。代わりに、より人間が理解しやすい方法を使っています。
例えば、<code>gpioe.bsrr</code>は、<code>GPIOE</code>レジスタブロックの<code>BSRR</code>レジスタを意味しています。</p>
<!-- 
Then we have this `write` method that takes a closure. If the identity closure (`|w| w`) is used,
this method will set the register to its *default* (reset) value, the value it had right after the
microcontroller was powered on / reset. That value is `0x0` for the `BSRR` register. Since we want
to write a non-zero value to the register, we use builder methods like `bs9` and `br9` to set some
of the bits of the default value.
 -->
<p>そして、<code>write</code>メソッドは、クロージャを引数に取ります。アイデンティティクロージャ(<code>|w| w</code>)を使った場合、
このメソッドは、レジスタに<em>デフォルト</em>（リセット）値を設定します。デフォルト値は、マイクロコントローラが電源オン / リセットされた直後の値です。
<code>BSRR</code>レジスタでは、デフォルト値は<code>0x0</code>です。
レジスタにゼロでない値を書き込みたいので、デフォルト値のいくつかのビットを設定するために、<code>bs9</code>や<code>br9</code>のようなビルダーメソッドを使用します。</p>
<!-- Let's run this program! There's some interesting stuff we can do *while* debugging the program. -->
<p>このプログラムを実行してみましょう！プログラムをデバッグしている<em>間に</em>いくつかのおもしろいことができます。</p>
<!-- 
`gpioe` is a reference to the `GPIOE` register block. `print gpioe` will return the base address of
the register block.
 -->
<p><code>gpioe</code>は、<code>GPIOE</code>レジスタブロックへの参照です。<code>print gpioe</code>は、レジスタブロックのベースアドレスを返します。</p>
<pre><code>$ cargo run
Breakpoint 3, main () at src/07-registers/src/main.rs:9
9           let gpioe = aux7::init().1;

(gdb) next
12          gpioe.bsrr.write(|w| w.bs9().set_bit());

(gdb) print gpioe
$1 = (stm32f30x::gpioc::RegisterBlock *) 0x48001000
</code></pre>
<!-- 
But if we instead `print *gpioe`, we'll get a *full view* of the register block: the value of each
of its registers will be printed.
 -->
<p>しかし、代わりに<code>print *gpioe</code>を実行すると、レジスタブロックの<em>全貌</em>を得ることができます。
レジスタの各値が表示されます。</p>
<pre><code>(gdb) print *gpioe
$2 = stm32f30x::gpioc::RegisterBlock {
  moder: stm32f30x::gpioc::MODER {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x55550000
      }
    }
  },
  otyper: stm32f30x::gpioc::OTYPER {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  ospeedr: stm32f30x::gpioc::OSPEEDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  pupdr: stm32f30x::gpioc::PUPDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  idr: stm32f30x::gpioc::IDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0xcc
      }
    }
  },
  odr: stm32f30x::gpioc::ODR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  bsrr: stm32f30x::gpioc::BSRR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  lckr: stm32f30x::gpioc::LCKR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  afrl: stm32f30x::gpioc::AFRL {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  afrh: stm32f30x::gpioc::AFRH {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  brr: stm32f30x::gpioc::BRR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  }
}
</code></pre>
<!-- 
All these newtypes and closures sound like they'd generate large, bloated programs but, if you
actually compile the program in release mode with [LTO] enabled, you'll see that it produces exactly
the same instructions that the "unsafe" version that used `write_volatile` and hexadecimal addresses
did!
 -->
<p>全てのこれらの新しい型とクロージャは、大きく肥大化したプログラムを生成するように見えます。
しかし、実際にこのプログラムを<a href="https://en.wikipedia.org/wiki/Interprocedural_optimization">LTO</a>を有効化してリリースモードでコンパイルすると、
<code>write_volatile</code>と16進数アドレスを使った「unsafe」版と全く同じ命令が生成されることがわかります。</p>
<pre><code class="language-console">$ cargo objdump --bin registers --release -- -d -no-show-raw-insn -print-imm-hex
registers:      file format ELF32-arm-little

Disassembly of section .text:
main:
 8000188:       bl      #0x22
 800018c:       movw    r0, #0x1018
 8000190:       mov.w   r1, #0x200
 8000194:       movt    r0, #0x4800
 8000198:       str     r1, [r0]
 800019a:       mov.w   r1, #0x800
 800019e:       str     r1, [r0]
 80001a0:       mov.w   r1, #0x2000000
 80001a4:       str     r1, [r0]
 80001a6:       mov.w   r1, #0x8000000
 80001aa:       str     r1, [r0]
 80001ac:       b       #-0x4 &lt;main+0x24&gt;
</code></pre>
<!-- 
The best part of all this is that I didn't have to write a single line of code to implement the
GPIOE API. All was automatically generated from a System View Description (SVD) file using the
[svd2rust] tool. This SVD file is actually an XML file that microcontroller vendors provide and that
contains the register maps of their microcontrollers. The file contains the layout of register
blocks, the base addresses, the read/write permissions of each register, the layout of the
registers, whether a register has reserved bits and lots of other useful information.
 -->
<p>最も良い点は、GPIOE APIを実装するために、1行もコードを書く必要がなかったことです。
全ては、<a href="https://crates.io/crates/svd2rust">svd2rust</a>ツールを使って、System View Description (SVD)ファイルから自動生成されています。
SVDファイルは、実のところ、マイクロコントローラのベンダが提供しているXMLファイルです。このファイルは、マイクロコントローラのレジスタマップを含んでいます。
このファイルは、レジスタブロックのレイアウトやベースアドレス、書くレジスタの読み/書きのパーミッション、レジスタのレイアウト、
レジスタが予約済みのビットを持っているかどうか、などの有用な情報を含んでいます。</p>
<!-- # LEDs, again -->
<h1><a class="header" href="#led再び" id="led再び">LED、再び</a></h1>
<!-- 
In the last section, I gave you *initialized* (configured) peripherals (I initialized them in
`aux7::init`). That's why just writing to `BSRR` was enough to control the LEDs. But, peripherals
are not *initialized* right after the microcontroller boots.
 -->
<p>前のセクションでは、<em>初期化済み</em>（設定済み）のペリフェラルを提供しました（<code>aux7::init</code>で初期化していました）。
LEDを制御するために、<code>BSRR</code>に書き込むだけで十分だったのは、このおかげです。
しかし、マイクロコントローラが起動した直後、ペリフェラルは<em>初期化</em>されていません。</p>
<!-- 
In this section, you'll have more fun with registers. I won't do any initialization and you'll have
to initialize configure `GPIOE` pins as digital outputs pins so that you'll be able to drive LEDs
again.
 -->
<p>このセクションでは、レジスタを使ってもっとおもしろいことをやります。
私は初期化を行いません。再びLEDを駆動できるようにするために、あなたが<code>GPIOE</code>ピンをデジタル出力ピンとして初期化、設定します。</p>
<!-- This is the starter code. -->
<p>スターターコードは下記の通りです。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use aux8::entry;

#[entry]
fn main() -&gt; ! {
    let (gpioe, rcc) = aux8::init();

    // TODO GPIOEを初期化して下さい

    // コンパスの全てのLEDを点灯します。
    gpioe.odr.write(|w| {
        w.odr8().set_bit();
        w.odr9().set_bit();
        w.odr10().set_bit();
        w.odr11().set_bit();
        w.odr12().set_bit();
        w.odr13().set_bit();
        w.odr14().set_bit();
        w.odr15().set_bit()
    });

    aux8::bkpt();

    loop {}
}
</code></pre></pre>
<!-- 
If you run the starter code, you'll see that nothing happens this time. Furthermore, if you print
the `GPIOE` register block, you'll see that every register reads as zero even after the
`gpioe.odr.write` statement was executed!
 -->
<p>スターターコードを動かすと、今回は何も起こりません。その上、<code>GPIOE</code>レジスタブロックを表示すると、
<code>gpioe.odr.write</code>ステートメントを実行した後でも、全てのレジスタがゼロになっていることがわかるでしょう。</p>
<pre><code>$ cargo run
Breakpoint 1, main () at src/08-leds-again/src/main.rs:9
9           let (gpioe, rcc) = aux8::init();

(gdb) continue
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0x08000f3c in __bkpt ()

(gdb) finish
Run till exit from #0  0x08000f3c in __bkpt ()
main () at src/08-leds-again/src/main.rs:25
25          aux8::bkpt();

(gdb) p/x *gpioe
$1 = stm32f30x::gpioc::RegisterBlock {
  moder: stm32f30x::gpioc::MODER {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  otyper: stm32f30x::gpioc::OTYPER {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  ospeedr: stm32f30x::gpioc::OSPEEDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  pupdr: stm32f30x::gpioc::PUPDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  idr: stm32f30x::gpioc::IDR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  odr: stm32f30x::gpioc::ODR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  bsrr: stm32f30x::gpioc::BSRR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  lckr: stm32f30x::gpioc::LCKR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  afrl: stm32f30x::gpioc::AFRL {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  afrh: stm32f30x::gpioc::AFRH {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  },
  brr: stm32f30x::gpioc::BRR {
    register: vcell::VolatileCell&lt;u32&gt; {
      value: core::cell::UnsafeCell&lt;u32&gt; {
        value: 0x0
      }
    }
  }
}
</code></pre>
<!-- # Power -->
<h1><a class="header" href="#電源" id="電源">電源</a></h1>
<!-- 
Turns out that, to save power, most peripherals start in a powered off state -- that's their state
right after the microcontroller boots.
 -->
<p>電力を節約するために、ほとんどのペリフェラルは、電源が入っていない状態で起動します。
これが、マイクロコントローラが起動した直後のペリフェラルの状態です。</p>
<!-- 
The Reset and Clock Control (`RCC`) peripheral can be used to power on or off every other
peripheral.
 -->
<p>リセットとクロック制御（<code>RCC</code>）ペリフェラルは、全ての他のペリフェラルの電源をオン/オフするために使います。</p>
<!-- You can find the list of registers in the `RCC` register block in: -->
<p><code>RCC</code>レジスタブロックのレジスタリストは、下記にあります。</p>
<blockquote>
<p>Section 9.4.14 - RCC register map - Page 166 - Reference Manual</p>
</blockquote>
<!-- The registers that control the power status of other peripherals are: -->
<p>他のペリフェラルの電源状態を制御するレジスタには、次のものがあります。</p>
<ul>
<li><code>AHBENR</code></li>
<li><code>APB1ENR</code></li>
<li><code>APB2ENR</code></li>
</ul>
<!-- Each bit in these registers controls the power status of a single peripheral, including `GPIOE`. -->
<p>これらのレジスタの各ビットは、1つのペリフェラルの電源状態を制御します。もちろん<code>GPIOE</code>も含まれています。</p>
<!-- Your task in this section is to power on the `GPIOE` peripheral. You'll have to: -->
<p>このセクションでのあなたの仕事は、<code>GPIOE</code>ペリフェラルの電源を入れることです。あなたは次のことに取り組む必要があります。</p>
<!-- 
- Figure out which of the three registers I mentioned before has the bit that controls the power
  status.
- Figure out what value that bit must be set to,`0` or `1`, to power on the `GPIOE` peripheral.
- Finally, you'll have to change the starter code to *modify* the right register to turn on the
  `GPIOE` peripheral.
 -->
<ul>
<li>上述した3つのレジスタのうち、どのレジスタが電源状態を制御するビットを持つか、調べて下さい。</li>
<li><code>GPIOE</code>ペリフェラルの電源を入れるために、ビットを<code>0</code>か<code>1</code>の、どちらにしなければならないか、調べて下さい。</li>
<li>最後に、<code>GPIOE</code>ペリフェラルの電源を入れるために、正しいレジスタを<em>modify</em>するようにスターターコードを変更する必要があります。</li>
</ul>
<!-- 
If you are successful, you'll see that the `gpioe.odr.write` statement will now be able to modify
the value of the `ODR` register.
 -->
<p>うまくいくと、<code>gpioe.odr.write</code>ステートメントが<code>ODR</code>レジスタの値を修正するようになります。</p>
<!-- Note that this won't be enough to actually turn on the LEDs. -->
<p>LEDを実際に点灯するには不十分であることに、留意して下さい。</p>
<!-- # Configuration -->
<h1><a class="header" href="#設定" id="設定">設定</a></h1>
<!-- 
After turning on the GPIOE peripheral. The peripheral still needs to be configured. In this case, we
want the pins to be configured as digital *outputs* so they can drive the LEDs; by default, most
pins are configured as digital *inputs*.
 -->
<p>GPIOEペリフェラルに電源を入れた後も、GPIOEペリフェラルには、まだ設定が必要です。
今回の場合、LEDを駆動できるように、そのピンをデジタル<em>出力</em>として設定したいです。
デフォルトでは、ピンはデジタル<em>入力</em>として設定されます。</p>
<!-- You can find the list of registers in the `GPIOE` register block in: -->
<p><code>GPIOE</code>レジスタブロックのレジスタリストは、下記にあります。</p>
<blockquote>
<p>Section 11.4.12 - GPIO registers - Page 243 - Reference Manual</p>
</blockquote>
<!-- The register we'll have to deal with is: `MODER`. -->
<p>制御する必要があるレジスタは、<code>MODER</code>です。</p>
<!-- 
Your task for this section is to further update the starter code to configure the *right* `GPIOE`
pins as digital outputs. You'll have to:
 -->
<p>このセクションのあなたの仕事は、<code>GPIOE</code>ピンをデジタル出力として<em>正しく</em>設定するように、スターターコードを更新することです。
次のことに取り組む必要があります。</p>
<!-- 
- Figure out *which* pins you need to configure as digital outputs. (hint: check Section 6.4 LEDs of
  the *User Manual* (page 18)).
- Read the documentation to understand what the bits in the `MODER` register do.
- Modify the `MODER` register to configure the pins as digital outputs.
 -->
<ul>
<li><em>どの</em>ピンをデジタル出力に設定しなければならないか、調べて下さい。（ヒント：<em>ユーザーマニュアル</em>18ページのSection 6.4 LEDsを見て下さい）</li>
<li><code>MODER</code>レジスタに含まれるビットが何をするか理解するために、ドキュメントを読んで下さい。</li>
<li>ピンをデジタル出力に設定するために、<code>MODER</code>レジスタを修正して下さい。</li>
</ul>
<!-- If successful, you'll see the 8 LEDs turn on when you run the program. -->
<p>うまくいくと、プログラム実行時に、8個のLEDが点灯します。</p>
<!-- # The solution -->
<h1><a class="header" href="#解答例-1" id="解答例-1">解答例</a></h1>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use aux8::entry;

#[entry]
fn main() -&gt; ! {
    let (gpioe, rcc) = aux8::init();

    // GPIOEペリフェラルを有効化します
    rcc.ahbenr.modify(|_, w| w.iopeen().set_bit());

    // ピンを出力に設定します
    gpioe.moder.modify(|_, w| {
        w.moder8().output();
        w.moder9().output();
        w.moder10().output();
        w.moder11().output();
        w.moder12().output();
        w.moder13().output();
        w.moder14().output();
        w.moder15().output()
    });

    // コンパスのLEDを全て点灯します
    gpioe.odr.write(|w| {
        w.odr8().set_bit();
        w.odr9().set_bit();
        w.odr10().set_bit();
        w.odr11().set_bit();
        w.odr12().set_bit();
        w.odr13().set_bit();
        w.odr14().set_bit();
        w.odr15().set_bit()
    });

    aux8::bkpt();

    loop {}
}
</code></pre></pre>
<!-- # Clocks and timers -->
<h1><a class="header" href="#クロックと時間" id="クロックと時間">クロックと時間</a></h1>
<!-- 
In this section, we'll re-implement the LED roulette application. I'm going to give you back the
`Led` abstraction but this time I'm going to take away the `Delay` abstraction `:-)`.
 -->
<p>このセクションでは、LEDルーレットアプリケーションを再実装します。<code>Led</code>の抽象化をお返ししますが、
<code>Delay</code>の抽象化を取り除いていきます。</p>
<!-- 
Here's the starter code. The `delay` function is unimplemented so if you run this program the LEDs
will blink so fast that they'll appear to always be on.
 -->
<p>スターターコードはこちらです。<code>delay</code>関数は、未実装です。プログラムを実行すると、LEDの点滅が早すぎて、常に点灯しているように見えるでしょう。</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use aux9::{entry, tim6};

#[inline(never)]
fn delay(tim6: &amp;tim6::RegisterBlock, ms: u16) {
    // 実装して下さい
}

#[entry]
fn main() -&gt; ! {
    let (mut leds, rcc, tim6) = aux9::init();

    // TIMGを実装して下さい

    let ms = 50;
    loop {
        for curr in 0..8 {
            let next = (curr + 1) % 8;

            leds[next].on();
            delay(tim6, ms);
            leds[curr].off();
            delay(tim6, ms);
        }
    }
}
</code></pre></pre>
<!-- # `for` loop delays -->
<h1><a class="header" href="#forループで遅延" id="forループで遅延"><code>for</code>ループで遅延</a></h1>
<!-- 
The first challenge is to implement the `delay` function without using any peripheral and the
obvious solution is to implement it as a `for` loop delay:
 -->
<p>最初の課題は、<code>delay</code>関数をペリフェラルを使わずに実装することです。
明らかな解決策は、<code>for</code>ループで遅延を実装することです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(never)]
fn delay(tim6: &amp;tim6::RegisterBlock, ms: u16) {
    for _ in 0..1_000 {}
}
<span class="boring">}
</span></code></pre></pre>
<!-- 
Of course, the above implementation is wrong because it always generates the same delay for any
value of `ms`.
 -->
<p>もちろん、上の実装は間違っています。どんな<code>ms</code>の値に対しても、常に同じ遅延を生成するからです。</p>
<!-- In this section, you'll have to: -->
<p>このセクションでは、次のことに取り組む必要があります。</p>
<!-- 
- Fix the `delay` function to generate delays proportional to its input `ms`.
- Tweak the `delay` function to make the LED roulette spin at a rate of approximately 5 cycles in 4
  seconds (800 milliseconds period).
- The processor inside the microcontroller is clocked at 8 MHz and executes most instructions in one
  "tick", a cycle of its clock. How many (`for`) loops do  you *think* the `delay` function must do
  to generate a delay of 1 second?
- How many `for` loops does `delay(1000)` actually do?
- What happens if compile your program in release mode and run it?
 -->
<ul>
<li>入力の<code>ms</code>に比例した遅延を生成するように、<code>delay</code>関数を修正します。</li>
<li>LEDルーレットが4秒に5回（1周期800ms）程度回るように、<code>delay</code>関数を微調整します。</li>
<li>マイクロコントローラ内のプロセッサは、8MHzのクロックで駆動されており、ほとんどの命令を1「ティック」（1クロックサイクル）で実行します。
1秒の遅延を生成するために、何回の（<code>for</code>）ループが、<code>delay</code>関数に必要だと考えますか？</li>
<li><code>delay(1000)</code>が実際に実行する<code>for</code>ループは何回でしょうか？</li>
<li>プログラムをリリースモードでコンパイルし、実行すると、何が起こりますか？</li>
</ul>
<h1><a class="header" href="#nop" id="nop">NOP</a></h1>
<!-- 
If in the previous section you compiled the program in release mode and actually looked at the
disassembly, you probably noticed that the `delay` function is optimized away and never gets called
from within `main`.
 -->
<p>前のセクションで、プログラムをリリースモードでコンパイルし、逆アセンブルした結果を実際に見ると、
<code>delay</code>関数が最適化されて<code>main</code>から呼び出されないことに気づくでしょう。</p>
<!-- LLVM decided that the function wasn't doing anything worthwhile and just removed it. -->
<p>LLVMは、delay関数が何も価値のあることをやっていないと判断し、関数を削除しました。</p>
<!-- 
There is a way to prevent LLVM from optimizing the `for` loop delay: add a *volatile* assembly
instruction. Any instruction will do but NOP (No OPeration) is a particular good choice in this case
because it has no side effect.
 -->
<p>LLVMが<code>for</code>ループでの遅延を最適化しないようにする方法があります。<em>volatile</em>アセンブリ命令を追加します。
どのような命令を追加しても良いのですが、今回の場合は、NOP (No OPeration)が特に良い選択です。NOPは副作用がないためです。</p>
<!-- Your `for` loop delay would become: -->
<p><code>for</code>ループでの遅延は、次のようになるでしょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(never)]
fn delay(_tim6: &amp;tim6::RegisterBlock, ms: u16) {
    const K: u16 = 3; // この値は微調整が必要です
    for _ in 0..(K * ms) {
        aux9::nop()
    }
}
<span class="boring">}
</span></code></pre></pre>
<!-- 
And this time `delay` won't be compiled away by LLVM when you compile your program in release mode:
 -->
<p>今回は、プログラムをリリースモードでコンパイルしても、<code>delay</code>はLLVMによって削除されません。</p>
<pre><code class="language-console">$ cargo objdump --bin clocks-and-timers --release -- -d -no-show-raw-insn
clocks-and-timers:      file format ELF32-arm-little

Disassembly of section .text:
clocks_and_timers::delay::h711ce9bd68a6328f:
 8000188:       push    {r4, r5, r7, lr}
 800018a:       movs    r4, #0
 800018c:       adds    r4, #1
 800018e:       uxth    r5, r4
 8000190:       bl      #4666
 8000194:       cmp     r5, #150
 8000196:       blo     #-14 &lt;clocks_and_timers::delay::h711ce9bd68a6328f+0x4&gt;
 8000198:       pop     {r4, r5, r7, pc}
</code></pre>
<!-- 
Now, test this: Compile the program in debug mode and run it, then compile the program in release
mode and run it. What's the difference between them? What do you think is the main cause of the
difference? Can you think of a way to make them equivalent or at least more similar again?
 -->
<p>では、次のことを試して下さい。プログラムをデバッグモードでコンパイルし、実行します。その後、リリースモードでプログラムをコンパイルし、実行します。
2つの間で何が違いますか？この違いは何が原因と考えますか？
2つを同じものにするか、もしくは、少なくとも似たような振る舞いにする方法を思いつきますか？</p>
<!-- # One-shot timer -->
<h1><a class="header" href="#ワンショットタイマ" id="ワンショットタイマ">ワンショットタイマ</a></h1>
<!-- I hope that, by now, I have convinced you that `for` loop delays are a poor way to implement delays. -->
<p>これまでに、<code>for</code>ループでの遅延は、遅延を実装する方法としては良くない方法であると納得してもらっていると思います。</p>
<!-- 
Now, we'll implement delays using a *hardware timer*. The basic function of a (hardware) timer is
... to keep precise track of time. A timer is yet another peripheral that's available to the
microcontroller; thus it can be controlled using registers.
 -->
<p>ここでは、<em>ハードウェアタイマ</em>を使って遅延を実装します。（ハードウェア）タイマの基本的な機能は、時間を正確に追跡することです。
タイマは、マイクロコントローラから利用できるさらに別のペリフェラルです。
そのため、レジスタを使って制御できます。</p>
<!-- 
The microcontroller we are using has several (in fact, more than 10) timers of different kinds
(basic, general purpose, and advanced timers) available to it. Some timers have more *resolution*
(number of bits) than others and some can be used for more than just keeping track of time.
 -->
<p>私たちが利用しているマイクロコントローラは、いくつかの（実は10を超える数の）異なる種類（簡易、汎用、高度なタイマ）のタイマを持っています。
いくつかのタイマは、他のタイマより高い分解能（ビット数）を持ちます。そして、単純に時間を追跡すること以上の用途で使えるものもあります。</p>
<!-- 
We'll be using one of the *basic* timers: `TIM6`. This is one of the simplest timers available in
our microcontroller. The documentation for basic timers is in the following section:
 -->
<p><code>TIM6</code>という<em>簡易</em>タイマの1つを利用します。このもっとも単純なタイマは、マイクロコントローラ内で利用可能です。
この簡易タイマのドキュメントは、下記にあります。</p>
<blockquote>
<p>Section 22 Timers - Page 670 - Reference Manual</p>
</blockquote>
<!-- Its registers are documented in: -->
<p>レジスタに関する記述は、下記にあります。</p>
<blockquote>
<p>Section 22.4.9 TIM6/TIM7 register map - Page 682 - Reference Manual</p>
</blockquote>
<!-- The registers we'll be using in this section are: -->
<p>このセクションで利用するレジスタは、下記の通りです。</p>
<!-- 
- `SR`, the status register.
- `EGR`, the event generation register.
- `CNT`, the counter register.
- `PSC`, the prescaler register.
- `ARR`, the autoreload register.
 -->
<ul>
<li><code>SR</code>、ステータスレジスタ。</li>
<li><code>EGT</code>、イベント生成レジスタ。</li>
<li><code>CNT</code>、カウンタレジスタ。</li>
<li><code>PSC</code>、プリスケーラレジスタ。</li>
<li><code>ARR</code>、自動リロードレジスタ。</li>
</ul>
<!-- 
We'll be using the timer as a *one-shot* timer. It will sort of work like an alarm clock. We'll set
the timer to go off after some amount of time and then we'll wait until the timer goes off. The
documentation refers to this mode of operation as *one pulse mode*.
 -->
<p>タイマを<em>ワンショット</em>タイマとして使用します。これは、目覚まし時計のような役割を果たします。
ある程度時間が経過してからタイマがオフになるように設定してから、タイマがオフになるまで待ちます。
ドキュメント内では、この動作モードを<em>ワンパルスモード</em>と呼んでいます。</p>
<!-- 
Here's a description of how a basic timer works when configured in one pulse mode:
 -->
<p>ここに、簡易タイマをワンパルスモードとして設定する方法を記載します。</p>
<!-- 
- The counter is enabled by the user (`CR1.CEN = 1`).
- The `CNT` register resets its value to zero and, on each tick, its value gets incremented by one.
- Once the `CNT` register has reached the value of the `ARR` register, the counter will be disabled
  by hardware (`CR1.CEN = 0`) and an *update event* will be raised (`SR.UIF = 1`).
 -->
<ul>
<li>カウンタをユーザーによって有効化します（<code>CR1.CEN = 1</code>）。</li>
<li><code>CNT</code>レジスタの値をゼロにリセットします。この値は、ティックごとに値が1つずつインクリメントされます。</li>
<li>一度<code>CNT</code>レジスタが<code>ARR</code>レジスタの値に到達すると、カウンタがハードウェアによって無効になります（<code>CR1.CEN = 0</code>）。
そして、<em>更新イベント</em>（<code>SR.UIF = 1</code>）が通知されます。</li>
</ul>
<!-- 
`TIM6` is driven by the APB1 clock, whose frequency doesn't have to necessarily match the processor
frequency. That is, the APB1 clock could be running faster or slower. The default, however, is that
both APB1 and the processor are clocked at 8 MHz.
 -->
<p><code>TIM6</code>はAPB1クロックによって駆動されます。APB1のクロック周波数は、プロセッサの周波数と一致している必要はありません。
APB1クロックは、プロセッサより速かったり遅かったりします。しかし、デフォルトでは、APB1とプロセッサのクロックは両方とも8MHzです。</p>
<!-- 
The tick mentioned in the functional description of the one pulse mode is *not* the same as one
tick of the APB1 clock. The `CNT` register increases at a frequency of `apb1 / (psc + 1)`
times per second, where `apb1` is the frequency of the APB1 clock and `psc` is the value of the
prescaler register, `PSC`.
 -->
<p>ワンパルスモードの機能説明で書かれているティックは、APB1クロックの1ティックと同じ<em>ではありません</em>。
<code>CNT</code>レジスタは、毎秒<code>apb1 / (psc + 1)</code>の周波数で増加します。
ここで、<code>apb1</code>はAPB1クロックの周波数で、<code>psc</code>はプリスケーラレジスタ（<code>PSC</code>）の値です。</p>
<!-- # Initialization -->
<h1><a class="header" href="#初期化" id="初期化">初期化</a></h1>
<!-- 
As with every other peripheral, we'll have to initialize this timer before we can use it. And just
as in the previous section, initialization is going to involve two steps: powering up the timer and
then configuring it.
 -->
<p>他のペリフェラルと同様に、タイマを使う前に、タイマを初期化する必要があります。
前のセクションと同様に、初期化には2つの手順があります。タイマの電源を入れることとタイマを設定することです。</p>
<!-- 
Powering up the timer is easy: We just have to set `TIM6EN` bit to 1. This bit is in the `APB1ENR`
register of the `RCC` register block.
 -->
<p>タイマの電源を入れることは簡単です。<code>TIM6EN</code>ビットに1を設定するだけです。
このビットは、<code>RCC</code>レジスタブロックの<code>APB1ENR</code>レジスタの中にあります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // TIM6のタイマの電源を入れます。
    rcc.apb1enr.modify(|_, w| w.tim6en().set_bit());
<span class="boring">}
</span></code></pre></pre>
<!-- The configuration part is slightly more elaborate. -->
<p>設定部分は、もう少し複雑です。</p>
<!-- First, we'll have to configure the timer to operate in one pulse mode. -->
<p>まず最初に、タイマをワンパルスモードで動作するように設定しなければなりません。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // OPM：ワンパルスモードを選択します。
    // CEN：今はカウンタを無効にしておきます。
    tim6.cr1.write(|w| w.opm().set_bit().cen().clear_bit());
<span class="boring">}
</span></code></pre></pre>
<!-- 
Then, we'll like to have the `CNT` counter operate at a frequency of 1 KHz because our `delay`
function takes a number of milliseconds as arguments and 1 KHz produces a 1 millisecond period. For
that we'll have to configure the prescaler.
 -->
<p>次に、<code>CNT</code>カウンタが1KHzの周波数で動作するようにします。なぜなら、<code>delay</code>関数がミリ秒を引数として取り、1KHzは1ミリ秒の周期を生成するからです。
このために、プリスケーラを設定する必要があります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // カウンタが1KHzで動作するようにプリスケーラを設定します。
    tim6.psc.write(|w| w.psc().bits(psc));
<span class="boring">}
</span></code></pre></pre>
<!-- 
I'm going to let you figure out the value of the prescaler, `psc`. Remember that the frequency of
the counter is `apb1 / (psc + 1)` and that `apb1` is 8 MHz.
 -->
<p>プリスケーラに設定する<code>psc</code>の値は、あなたが見つけ出して下さい。
カウンタの周波数は、<code>apb1 / (psc + 1)</code>で<code>apb1</code>は8MHzであることを思い出して下さい。</p>
<!-- # Busy waiting -->
<h1><a class="header" href="#ビジーウェイト" id="ビジーウェイト">ビジーウェイト</a></h1>
<!-- 
The timer should now be properly initialized. All that's left is to implement the `delay` function
using the timer.
 -->
<p>タイマは、適切に初期化されているはずです。残りは、このタイマを使って<code>delay</code>関数を実装することです。</p>
<!-- 
First thing we have to do is set the autoreload register (`ARR`) to make the timer go off in `ms`
milliseconds. Because the counter operates at 1 KHz, the autoreload value will be the same as `ms`.
 -->
<p>まず最初にやらなければならないことは、<code>ms</code>ミリ秒後にタイマをオフにするために、自動リロードレジスタ（<code>ARR</code>）レジスタを設定することです。
カウンタは1KHzで動作するため、自動リロードの値は、<code>ms</code>と同じ値になります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // `ms`ティック後にオフになるようにタイマを設定します。
    // 1ティックは1msです。
    tim6.arr.write(|w| w.arr().bits(ms));
<span class="boring">}
</span></code></pre></pre>
<!-- 
Next, we need to enable the counter. It will immediately start counting.
 -->
<p>次に、カウンタを有効にする必要があります。有効化すると、すぐにカウントが開始します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // CEN：カウンタを有効化します。
    tim6.cr1.modify(|_, w| w.cen().set_bit());
<span class="boring">}
</span></code></pre></pre>
<!-- 
Now we need to wait until the counter reaches the value of the autoreload register, `ms`, then we'll
know that `ms` milliseconds have passed. That condition is known as an *update event* and its
indicated by the `UIF` bit of the status register (`SR`).
 -->
<p>今度は、カウンタが自動リロードレジスタの値（<code>ms</code>）に到達するまで待つ必要があります。すると、<code>ms</code>ミリ秒経過したことがわかります。
この状態は、<em>更新イベント</em>と呼ばれます。そして、これはステータスレジスタ（<code>SR</code>）の<code>UIF</code>ビットによってわかります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // アラームがオフになるまで（更新イベントが発生するまで）待ちます
    while !tim6.sr.read().uif().bit_is_set() {}
<span class="boring">}
</span></code></pre></pre>
<!-- 
This pattern of just waiting until some condition is met, in this case that `UIF` becomes `1`, is
known as *busy waiting* and you'll see it a few more times in this text `:-)`.
 -->
<p>ある条件が満たされるまで単純に待つようなパターン、今回の場合だと<code>UIF</code>が<code>1</code>になる、は<em>ビジーウェイト</em>と呼ばれます。
この言葉を、このテキスト内で何回か目にするでしょう<code>:-)</code>。</p>
<!-- 
Finally, we must clear (set to `0`) this `UIF` bit. If we don't, next time we enter the `delay`
function we'll think the update event has already happened and skip over the busy waiting part.
 -->
<p>最後に、<code>UIF</code>ビットをクリア（<code>0</code>に設定）しなければなりません。もしこれを行わないと、次に<code>delay</code>関数に入った時に、
更新イベントが既に発生しており、ビジーウェイト部分の実行を飛ばすことになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // 更新イベントフラグをクリアします
    tim6.sr.modify(|_, w| w.uif().clear_bit());
<span class="boring">}
</span></code></pre></pre>
<!-- Now, put this all together and check if it works as expected. -->
<p>では、ここまでの全てをまとめて、期待通り動くかどうか確認して下さい。</p>
<!-- # Putting it all together -->
<h1><a class="header" href="#全てをまとめる" id="全てをまとめる">全てをまとめる</a></h1>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use aux9::{entry, tim6};

#[inline(never)]
fn delay(tim6: &amp;tim6::RegisterBlock, ms: u16) {
    // `ms`ティック後にオフになるようにタイマを設定します。
    // 1ティックは1msです。
    tim6.arr.write(|w| w.arr().bits(ms));

    // CEN：カウンタを有効化します。
    tim6.cr1.modify(|_, w| w.cen().set_bit());

    // アラームがオフになるまで（更新イベントが発生するまで）待ちます
    while !tim6.sr.read().uif().bit_is_set() {}

    // 更新イベントフラグをクリアします
    tim6.sr.modify(|_, w| w.uif().clear_bit());
}

#[entry]
fn main() -&gt; ! {
    let (mut leds, rcc, tim6) = aux9::init();

    // TIM6のタイマの電源を入れます。
    rcc.apb1enr.modify(|_, w| w.tim6en().set_bit());

    // OPM：ワンパルスモードを選択します。
    // CEN：今はカウンタを無効にしておきます。
    tim6.cr1.write(|w| w.opm().set_bit().cen().clear_bit());

    // カウンタが1KHzで動作するようにプリスケーラを設定します。
    // APB1_CLOCK = 8 MHz
    // PSC = 7999
    // 8 MHz / (7999 + 1) = 1 KHz
    // カウンタ（CNT）は、毎ミリ秒ごとに増加します。
    tim6.psc.write(|w| w.psc().bits(7_999));

    let ms = 50;
    loop {
        for curr in 0..8 {
            let next = (curr + 1) % 8;

            leds[next].on();
            delay(tim6, ms);
            leds[curr].off();
            delay(tim6, ms);
        }
    }
}
</code></pre></pre>
<!-- # Serial communication -->
<h1><a class="header" href="#シリアル通信" id="シリアル通信">シリアル通信</a></h1>
<a href="https://en.wikipedia.org/wiki/File:Serial_port.jpg">
<p align="center">
<img height="240" title="Standard serial port connector DE-9" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Serial_port.jpg/800px-Serial_port.jpg">
</p>
</a>
<!-- 
<p align="center">
<em>This is what we'll be using. I hope your laptop has one!</em>
</p>
 -->
<p align="center">
<em>これが、これから使うものです！あなたのラップトップにも1つ付いていると良いのですが！</em>
</p>
<!-- 
Nah, don't worry. This connector, the DE-9, went out of fashion on PCs quite some time ago; it got
replaced by the Universal Serial Bus (USB). We won't be dealing with the DE-9 connector itself but
with the communication protocol that this cable is/was usually used for.
 -->
<p>冗談です、心配しないで下さい。このDE-9というコネクターは、かなり昔にPCでは時代遅れになり、USB（Universal Serial Bus）に置き換わりました。
DE-9コネクタ自体を扱うことはしませんが、このケーブルで使われている/使われていた通信プロトコルを使います。</p>
<!-- 
So what's this *serial communication*? It's an *asynchronous* communication protocol where two
devices exchange data *serially*, as in one bit at a time, using two data lines (plus a common
ground). The protocol is asynchronous in the sense that neither of the shared lines carries a clock
signal. Instead both parties must agree on how fast data will be sent along the wire *before* the
communication occurs. This protocol allows *duplex* communication as data can be sent from A to B
and from B to A simultaneously.
 -->
<p><em>シリアル通信</em>とは何なのでしょうか？それは、2本のデータ線（と共通のグランド）を使って、
2つのデバイスが1回に1ビットずつ<em>逐次に</em>データ交換する<em>非同期</em>通信プロトコルです。
このプロトコルは、どちらの共有線もクロック信号を伝送しない、という意味で非同期です。
代わりに、双方の当事者は、通信が行われる<em>前に</em>、ワイヤに流れるデータの送信速度について合意する必要があります。
このプロトコルは、<em>双方向の</em>通信が可能です。データは、AからBへ、BからAへ、同時に送信することができます。</p>
<!-- 
We'll be using this protocol to exchange data between the microcontroller and your laptop. In
contrast to the ITM protocol we have used before, with the serial communication protocol you can
send data from your laptop to the microcontroller.
 -->
<p>このプロトコルを、マイクロコントローラとノートPCとの間のデータ交換に使用します。
これまでに使ったITMプロトコルと違って、シリアル通信プロトコルでは、ノートPCからマイクロコントローラにデータを送ることができます。</p>
<!-- 
The next practical question you probably want to ask is: How fast can we send data through this
protocol?
 -->
<p>次に尋ねたいと思うであろう実用上の質問は、このプロトコルではどのくらいの速度でデータを送信できるのか？ということでしょう。</p>
<!-- 
This protocol works with frames. Each frame has one *start* bit, 5 to 9 bits of payload (data) and 1
to 2 *stop bits*. The speed of the protocol is known as *baud rate* and it's quoted in bits per
second (bps). Common baud rates are: 9600, 19200, 38400, 57600 and 115200 bps.
 -->
<p>このプロトコルは、フレームで動作します。各フレームは、1つの<em>開始</em>ビット、5から9ビットのペイロード（データ）と、1か2ビットの<em>終了ビット</em>を持ちます。
プロトコルの速度は、<em>ボーレート</em>と呼ばれており、ビット毎秒（bps）として示されます。
一般的なボーレートは、9600、19200、38400、57600、115200です。</p>
<!-- 
To actually answer the question: With a common configuration of 1 start bit, 8 bits of data, 1
stop bit and a baud rate of 115200 bps one can, in theory, send 11,520 frames per second. Since each
one frame carries a byte of data that results in a data rate of 11.52 KB/s. In practice, the data
rate will probably be lower because of processing times on the slower side of the communication (the
microcontroller).
 -->
<p>実際に質問に答えると、一般的な設定の開始ビット1ビット、データビット8ビット、終了ビット1ビットでボーレートが115200 bpsであれば、
理論上は、毎秒11,520フレーム送信することが可能です。
各1フレームは、1バイトのデータを伝送するため、11.52KB/秒というデータレートになります。実際には、データレートは、より低くなります。
なぜなら、通信しているより遅い側（マイクロコントローラ）の処理時間があるためです。</p>
<!-- 
Today's laptops/PCs don't support the serial communication protocol. So you can't directly connect
your laptop to the microcontroller. But that's where the serial module comes in. This module will
sit between the two and expose a serial interface to the microcontroller and an USB interface to
your laptop. The microcontroller will see your laptop as another serial device and your laptop
will see the microcontroller as a virtual serial device.
 -->
<p>現在のノートPC/PCは、シリアル通信のプロトコルをサポートしていません。そのため、ノートPCを直接マイクロコントローラに接続することはできません。
しかし、そこでシリアルモジュールの出番です。このモジュールは、2つの機器の間に入り、マイクロコントローラにシリアルインタフェースを、
ノートPCにUSBインタフェースを用意します。
マイクロコントローラは、ノートPCを別のシリアルデバイスとして見るでしょう。そして、ノートPCは、マイクロコントローラを仮想シリアルデバイスとして見ます。</p>
<!-- 
Now, let's get familiar with the serial module and the serial communication tools that your OS
offers. Pick a route:
 -->
<p>それでは、シリアルモジュールと使用しているOSが提供するシリアル通信ツールについて、詳しく学びましょう。ルートを選んで下さい。</p>
<ul>
<li><a href="10-serial-communication/nix-tooling.html">*nix</a></li>
<li><a href="10-serial-communication/windows-tooling.html">Windows</a></li>
</ul>
<!-- # *nix tooling -->
<h1><a class="header" href="#nixのツール" id="nixのツール">*nixのツール</a></h1>
<!-- 
Connect the serial module to your laptop and let's find out what name the OS assigned to it.
 -->
<p>シリアルモジュールをノートPCに接続し、OSがなんという名前を割り当てたか、を確認します。</p>
<!-- 
> **NOTE** On macs, the USB device will named like this: `/dev/cu.usbserial-*`. You won't
> find it using `dmesg`, instead use `ls -l /dev | grep cu.usb` and adjust the following 
> commands accordingly!
 -->
<blockquote>
<p><strong>注記</strong> macでは、USBデバイスは<code>/dev/cu.usbserial-*</code>といった名前になります。
<code>dmesg</code>を使用してもわからないので、代わりに、<code>ls -l /dev | grep cu.usb</code>を使って下さい。
そして、適宜、以下のコマンドを調整して下さい。</p>
</blockquote>
<pre><code class="language-console">$ dmesg | grep -i tty
(..)
[  +0.000155] usb 3-2: FTDI USB Serial Device converter now attached to ttyUSB0
</code></pre>
<!-- But what's this `ttyUSB0` thing? It's a file of course! Everything is a file in *nix: -->
<p>しかし、<code>ttyUSB0</code>という物は何なのでしょうか？もちろんファイルです！*nixでは、全てがファイルなのです。</p>
<pre><code class="language-console">$ ls -l /dev/ttyUSB0
crw-rw-rw- 1 root uucp 188, 0 Oct 27 00:00 /dev/ttyUSB0
</code></pre>
<!-- 
> **NOTE** if the permissions above is `crw-rw----`, the udev rules have not been set correctly
> see [udev rules](../03-setup/linux.html#udev-rules)
 -->
<blockquote>
<p><strong>注記</strong> パーミッションが<code>crw-rw----</code>の場合、udevルールが正しく設定できていません。
<a href="10-serial-communication/../03-setup/linux.html#udev-rules">udevルール</a>を参照して下さい</p>
</blockquote>
<!-- You can send out data by simply writing to this file: -->
<p>単にこのファイルに書き込むだけで、データを送ることができます。</p>
<pre><code class="language-console">$ echo 'Hello, world!' &gt; /dev/ttyUSB0
</code></pre>
<!-- You should see the TX (red) LED on the serial module blink, just once and very fast! -->
<p>シリアルモジュールのTX（赤色）LEDが点滅するのが見えたはずです。非常に速い速度で、ちょうど1回だけ！</p>
<h2><a class="header" href="#minicom" id="minicom">minicom</a></h2>
<!-- 
Dealing with serial devices using `echo` is far from ergonomic. So, we'll use the program `minicom`
to interact with the serial device using the keyboard.
 -->
<p>シリアルデバイスを<code>echo</code>を使って扱うことは、やりやすい方法ではありません。
そこで、キーボードを使ってシリアルデバイスと通信するために、<code>minicom</code>プログラムを使います。</p>
<!-- 
We must configure `minicom` before we use it. There are quite a few ways to do that but we'll use a
`.minirc.dfl` file in the home directory. Create a file in `~/.minirc.dfl` with the following
contents:
 -->
<p><code>minicom</code>を使う前に、設定が必要です。多くの設定方法がありますが、ホームディレクトリの<code>.minirc.dfl</code>ファイルを使います。
<code>~/.minirc.dfl</code>ファイルを、下記の内容で作成します。</p>
<pre><code class="language-console">$ cat ~/.minirc.dfl
pu baudrate 115200
pu bits 8
pu parity N
pu stopbits 1
pu rtscts No
pu xonxoff No
</code></pre>
<!-- > **NOTE** Make sure this file ends in a newline! Otherwise, `minicom` will fail to read it. -->
<blockquote>
<p><strong>注記</strong> ファイルが新しい行で終わるようにして下さい！そうでないと、<code>minicom</code>がファイルの読み込みに失敗します。</p>
</blockquote>
<!-- 
That file should be straightforward to read (except for the last two lines), but nonetheless let's
go over it line by line:
 -->
<p>このファイルは、（最後の2行を除いて）素直に読めますが、1行ずつ順番に見ていきましょう。</p>
<!-- 
- `pu baudrate 115200`. Sets baud rate to 115200 bps.
- `pu bits 8`. 8 bits per frame.
- `pu parity N`. No parity check.
- `pu stopbits 1`. 1 stop bit.
- `pu rtscts No`. No hardware control flow.
- `pu xonxoff No`. No software control flow.
 -->
<ul>
<li><code>pu baudrate 115200</code>. ボーレートを115200 bpsに設定します。</li>
<li><code>pu bits 8</code>. 1フレーム8ビットです。</li>
<li><code>pu parity N</code>. パリティチェックなし。</li>
<li><code>pu stopbits 1</code>. ストップビット1ビット。</li>
<li><code>pu rtscts No</code>. ハードウェア制御フローなし。</li>
<li><code>pu xonxoff No</code>. ソフトウェア制御フローなし。</li>
</ul>
<!-- Once that's in place. We can launch `minicom` -->
<p>設定ファイルの作成を終えると、<code>minicom</code>を起動できます。</p>
<pre><code class="language-console">$ minicom -D /dev/ttyUSB0 -b 115200
</code></pre>
<!-- 
This tells `minicom` to open the serial device at `/dev/ttyUSB0` and set its baud rate to 115200.
A text-based user interface (TUI) will pop out.
 -->
<p>このコマンドは、<code>minicom</code>に<code>/dev/ttyUSB0</code>のシリアルデバイスをオープンするように伝え、ボーレートを115200に設定します。
テキストベースのユーザーインタフェース（TUI）が現れます。</p>
<p align="center">
<img height="480" title="minicom" src="10-serial-communication/../assets/minicom.png">
</p>
<!-- 
You can now send data using the keyboard! Go ahead and type something. Note that the TUI *won't*
echo back what you type but you'll see TX (red) LED on the serial module blink with each keystroke.
 -->
<p>これからは、キーボードを使ってデータを送信できます。何かを入力してみて下さい。TUIは、あなたの入力をエコーバック<em>しない</em>ことに気をつけて下さい。
しかし、キーストロークごとにシリアルモジュールのTX（赤色）LEDが点滅するのが見えるでしょう。</p>
<!-- ## `minicom` commands -->
<h2><a class="header" href="#minicomコマンド" id="minicomコマンド"><code>minicom</code>コマンド</a></h2>
<!-- 
`minicom` exposes commands via keyboard shortcuts. On Linux, the shortcuts start with `Ctrl+A`. On
mac, the shortcuts start with the `Meta` key. Some useful commands below:
 -->
<p><code>minicom</code>は、キーボードショートカットによるコマンドを受け付けます。Linuxでは、ショートカットは<code>Ctrl+A</code>で始まります。
macでは、ショートカットは<code>Meta</code>キーで始まります。便利なコマンドを下記に示します。</p>
<!-- 
- `Ctrl+A` + `Z`. Minicom Command Summary
- `Ctrl+A` + `C`. Clear the screen
- `Ctrl+A` + `X`. Exit and reset
- `Ctrl+A` + `Q`. Quit with no reset
 -->
<ul>
<li><code>Ctrl+A</code> + <code>Z</code>. Minicomコマンドのまとめ</li>
<li><code>Ctrl+A</code> + <code>C</code>. スクリーンのクリア</li>
<li><code>Ctrl+A</code> + <code>X</code>. 終了とリセット</li>
<li><code>Ctrl+A</code> + <code>Q</code>. リセットなしの終了</li>
</ul>
<!-- > **NOTE** mac users: In the above commands, replace `Ctrl+A` with `Meta`. -->
<blockquote>
<p><strong>注記</strong> macユーザーへ：上記コマンドの、<code>Ctrl+A</code>は<code>Meta</code>で置き換えて下さい。</p>
</blockquote>
<!-- # Windows tooling -->
<h1><a class="header" href="#windowsのツール" id="windowsのツール">Windowsのツール</a></h1>
<!-- Before plugging the Serial module, run the following command on the terminal: -->
<p>シリアルモジュールを差し込む前に、ターミナルで次のコマンドを実行して下さい。</p>
<pre><code class="language-console">$ mode
</code></pre>
<!-- 
It will print a list of devices that are connected to your laptop. The ones that start with `COM` in
their names are serial devices. This is the kind of device we'll be working with. Take note of all
the `COM` *ports* `mode` outputs *before* plugging the serial module.
 -->
<p>このコマンドは、ノートPCに接続されているデバイスの一覧を表示します。<code>COM</code>から名前が始まるデバイスが、シリアルデバイスです。
このデバイスがこれから使うデバイスの種類です。シリアルモジュールを差し込む<em>前に</em><code>mode</code>が出力した全ての<code>COM</code><em>ポート</em>をメモして下さい。</p>
<!-- 
Now, plug the Serial module and run the `mode` command again. You should see a new `COM` port appear
on the list. That's the COM port assigned to the serial module.
 -->
<p>それでは、シリアルモジュールを差し込み、<code>mode</code>コマンドを再び実行して下さい。新しい<code>COM</code>ポートが、リストに現れるはずです。
これが、シリアルモジュールに割り当てらたCOMポートです。</p>
<!-- Now launch `putty`. A GUI will pop out. -->
<p>それでは、<code>putty</code>を起動します。GUIが現れます。</p>
<p align="center">
<img title="PuTTY settings" src="10-serial-communication/../assets/putty-settings.png">
</p>
<!-- 
On the starter screen, which should have the "Session" category open, pick "Serial" as the
"Connection type". On the "Serial line" field enter the `COM` device you got on the previous step,
for example `COM3`.
 -->
<p>開始画面では、「Session」カテゴリがあるはずなので、それを開いて「Connection type」として「Serial」を選択して下さい。
「Serial line」フィールドには、先ほどの手順で入手した<code>COM</code>デバイスを入力して下さい。例えば、<code>COM3</code>です。</p>
<!-- 
Next, pick the "Connection/Serial" category from the menu on the left. On this new view, make sure
that the serial port is configured as follows:
 -->
<p>次に、メニューの左側から、「Connection/Serial」カテゴリを選択します。新しい画面では、
シリアルポートが次の通り設定されていることを確認して下さい。</p>
<ul>
<li>&quot;Speed (baud)&quot;: 115200</li>
<li>&quot;Data bits&quot;: 8</li>
<li>&quot;Stop bits&quot;: 1</li>
<li>&quot;Parity&quot;: None</li>
<li>&quot;Flow control&quot;: None</li>
</ul>
<!-- Finally, click the Open button. A console will show up now: -->
<p>最後に、Openボタンをクリックします。コンソールが出現します。</p>
<p align="center">
<img title="PuTTY console" src="10-serial-communication/../assets/putty-console.png">
</p>
<!-- 
If you type on this console, the TX (red) LED on the Serial module should blink. Each key stroke
should make the LED blink once. Note that the console won't echo back what you type so the screen
will remain blank.
 -->
<p>このコンソールでタイピングすると、シリアルモジュールのTX（赤色）LEDが点滅するはずです。
キーストロークごとにLEDは1一度点滅します。コンソールは、タイピングしたことをエコーバックしないため、
画面は何も表示されていないままになります。</p>
<!-- # Loopbacks -->
<h1><a class="header" href="#ループバック" id="ループバック">ループバック</a></h1>
<!-- 
We've tested sending data. It's time to test receiving it. Except that there's no other device that
can send us some data ... or is there?
 -->
<p>データ送信をテストしました。次はデータ受信をテストします。こちらにデータを送信してくれる他のデバイスがないことを除けば…
それとも、ありますか？</p>
<!-- Enter: loopbacks -->
<p>ループバックを入力します。</p>
<p align="center">
<img title="Serial module loopback" src="10-serial-communication/../assets/serial-loopback.png">
</p>
<!-- You can send data to yourself! Not very useful in production but very useful for debugging. -->
<p>データを自分自身に送ることができます！製品では役に立ちませんが、デバッグには便利です。</p>
<!-- 
Connect the `TXO` and the `RXI` pins of the serial module together using a male to male jumper wire
as shown above.
 -->
<p>上図のように、シリアルモジュールの<code>TXO</code>ピンと<code>RXI</code>ピンを、オスオスジャンパワイヤを用いて接続します。</p>
<!-- Now enter some text into minicom/PuTTY and observe. What happens? -->
<p>では、minicom/PuTTYにテキストを入力して、観察して下さい。何が起こりますか？</p>
<!-- You should see three things: -->
<p>3つのことがわかるはずです。</p>
<!-- 
- As before, the TX (red) LED blinks on each key press.
- But now the RX (green) LED blinks on each key press as well! This indicates that the serial module
  is receiving some data; the one it just sent.
- Finally, on the minicom/PuTTY console, you should see that what you type echoes back to the
  console.
 -->
<ul>
<li>以前と同じように、TX（赤色）LEDがキーを押すごとに点滅します。</li>
<li>しかし今回は、RX（緑色）LEDも、キーを押すごとに点滅します！
これは、シリアルモジュールが何らかのデータ（送ったデータ）を受信していることを示しています。</li>
<li>最後に、minicom/PuTTYコンソール上に、入力がエコーバックされるのが見えるはずです。</li>
</ul>
<!-- 
Now that you are familiar with sending and receiving data over serial port using minicom/PuTTY,
let's make your microcontroller and your laptop talk!
 -->
<p>ここまでで、minicom/PuTTYを使って、シリアルポート越しにデータを送受信できるようになりました。
マイクロコントローラとノートPCとでやり取りしてみましょう！</p>
<h1><a class="header" href="#usart" id="usart">USART</a></h1>
<!-- 
The microcontroller has a peripheral called USART, which stands for Universal
Synchronous/Asynchronous Receiver/Transmitter. This peripheral can be configured to work with
several communication protocols like the serial communication protocol.
 -->
<p>使用しているマイクロコントローラは、USART（Universal Synchronous/Asynchronous Receiver/Transmitter）と呼ばれるペリフェラルを持っています。
このペリフェラルは、シリアル通信プロトコルのようないくつかの通信プロトコルで動作するように設定できます。</p>
<!-- 
Throughout this chapter, we'll use serial communication to exchange information between the
microcontroller and your laptop. But before we do that we have to wire up everything.
 -->
<p>この章では、マイクロコントローラとノートPCとの間で情報をやり取りするために、シリアル通信を使います。
しかし、それに取り組む前に、配線する必要があります。</p>
<!-- 
I mentioned before that this protocol involves two data lines: TX and RX. TX stands for transmitter
and RX stands for receiver. Transmitter and receiver are relative terms though; which line is the
transmitter and which line is the receiver depends from which side of the communication you are
looking at the lines.
 -->
<p>前述の通り、このプロトコルは、TXとRXとの2つのデータ線を使います。TXは送信機を、RXは受信機を意味します。
送信機と受信機は、相対的な用語です。つまり、どの線が送信機で、どの線が受信機か、は通信をどちら側から見ているか、に依存します。</p>
<!-- 
We'll be using the pin `PA9` as the microcontroller's TX line and `PA10` as its RX line. In other
words, the pin `PA9` outputs data onto its wire whereas the pin `PA10` listens for data on its
wire.
 -->
<p><code>PA9</code>ピンをマイクロコントローラのTX線として、<code>PA10</code>をRX線として、利用します。
言い換えると、<code>PA9</code>ピンはワイヤにデータを出力し、<code>PA10</code>ピンはワイヤ上のデータを読み取ります。</p>
<!-- 
We could have used a different pair of pins as the TX and RX pins. There's a table in page 44 of the
[Data Sheet] that list all the other possible pins we could have used.
 -->
<p>TXとRXピンとして、別のピンの組み合わせを使うこともできます。<a href="http://www.st.com/resource/en/datasheet/stm32f303vc.pdf">データシート</a>の44ページの表に、
使用できる他のピンの一覧が記載されています。</p>
<!-- [Data Sheet]: http://www.st.com/resource/en/datasheet/stm32f303vc.pdf -->
<!-- 
The serial module also has TX and RX pins. We'll have to *cross* these pins: that is connect the
microcontroller's TX pin to the serial module's RX pin and the micro's RX pin to the serial module's
TX pin. The wiring diagram below shows all the necessary connections.
 -->
<p>シリアルモジュールにもTXとRXピンがあります。これらのピンを<em>交差する</em>必要があります。すなわち、
マイクロコントローラのTXピンをシリアルモジュールのRXピンに、マイクロコントローラのRXピンをシリアルモジュールのTXピンに接続します。
下記の配線図は、必要な全ての接続を示しています。</p>
<p align="center">
<img height=640 title="F3 <-> Serial connection" src="../assets/f3-serial.png">
</p>
<!-- These are the recommended steps to connect the microcontroller and the serial module: -->
<p>マイクロコントローラとシリアルモジュールを接続するためのお勧めの手順は、次の通りです。</p>
<!-- 
- Close OpenOCD and `itmdump`
- Disconnect the USB cables from the F3 and the serial module.
- Connect one of F3 GND pins to the GND pin of the serial module using a female to male (F/M) wire.
  Preferably, a black one.
- Connect the PA9 pin on the back of the F3 to the RXI pin of the serial module using a F/M wire.
- Connect the PA10 pin on the back of the F3 to the TXO pin of the serial module using a F/M wire.
- Now connect the USB cable to the F3.
- Finally connect the USB cable to the Serial module.
- Re-launch OpenOCD and `itmdump`
 -->
<ul>
<li>OpenOCDと<code>itmdump</code>を終了します。</li>
<li>USBケーブルをF3とシリアルモジュールから抜きます。</li>
<li>F3のGNDピンとシリアルモジュールのGNDピンとを、オスメスワイヤを使って接続します。黒色のワイヤが好ましいです。</li>
<li>F3の背面にあるPA9ピンとシリアルモジュールのRXIピンとを、オスメスワイヤを使って接続します。</li>
<li>F3の背面にあるPA10ピンとシリアルモジュールのTXOピンとを、オスメスワイヤを使って接続します。</li>
<li>次に、USBケーブルとF3とを接続します。</li>
<li>最後にUSBケーブルをシリアルモジュールに接続します。</li>
<li>OpenOCDと<code>itmdump</code>を再起動します。</li>
</ul>
<!-- Everything's wired up! Let's proceed to send data back and forth. -->
<p>配線が全て完了しました！データのやり取りをしましょう。</p>
<!-- # Send a single byte -->
<h1><a class="header" href="#1バイト送信" id="1バイト送信">1バイト送信</a></h1>
<!-- 
Our first task will be to send a single byte from the microcontroller to the laptop over the serial
connection.
 -->
<p>最初のタスクは、シリアル接続経由で、マイクロコントローラからノートPCに1バイト送信することです。</p>
<!-- 
This time, I'm going to provide you with an already initialized USART peripheral. You'll only have
to work with the registers that are in charge of sending and receiving data.
 -->
<p>ここでは、初期化済みのUSARTペリフェラルを提供します。
データの送受信に関連のあるレジスタの操作だけ、行う必要があります。</p>
<!-- 
Go into the `11-usart` directory and let's run the starter code therein. Make sure that you have
minicom/PuTTY open.
 -->
<p><code>11-usart</code>ディレクトリに移動し、そこにあるスターターコードを実行しましょう。
minicom/PuTTYを開いていることを確認して下さい。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    // 1文字送信します
    usart1.tdr.write(|w| w.tdr().bits(u16::from(b'X')));

    loop {}
}
</code></pre></pre>
<!-- 
This program writes to the `TDR` register. This causes the `USART` peripheral to send one byte of
information through the serial interface.
 -->
<p>このプログラムは<code>TDR</code>レジスタに書き込みます。このことにより、<code>USART</code>ペリフェラルがシリアルインタフェースを通じて、1バイトの情報を送信します。</p>
<!-- 
On the receiving end, your laptop, you should see show the character `X` appear on minicom/PuTTY's
terminal.
 -->
<p>受信側（ノートPC）では、<code>X</code>の文字がminicom/PuTTYの端末に現れているはずです。</p>
<!-- # Send a string -->
<h1><a class="header" href="#文字列送信" id="文字列送信">文字列送信</a></h1>
<!-- The next task will be to send a whole string from the micro to your laptop. -->
<p>次のタスクは、マイクロコントローラからノートPCに1つの文字列全てを送信することです。</p>
<!-- 
I want you to send the string `"The quick brown fox jumps over the lazy dog."` from the micro to
your laptop.
 -->
<p><code>&quot;The quick brown fox jumps over the lazy dog.&quot;</code>という文字列を、マイクロコントローラからノートPCに送ってもらいたいです。</p>
<!-- It's your turn to write the program. -->
<p>あなたがプログラムを書く番です。</p>
<!-- Execute your program inside the debugger, statement by statement. What do you see? -->
<p>プログラムをデバッガでステートメントごとに実行して下さい。何が起こりますか？</p>
<!-- Then execute the program again but in *one go* using the `continue` command. What happens this time? -->
<p>プログラムを再度実行します。しかし。<code>continue</code>コマンドを使って<em>一気に</em>実行します。今度はどうなりますか？</p>
<!-- Finally, build the program in *release* mode and, again, run it one go. What happens this time? -->
<p>最後に、<em>リリース</em>モードでプログラムをビルドし、再度、一気に実行して下さい。今回はどうなりますか？</p>
<!-- # Overruns -->
<h1><a class="header" href="#オーバーラン" id="オーバーラン">オーバーラン</a></h1>
<!-- If you wrote your program like this: -->
<p>プログラムを次のように書いた場合、</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    // 文字列を送信します
    for byte in b&quot;The quick brown fox jumps over the lazy dog.&quot;.iter() {
        usart1.tdr.write(|w| w.tdr().bits(u16::from(*byte)));
    }

    loop {}
}
</code></pre></pre>
<!-- 
You probably received something like this on your laptop when you executed the program compiled in
debug mode.
 -->
<p>デバッグモードでコンパイルしたプログラムを実行した場合、ノートPCでは、おそらく次のようなものを受信したと思います。</p>
<pre><code class="language-console">$ # minicom's terminal
(..)
The uic brwn oxjums oer helaz do.
</code></pre>
<!-- And if you compiled in release mode, you probably only got something like this: -->
<p>そして、リリースモードでコンパイルした場合、次のような表示になったと思います。</p>
<pre><code class="language-console">$ # minicom's terminal
(..)
T
</code></pre>
<!-- What went wrong? -->
<p>何がいけなかったのでしょう？</p>
<!-- 
You see, sending bytes over the wire takes a relatively large amount of time. I already did the math
so let me quote myself:
 -->
<p>おわかりのように、ワイヤを介してバイトを送信するには、比較的長い時間がかかります。計算しておいた値を引用します。</p>
<!-- 
> With a common configuration of 1 start bit, 8 bits of data, 1 stop bit and a baud rate of 115200
> bps one can, in theory, send 11,520 frames per second. Since each one frame carries a byte of data
> that results in a data rate of 11.52 KB/s
 -->
<blockquote>
<p>一般的な、スタートビット1ビット、データ8ビット、ストップビット1ビットでボーレートが115200 bpsの設定では、
理論上は、毎秒11,520フレームを送信できます。1フレームにつき1バイトのデータを転送するので、データレートは、11.52 KB/秒になります。</p>
</blockquote>
<!-- 
Our pangram has a length of 45 bytes. That means it's going to take, at least, 3,900 microseconds
(`45 bytes / (11,520 bytes/s) = 3,906 us`) to send the string. The processor is working at 8 MHz,
where executing an instruction takes 125 nanoseconds, so it's likely going to be done with the `for`
loop is less than 3,900 microseconds.
 -->
<p>送信した文字列は、45バイトの長さです。これは、この文字列を送るために、
少なくとも3,900マイクロ秒（<code>45 bytes / (11,520 bytes/s) = 3,906 us</code>）かかることを意味しています。
プロセッサは、8MHzで動作しており、1命令125ナノ秒で実行します。この<code>for</code>ループは、3,900マイクロ秒より短い時間で完了するようです。</p>
<!-- 
We can actually time how long it takes to execute the `for` loop. `aux11::init()` returns a
`MonoTimer` (monotonic timer) value that exposes an `Instant` API that's similar to the one in
`std::time`.
 -->
<p>この<code>for</code>ループの実行に、どのくらい時間がかかっているのか、を実際に計測します。
<code>aux11::init()</code>は、<code>MonoTimer</code> (monotonic timer) の値を返します。これは、<code>std::time</code>に似た<code>Instant</code> APIを提供します。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, mut itm) = aux11::init();

    let instant = mono_timer.now();
    // 文字列を送信します
    for byte in b&quot;The quick brown fox jumps over the lazy dog.&quot;.iter() {
        usart1.tdr.write(|w| w.tdr().bits(u16::from(*byte)));
    }
    let elapsed = instant.elapsed(); // ティック単位で

    iprintln!(
        &amp;mut itm.stim[0],
        &quot;`for` loop took {} ticks ({} us)&quot;,
        elapsed,
        elapsed as f32 / mono_timer.frequency().0 as f32 * 1e6
    );

    loop {}
}
</code></pre></pre>
<!-- In debug mode, I get: -->
<p>デバッグモードでは、下記の結果が得られました。</p>
<pre><code class="language-console">$ # itmdump terminal
(..)
`for` loop took 22415 ticks (2801.875 us)
</code></pre>
<!-- 
This is less than 3,900 microseconds but it's not that far off and that's why only a few bytes of
information are lost.
 -->
<p>これは、3,900マイクロ秒より短いですが、それほどかけ離れているわけではありません。そのため、情報の数バイトだけが失われました。</p>
<!-- 
In conclusion, the processor is trying to send bytes at a faster rate than what the hardware can
actually handle and this results in data loss. This condition is known as buffer *overrun*.
 -->
<p>結論として、プロセッサは、ハードウェアの実際の処理能力より速いレートでバイトを送信し、その結果、データが失われました。
この状態は、バッファ<em>オーバーラン</em>と呼ばれています。</p>
<!-- 
How do we avoid this? The status register (`ISR`) has a flag, `TXE`, that indicates if it's "safe"
to write to the `TDR` register without incurring in data loss.
 -->
<p>どうすれば、これを回避できるでようか？ステータスレジスタ（<code>ISR</code>）は、<code>TXE</code>というフラグを持っています。
このフラグは、<code>TDR</code>レジスタにデータ損失なしで「安全」に書き込むことができるかどうかを、示しています。</p>
<!-- Let's use that to slowdown the processor. -->
<p>プロセッサを減速させるために、これを使いましょう。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, mut itm) = aux11::init();

    let instant = mono_timer.now();
    // 文字列を送信します
    for byte in b&quot;The quick brown fox jumps over the lazy dog.&quot;.iter() {
        // TDRへの書き込みが安全になるまで待ちます
        while usart1.isr.read().txe().bit_is_clear() {} // &lt;- NEW!

        usart1.tdr.write(|w| w.tdr().bits(u16::from(*byte)));
    }
    let elapsed = instant.elapsed(); // ティック単位で

    iprintln!(
        &amp;mut itm.stim[0],
        &quot;`for` loop took {} ticks ({} us)&quot;,
        elapsed,
        elapsed as f32 / mono_timer.frequency().0 as f32 * 1e6
    );

    loop {}
}
</code></pre></pre>
<!-- 
This time, running the program in debug or release mode should result in a complete string on the
receiving side.
 -->
<p>今回は、デバッグモードかリリースモードかに関わらず、プログラムを実行すると、受信側で完全に文字列を受信できるはずです。</p>
<pre><code class="language-console">$ # minicom/PuTTY's console
(..)
The quick brown fox jumps over the lazy dog.
</code></pre>
<!-- 
The timing of the `for` loop should be closer to the theoretical 3,900 microseconds as well. The
timing below is for the debug version.
 -->
<p><code>for</code>ループの実行時間は、理論上の3,900マイクロ秒に近くなるはずです。
デバッグモードのバージョンを下記に示します。</p>
<pre><code class="language-console">$ # itmdump terminal
(..)
`for` loop took 30499 ticks (3812.375 us)
</code></pre>
<h1><a class="header" href="#uprintln" id="uprintln"><code>uprintln!</code></a></h1>
<!-- 
For the next exercise, we'll implement the `uprint!` family of macros. Your goal is to make this
line of code work:
 -->
<p>次の演習は、<code>uprint!</code>系マクロの実装です。目標は、次のコードが動くことです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    uprintln!(serial, &quot;The answer is {}&quot;, 40 + 2);
<span class="boring">}
</span></code></pre></pre>
<!-- Which must send the string `"The answer is 42"` through the serial interface. -->
<p>これは、シリアルインタフェースを通じて、文字列の<code>&quot;The answer is 42&quot;</code>を送信しなければなりません。</p>
<!-- 
How do we go about that? It's informative to look into the `std` implementation of `println!`.
 -->
<p>どうしたら良いのでしょうか？<code>std</code>の<code>println!</code>実装を見ると、有益な情報が得られます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/libstd/macros.rs
macro_rules! print {
    ($($arg:tt)*) =&gt; ($crate::io::_print(format_args!($($arg)*)));
}
<span class="boring">}
</span></code></pre></pre>
<!-- 
Looks simple so far. We need the built-in `format_args!` macro (it's implemented in the compiler so we
can't see what it actually does). We'll have to use that macro in the exact same way. What does this
`_print` function do?
 -->
<p>非常に単純に見えます。組込み機能の<code>format_args!</code>マクロ（コンパイラに実装されているため、実際に何をしているかは見えません）が必要です。
このマクロを、正しい方法で使わなければなりません。<code>_print</code>関数は、何をやっているのでしょうか？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/libstd/io/stdio.rs
pub fn _print(args: fmt::Arguments) {
    let result = match LOCAL_STDOUT.state() {
        LocalKeyState::Uninitialized |
        LocalKeyState::Destroyed =&gt; stdout().write_fmt(args),
        LocalKeyState::Valid =&gt; {
            LOCAL_STDOUT.with(|s| {
                if s.borrow_state() == BorrowState::Unused {
                    if let Some(w) = s.borrow_mut().as_mut() {
                        return w.write_fmt(args);
                    }
                }
                stdout().write_fmt(args)
            })
        }
    };
    if let Err(e) = result {
        panic!(&quot;failed printing to stdout: {}&quot;, e);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!-- 
That *looks* complicated but the only part we are interested in is: `w.write_fmt(args)` and
`stdout().write_fmt(args)`. What `print!` ultimately does is call the `fmt::Write::write_fmt` method
with the output of `format_args!` as its argument.
 -->
<p>複雑に<em>見えます</em>が、興味のある部分は、<code>w.write_fmt(args)</code>と<code>stdout().write_fmt(args)</code>だけです。
結局のところ、<code>print!</code>が行っていることは、<code>format_args!</code>の出力を引数にして、<code>fmt::Write::write_fmt</code>メソッドを呼ぶことなのです。</p>
<!-- 
Luckily we don't have to implement the `fmt::Write::write_fmt` method either because it's a default
method. We only have to implement the `fmt::Write::write_str` method.
 -->
<p>幸運なことに、<code>fmt::Write::write_fmt</code>メソッドはデフォルトメソッドなので、実装する必要はありません。
<code>fmt::Write::write_str</code>メソッドだけを実装しなければなりません。</p>
<!-- Let's do that. -->
<p>では、やってみましょう。</p>
<!-- 
This is what the macro side of the equation looks like. What's left to be done by you is provide the
implementation of the `write_str` method.
 -->
<p>ここまでが、方程式のマクロ側がどのように見えるか、です。残りの取り組まなければならないことは、<code>write_str</code>メソッドの実装を提供することです。</p>
<!-- 
Above we saw that `Write` is in `std::fmt`. We don't have access to `std` but `Write` is also
available in `core::fmt`.
 -->
<p>上の方で、<code>std::fmt</code>の<code>Write</code>を見ました。<code>std</code>にはアクセスできませんが、<code>Write</code>は<code>core::fmt</code>でも利用可能です。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use core::fmt::{self, Write};

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln, usart1};

macro_rules! uprint {
    ($serial:expr, $($arg:tt)*) =&gt; {
        $serial.write_fmt(format_args!($($arg)*)).ok()
    };
}

macro_rules! uprintln {
    ($serial:expr, $fmt:expr) =&gt; {
        uprint!($serial, concat!($fmt, &quot;\n&quot;))
    };
    ($serial:expr, $fmt:expr, $($arg:tt)*) =&gt; {
        uprint!($serial, concat!($fmt, &quot;\n&quot;), $($arg)*)
    };
}

struct SerialPort {
    usart1: &amp;'static mut usart1::RegisterBlock,
}

impl fmt::Write for SerialPort {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        // TODO ここの実装して下さい
        // ヒント：以前のプログラムと非常に似たものになります
        Ok(())
    }
}

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    let mut serial = SerialPort { usart1 };

    uprintln!(serial, &quot;The answer is {}&quot;, 40 + 2);

    loop {}
}
</code></pre></pre>
<!-- # Receive a single byte -->
<h1><a class="header" href="#1バイト受信" id="1バイト受信">1バイト受信</a></h1>
<!-- 
So far we have sending data from the micro to your laptop. It's time to try the opposite: receiving
data from your laptop.
 -->
<p>これまで、マイクロコントローラからノートPCへデータを送ってきました。反対側をやってみましょう。
ノートPCからデータを受信します。</p>
<!-- 
There's a `RDR` register that will be filled with the data that comes from the RX line. If we read
that register, we'll retrieve the data that the other side of the channel sent. The question is: How
do we know that we have received (new) data? The status register, `ISR`, has a bit for that purpose:
`RXNE`. We can just busy wait on that flag.
 -->
<p>RX線から来たデータが詰められる<code>RDP</code>レジスタがあります。このレジスタを読むと、対向側が送ったデータを取り出すことができます。
（新しい）データを受信したことをどうやって知るか？という疑問があります。<code>ISR</code>というステータスレジスタが、この目的のための<code>RXNE</code>ビットを持っています。
単純にこのフラグをビジーウェイトすることができます。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    loop {
        // データが利用可能になるまで待ちます
        while usart1.isr.read().rxne().bit_is_clear() {}

        // データを取り出します
        let _byte = usart1.rdr.read().rdr().bits() as u8;

        aux11::bkpt();
    }
}
</code></pre></pre>
<!-- 
Let's try this program! Let it run free using `continue` and then type a single character in
minicom/PuTTY's console. What happens? What are the contents of the `_byte` variable?
 -->
<p>このプログラムを試してみて下さい！<code>continue</code>を使って実行し、minicom/PuTTYのコンソールから1文字入力します。
何が起こりましたか？<code>_byte</code>変数の中身はなんでしょうか？</p>
<pre><code>(gdb) continue
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0x8003d48 in __bkpt ()

(gdb) finish
Run till exit from #0  0x8003d48 in __bkpt ()
usart::main () at src/11-usart/src/main.rs:19
19              aux11::bkpt();

(gdb) p/c _byte
$1 = 97 'a'
</code></pre>
<!-- # Echo server -->
<h1><a class="header" href="#エコーサーバー" id="エコーサーバー">エコーサーバー</a></h1>
<!-- 
Let's merge transmission and reception into a single program and write an echo server. An echo
server sends back to the client the same text it sent. For this application, the microcontroller
will be the server and you and your laptop will be the client.
 -->
<p>送信と受信を1つのプログラムにまとめて、エコーサーバーを書いてみましょう。
エコーサーバーは、クライアントに送信されたものと同じテキストを送り返します。
このアプリケーションでは、マイクロコントローラがサーバーで、ノートPCがクライアントになります。</p>
<!-- This should be straightforward to implement. (hint: do it byte by byte) -->
<p>これは、素直な実装になるはずです。（ヒント：1バイトごとに処理します）</p>
<!-- # Reverse a string -->
<h1><a class="header" href="#文字列の反転" id="文字列の反転">文字列の反転</a></h1>
<!-- 
Alright, next let's make the server more interesting by having it respond to the client with the
reverse of the text that they sent. The server will respond to the client every time they press the
ENTER key. Each server response will be in a new line.
 -->
<p>それでは、次はサーバーをもっとおもしろくしましょう。送信されたデータを反転したテキストをクライアントに返信します。
サーバーは、ENTERキーが押されるたびに、クライアントに返信します。
サーバーの各返信は、新しい行になります。</p>
<!-- This time you'll need a buffer; you can use [`heapless::Vec`]. Here's the starter code: -->
<p>今回は、バッファが必要になります。<a href="https://docs.rs/heapless/0.2.1/heapless/struct.Vec.html"><code>heapless::Vec</code></a>が使えます。スターターコードは次の通りです。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};
use heapless::{consts, Vec};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    // 32バイト容量のバッファ
    let mut buffer: Vec&lt;u8, consts::U32&gt; = Vec::new();

    loop {
        buffer.clear();

        // TODO ユーザーリクエストを受信します。各ユーザーリクエストはENTERで終わります。
        // 注記　`buffer.push`は、`Result`を返します。
        // エラーメッセージを返信することで、エラーを処理して下さい。

        // TODO 反転した文字列を送り返します
    }
}
</code></pre></pre>
<!-- # My solution -->
<h1><a class="header" href="#解答例-2" id="解答例-2">解答例</a></h1>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux11::{entry, iprint, iprintln};
use heapless::{consts, Vec};

#[entry]
fn main() -&gt; ! {
    let (usart1, mono_timer, itm) = aux11::init();

    // 32バイト容量のバッファ
    let mut buffer: Vec&lt;u8, consts::U32&gt; = Vec::new();

    loop {
        buffer.clear();

        loop {
            while usart1.isr.read().rxne().bit_is_clear() {}
            let byte = usart1.rdr.read().rdr().bits() as u8;

            if buffer.push(byte).is_err() {
                // バッファが満杯
                for byte in b&quot;error: buffer full\n\r&quot; {
                    while usart1.isr.read().txe().bit_is_clear() {}
                    usart1.tdr.write(|w| w.tdr().bits(u16::from(*byte)));
                }

                break;
            }

            // キャリッジリターン
            if byte == 13 {
                // 返信
                for byte in buffer.iter().rev().chain(&amp;[b'\n', b'\r']) {
                    while usart1.isr.read().txe().bit_is_clear() {}
                    usart1.tdr.write(|w| w.tdr().bits(u16::from(*byte)));
                }

                break;
            }
        }
    }
}
</code></pre></pre>
<!-- # Bluetooth setup -->
<h1><a class="header" href="#bluetooth設定" id="bluetooth設定">Bluetooth設定</a></h1>
<!-- 
It's time to get rid of some wires. Serial communication can not only be emulated on top of the USB
protocol; it can also be emulated on top of the Bluetooth protocol. This serial over Bluetooth
protocol is known as RFCOMM.
 -->
<p>いくつかのワイヤを取り外す時が来ました。シリアル通信は、USBプロトコル上でのみエミュレートされるものではありません。
シリアル通信は、Bluetoothプロトコル上でもエミュレートできます。このBluetoothプロトコル経由のシリアルは、RFCOMMと呼ばれます。</p>
<!-- 
Before we use the Bluetooth module with the microcontroller, let's first interact with it using
minicom/PuTTY.
 -->
<p>マイクロコントローラでBluetoothモジュールを使う前に、minicom/PuTTYを使って最初の通信を行ってみましょう。</p>
<!-- 
The first thing we'll need to do is: turn on the Bluetooth module. We'll have to share some of the
F3 power to it using the following connection:
 -->
<p>まず最初にやらなければならないのは、Bluetoothモジュールの電源を入れることです。
下記の接続を使って、F3の電源の一部を共有しなければなりません。</p>
<p align="center">
<img height=640 title="F3 <-> Bluetooth connection (power only)" src="../assets/f3-bluetooth-power-only.png">
</p>
<!-- The recommend steps to wire this up are: -->
<p>ワイヤを接続する推奨の手順は、以下の通りです。</p>
<!-- 
- Close OpenOCD and `itmdump`
- Disconnect the USB cables from the F3 and the serial module.
- Connect F3's GND pin to the Bluetooth's GND pin using a female to female (F/F) wire. Preferably, a
  black one.
- Connect F3's 5V pin to the Bluetooth's VCC pin using a F/F wire. Preferably, a red one.
- Then, connect the USB cable back to the F3.
- Re-launch OpenOCD and `itmdump`
 -->
<ul>
<li>OpenOCDと<code>itmdump</code>を終了します。</li>
<li>F3とシリアルモジュールからUSBケーブルを抜きます。</li>
<li>メスメスワイヤを使って、F3のGNDピンをBluetoothのGNDピンに接続します。できれば、黒色のワイヤを使います。</li>
<li>メスメスワイヤを使って、F3の5VピンとBluetoothのVCCピンを接続します。できれば、赤色のワイヤを使います。</li>
<li>その後、F3に再びUSBケーブルを挿します。</li>
<li>OpenOCDと<code>itmdump</code>を再起動します。</li>
</ul>
<!-- 
Two LEDs, a blue one and a red one, on the Bluetooth module should start blinking right after you
power on the F3 board.
 -->
<p>Bluetoothモジュール上の青いLEDと赤いLEDが、F3ボードの電源をオンした直後に、点滅し始めるはずです。</p>
<!-- 
Next thing to do is pair your laptop and the Bluetooth module. AFAIK, Windows and mac users can
simply use their OS default Bluetooth manager to do the pairing. The Bluetooth module default pin
is 1234.
 -->
<p>次にやることは、ノートPCとBluetoothモジュールをペアリングすることです。私の知る限りでは、Windowsとmacユーザーは、
OSデフォルトのBluetoothマネージャをペアリングに使うことができます。
Bluetoothモジュールのデフォルトの暗証番号は、1234です。</p>
<!-- Linux users will have to follow (some of) [these instructions]. -->
<p>Linuxユーザーは、<a href="12-bluetooth-setup/linux.html">これらの手順</a>（のいくつかに）従う必要があります。</p>
<!-- [these instructions]: linux.md -->
<h1><a class="header" href="#linux-1" id="linux-1">Linux</a></h1>
<!-- 
If you have a graphical Bluetooth manager, you can use that to pair your laptop to the Bluetooth
module and skip most of these steps. You'll probably still have to [this step] though.
 -->
<p>グラフィカルなBluetoothマネージャがある場合、ノートPCとBluetoothモジュールのペアリングに使えます。その場合、これらのほとんどの手順は不要です。
もしかすると、<a href="12-bluetooth-setup/linux.html#rfcomm-device">この手順</a>は必要かもしれません。</p>
<!-- [this step]: #rfcomm-device -->
<!-- ## Power up -->
<h2><a class="header" href="#電源を入れる" id="電源を入れる">電源を入れる</a></h2>
<!-- 
First, your laptop's Bluetooth transceiver may be OFF. Check its status with `hciconfig` and turn it
ON if necessary:
 -->
<p>まず、ノートPCのBluetoothトランシーバは、オフになっている可能性があります。<code>hciconfig</code>で状態を確認し、必要があれば電源を入れて下さい。</p>
<pre><code class="language-console">$ hciconfig
hci0:   Type: Primary  Bus: USB
        BD Address: 68:17:29:XX:XX:XX  ACL MTU: 310:10  SCO MTU: 64:8
        DOWN  &lt;--
        RX bytes:580 acl:0 sco:0 events:31 errors:0
        TX bytes:368 acl:0 sco:0 commands:30 errors:0

$ sudo hciconfig hci0 up

$ hciconfig
hci0:   Type: Primary  Bus: USB
        BD Address: 68:17:29:XX:XX:XX  ACL MTU: 310:10  SCO MTU: 64:8
        UP RUNNING  &lt;--
        RX bytes:1190 acl:0 sco:0 events:67 errors:0
        TX bytes:1072 acl:0 sco:0 commands:66 errors:0
</code></pre>
<!-- Then you need to launch the BlueZ (Bluetooth) daemon: -->
<p>その後、BlueZ (Bluetooth) デーモンを起動しなければなりません。</p>
<!-- - On systemd based Linux distributions, use: -->
<ul>
<li>systemdベースのLinuxディストリビューションでは、下記コマンドを使います。</li>
</ul>
<pre><code class="language-console">$ sudo systemctl start bluetooth
</code></pre>
<!-- - On Ubuntu (or upstart based Linux distributions), use: -->
<ul>
<li>Ubuntu（またはupstartベースのLinuxディストリビューション）では、下記コマンドを使います。</li>
</ul>
<pre><code class="language-console">$ sudo /etc/init.d/bluetooth start
</code></pre>
<!-- You may also need to unblock your Bluetooth, depending on what `rfkill list` says: -->
<p>Bluetoothをアンブロックする必要があるかもしれません。<code>rfkill list</code>の出力に依存します。</p>
<pre><code class="language-console">$ rkfill list
9: hci0: Bluetooth
        Soft blocked: yes # &lt;--
        Hard blocked: no

$ sudo rfkill unblock bluetooth

$ rkfill list
9: hci0: Bluetooth
        Soft blocked: no  # &lt;--
        Hard blocked: no

</code></pre>
<!-- ## Scan -->
<h2><a class="header" href="#スキャン" id="スキャン">スキャン</a></h2>
<pre><code class="language-console">$ hcitool scan
Scanning ...
        20:16:05:XX:XX:XX       Ferris
$ #                             ^^^^^^
</code></pre>
<!-- ## Pair -->
<h2><a class="header" href="#ペアリング" id="ペアリング">ペアリング</a></h2>
<pre><code class="language-console">$ bluetoothctl
[bluetooth]# scan on
[bluetooth]# agent on
[bluetooth]# pair 20:16:05:XX:XX:XX
Attempting to pair with 20:16:05:XX:XX:XX
[CHG] Device 20:16:05:XX:XX:XX Connected: yes
Request PIN code
[agent] Enter PIN code: 1234
</code></pre>
<!-- ## rfcomm device -->
<h2><a class="header" href="#rfcommデバイス" id="rfcommデバイス">rfcommデバイス</a></h2>
<!-- 
We'll create a device file for our Bluetooth module in `/dev`. Then we'll be able to use it just
like we used `/dev/ttyUSB0`.
 -->
<p><code>/dev</code>にBluetoothデバイス用のデバイスファイルを作成します。すると、<code>/dev/ttyUSB0</code>を使ったように、Bluetoothデバイスを使うことができます。</p>
<pre><code class="language-console">$ sudo rfcomm bind 0 20:16:05:XX:XX:XX
</code></pre>
<!-- 
Because we used `0` as an argument to `bind`, `/dev/rfcomm0` will be the device file assigned to our
Bluetooth module.
 -->
<p><code>bind</code>の引数として<code>0</code>を使用したため、<code>/dev/rfcomm0</code>がBluetoothモジュールのデバイスファイルとして割り当てられます。</p>
<!-- You can release (destroy) the device file at any time with the following command: -->
<p>次のコマンドで、いつでもデバイスファイルを解放（削除）することができます。</p>
<pre><code class="language-console">$ # 今はこのコマンドを実行しないで下さい！
$ sudo rfcomm release 0
</code></pre>
<!-- # Loopback, again -->
<h1><a class="header" href="#ループバック再び" id="ループバック再び">ループバック、再び</a></h1>
<!-- 
After pairing your laptop to the Bluetooth module, your OS should have created a device file / COM
port for you. On Linux, it should be `/dev/rfcomm*`; on mac, it should be `/dev/cu.*`; and on
Windows, it should be a new COM port.
 -->
<p>ノートPCをBluetoothモジュールとペアリングした後、OSはデバイスファイルファイル/COMポートを作ってくれているはずです。
Linuxでは<code>/dev/rfcomm*</code>で、macでは<code>/dev/cu.*</code>で、Windowsでは新しいCOMポートです。</p>
<!-- 
We can now test the Bluetooth module with minicom/PuTTY. Because this module doesn't have LED
indicators for the transmission and reception events like the serial module did, we'll test the
module using a loopback connection:
 -->
<p>これで、minicom/PuTTYでBluetoothモジュールのテストができます。
このモジュールは、シリアルモジュールにあったような送受信イベントのためのLEDインジケータがないため、
ループバック接続を使って、モジュールをテストします。</p>
<p align="center">
<img height=640 title="F3 <-> Bluetooth connection (loopback)" src="../assets/f3-bluetooth-loopback.png">
</p>
<!-- Just connect the module's TXD pin to its RXD pin using a F/F wire. -->
<p>メスメスワイヤを使って、モジュールのTXDピンをRXDピンに接続するだけです。</p>
<!-- Now, connect to the device using `minicom`/`PuTTY`: -->
<p>次に、<code>minicom</code>/<code>PuTTY</code>を使って、デバイスに接続します。</p>
<pre><code class="language-console">$ minicom -D /dev/rfcomm0
</code></pre>
<!-- 
Upon connecting, the blinking pattern of the Bluetooth module should change to: long pause then
blink twice quickly.
 -->
<p>接続時、Bluetoothモジュールの点滅パターンが変わります。長い消灯の後、素早く2回点滅します。</p>
<!-- Typing inside minicom/PuTTY terminal should echo back what you type. -->
<p>minicom/PuTTY端末の中でタイピングすると、タイピングしたものがエコーバックされるはずです。</p>
<!-- # Serial over Bluetooth -->
<h1><a class="header" href="#bluetooth経由のシリアル" id="bluetooth経由のシリアル">Bluetooth経由のシリアル</a></h1>
<!-- 
Now that we verify that the Bluetooth module works with minicom/PuTTY, let's connect it to the
microcontroller:
 -->
<p>minicom/PuTTYでBluetoothモジュールが動くことを検証します。マイクロコントローラを接続しましょう。</p>
<p align="center">
<img height=640 title="F3 <-> Bluetooth connection" src="../assets/f3-bluetooth.png">
</p>
<!-- Recommended steps to wire this up: -->
<p>ワイヤを接続する推奨手順は、次の通りです。</p>
<!-- 
- Close OpenOCD and `itmdump`.
- Disconnect the F3 from your laptop.
- Connect F3's GND pin to the module's GND pin using a female to female (F/F) wire (preferably, a
  black one).
- Connect F3's 5V pin to the module's VCC pin using a F/F wire (preferably, a red one).
- Connect the PA9 (TX) pin on the back of the F3 to the Bluetooth's RXD pin using a F/F wire.
- Connect the PA10 (RX) pin on the back of the F3 to the Bluetooth's TXD pin using a F/F wire.
- Now connect the F3 and your laptop using an USB cable.
- Re-launch OpenOCD and `itmdump`.
 -->
<ul>
<li>OpenOCDと<code>itmdump</code>を終了します。</li>
<li>F3をノートPCから外します。</li>
<li>メスメスワイヤを使って、F3のGNDピンをモジュールのGNDピンに接続します。（できれば、黒色の線を使います）</li>
<li>メスメスワイヤを使って、F3の5VピンをモジュールのVCCピンに接続します。（できれば、赤色の線を使います）</li>
<li>メスメスワイヤを使って、F3背面のPA9（TX）ピンをBluetoothのRXDピンに接続します。</li>
<li>メスメスワイヤを使って、F3背面のPA10（RX）ピンをBluetoothのTXDピンに接続します。</li>
<li>USBケーブルを使って、F3とノートPCを接続します。</li>
<li>OpenOCDと<code>itmdump</code>を再起動します。</li>
</ul>
<!-- 
And that's it! You should be able to run all the programs you wrote in [section 11] without
modification! Just make sure you open the right serial device / COM port.
 -->
<p>これで全てです！<a href="13-serial-over-bluetooth/../11-usart/index.html">セクション11</a>で書いたプログラム全てを、修正することなしに、実行することができます。
正しいシリアルデバイス / COMポートを開いていることを確認して下さい。</p>
<!-- [section 11]: ../11-usart/index.html -->
<h1><a class="header" href="#i2c" id="i2c">I2C</a></h1>
<!-- 
We just saw the serial communication protocol. It's a widely used protocol because it's very
simple and this simplicity makes it easy to implement on top of other protocols like Bluetooth and
USB.
 -->
<p>シリアル通信のプロトコルを見てきました。シリアル通信は広く利用されているプロトコルです。
なぜなら、シリアル通信は単純で、単純だからこそBluetoothやUSBのようなプロトコル上に実装することが容易であるためです。</p>
<!-- 
However, it's simplicity is also a downside. More elaborated data exchanges, like reading a digital
sensor, would require the sensor vendor to come up with another protocol on top of it.
 -->
<p>しかし、この単純さは欠点でもあります。例えばデジタルセンサを読み込みようなより複雑なデータのやり取りでは、
センサベンダは別プロトコルの用意を要求します。</p>
<!-- 
(Un)Luckily for us, there are *plenty* of other communication protocols in the embedded space. Some
of them are widely used in digital sensors.
 -->
<p>幸運（不幸）なことに、組込みの世界には<em>たくさんの</em>通信プロトコルが存在します。
デジタルセンサで広く使われているものもあります。</p>
<!-- 
The F3 board we are using has three motion sensors in it: an accelerometer, a magnetometer and
gyroscope. The accelerometer and magnetometer are packaged in a single component and can be accessed
via an I2C bus.
 -->
<p>使用しているF3ボードには、加速度計、磁力計、ジャイロスコープの3つのモーションセンサがあります。
加速度計と磁力計は1つのコンポーネントにパッケージされており、I2Cバスでアクセスできます。</p>
<!-- 
I2C stands for Inter-Integrated Circuit and is a *synchronous* *serial* communication protocol. It
uses two lines to exchange data: a data line (SDA) and a clock line (SCL). Because a clock line is
used to synchronize the communication, this is a *synchronous* protocol.
 -->
<p>I2Cは、Inter-Integrated Circuitを意味しており、<em>同期シリアル</em>通信プロトコルの1つです。
データをやり取りするために、データ線（SDA）とクロック線（SCL）の2つの線を使用します。
クロック線は通信を同期するために使用するので、これは<em>同期</em>プロトコルです。</p>
<p align="center">
<img height=180 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg">
</p>
<!-- 
This protocol uses a *master* *slave* model where the master is the device that *starts* and
drives the communication with a slave device. Several devices, both masters and slaves, can be
connected to the same bus at the same time. A master device can communicate with a specific slave
device by first broadcasting its *address* to the bus. This address can be 7 bits or 10 bits long.
Once a master has *started* a communication with a slave, no other device can make use of the bus
until the master *stops* the communication.
 -->
<p>このプロトコルは、<em>マスター</em>・<em>スレーブ</em>モデルを使います。ここで、マスターはスレーブデバイスとの通信を<em>開始</em>し駆動するデバイスです。
いくつかのデバイス（マスター、スレーブ共に）が同じバスに、同時に接続できます。
マスターデバイスは、まずバスに<em>アドレス</em>をブロードキャストすることで、特定のスレーブデバイスと通信できます。
このアドレスは、7ビットか10ビットの長さです。
一度マスターがスレーブと通信を<em>開始すると</em>、マスターが通信を<em>停止する</em>まで、他のデバイスはバスを使用できません。</p>
<!-- 
The clock line determines how fast data can be exchanged and it usually operates at a frequency of
100 KHz (standard mode) or 400 KHz (fast mode).
 -->
<p>クロック線は、データのやり取りの速度を決定します。通常、100 KHz（standard mode）か400 KHz (fast mode)の周波数で動作します。</p>
<!-- # General protocol -->
<h1><a class="header" href="#一般的なプロトコル" id="一般的なプロトコル">一般的なプロトコル</a></h1>
<!-- 
The I2C protocol is more elaborated than the serial communication protocol because it has to support
communication between several devices. Let's see how it works using examples:
 -->
<p>I2Cプロトコルは複数のデバイス間の通信をサポートしなければならないため、シリアル通信プロトコルより複雑です。
例を使って、I2Cプロトコルがどのように動くか見ていきましょう。</p>
<!-- ## Master -> Slave -->
<h2><a class="header" href="#マスター---スレーブ" id="マスター---スレーブ">マスター -&gt; スレーブ</a></h2>
<!-- If the master wants to send data to the slave: -->
<p>マスターがスレーブにデータを送りたい場合、次のようになります。</p>
<p align="center">
  <img height=180 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg">
</p>
<!-- 
1. Master: Broadcast START
2. M: Broadcast slave address (7 bits) + the R/W (8th) bit set to WRITE
3. Slave: Responds ACK (ACKnowledgement)
4. M: Send one byte
5. S: Responds ACK
6. Repeat steps 4 and 5 zero or more times
7. M: Broadcast STOP OR (broadcast RESTART and go back to (2))
 -->
<ol>
<li>マスター：STARTをブロードキャストします</li>
<li>M：スレーブアドレス（7ビット）＋R/W（第8の）ビットをWRITEに設定したものをブロードキャストします</li>
<li>スレーブ：ACK（ACKnowledgement）を返信します</li>
<li>M：1バイト送ります</li>
<li>S：ACKを返信します</li>
<li>手順4と5を0回以上繰り返します</li>
<li>M：STOPブロードキャストします（または、RESTARTをブロードキャストし、手順2に戻ります）</li>
</ol>
<!-- 
> **NOTE** The slave address could have been 10 bits instead of 7 bits long. Nothing else would have
> changed.
 -->
<blockquote>
<p><strong>注記</strong> スレーブアドレスは7ビット長の代わりに10ビット長になる可能性があります。他には何も変わりません。</p>
</blockquote>
<!-- ## Master <- Slave -->
<h2><a class="header" href="#マスター---スレーブ-1" id="マスター---スレーブ-1">マスター &lt;- スレーブ</a></h2>
<!-- If the master wants to read data from the slave: -->
<p>マスターがスレーブからデータを読みたい場合、次のようになります。</p>
<p align="center">
<img height=180 title="I2C bus" src="https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg">
</p>
<!-- 
1. M: Broadcast START
2. M: Broadcast slave address (7 bits) + the R/W (8th) bit set to READ
3. S: Responds with ACK
4. S: Send byte
5. M: Responds with ACK
6. Repeat steps 4 and 5 zero or more times
7. M: Broadcast STOP OR (broadcast RESTART and go back to (2))
 -->
<ol>
<li>M：STARTをブロードキャストします</li>
<li>M：スレーブアドレス（7ビット）＋R/W（第8の）ビットをREADに設定したものをブロードキャストします</li>
<li>S：ACKを返信します</li>
<li>S：1バイト送ります</li>
<li>M：ACKを返信します</li>
<li>手順4と5を0回以上繰り返します</li>
<li>M：M：STOPブロードキャストします（または、RESTARTをブロードキャストし、手順2に戻ります）</li>
</ol>
<!-- 
> **NOTE** The slave address could have been 10 bits instead of 7 bits long. Nothing else would have
> changed.
 -->
<blockquote>
<p><strong>注記</strong> スレーブアドレスは7ビット長の代わりに10ビット長になる可能性があります。他には何も変わりません。</p>
</blockquote>
<h1><a class="header" href="#lsm303dlhc" id="lsm303dlhc">LSM303DLHC</a></h1>
<!-- 
Two of the sensors in the F3, the magnetometer and the accelerometer, are packaged in a single
component: the LSM303DLHC integrated circuit. These two sensors can be accessed via an I2C bus. Each
sensor behaves like an I2C slave and has a *different* address.
 -->
<p>F3にある磁力計と加速度計の2つのセンサは、1つのコンポーネントにまとめられています。このコンポーネントは、LSM303DLHCという集積回路です。
これら2つのセンサは、I2Cバスでアクセスできます。各センサは<em>異なる</em>アドレスを持つI2Cスレーブとして動作します。</p>
<!-- 
Each sensor has its own memory where it stores the results of sensing its environment. Our
interaction with these sensors will mainly involve reading their memory.
 -->
<p>環境をセンシングした結果を格納するため、各センサは自身のメモリを持っています。
これらのセンサとのやり取りは、主にこれらのメモリから読み込むことです。</p>
<!-- 
The memory of these sensors is modeled as byte addressable registers. These sensors can be
configured too; that's done by writing to their registers. So, in a sense, these sensors are very
similar to the peripherals *inside* the microcontroller. The difference is that their registers are
not mapped into the microcontrollers' memory. Instead, their registers have to be accessed via the
I2C bus.
 -->
<p>これらセンサのメモリは、バイト単位でアドレスが割り当てられたレジスタとして作られています。センサは設定することもできます。
センサのレジスタに書き込むことで設定ができます。そのため、ある意味で、これらのセンサはマイクロコントローラ<em>内の</em>ペリフェラルに似ています。
異なる点は、これらセンサのレジスタがマイクロコントローラのメモリにマッピングされていないことです。
代わりに、I2Cバスでアクセスしなければなりません。</p>
<!-- 
The main source of information about the LSM303DLHC is its [Data Sheet]. Read through it to see how
one can read the sensors' registers. That part is in:
 -->
<p>LSM303DLHCに関する主な情報源は、<a href="http://www.st.com/resource/en/datasheet/lsm303dlhc.pdf">データシート</a>です。どうすればセンサのレジスタを読めるか、を知るために読んでみます。
その情報がある部分は、次のセクションです。</p>
<!-- [Data Sheet]: http://www.st.com/resource/en/datasheet/lsm303dlhc.pdf -->
<blockquote>
<p>Section 5.1.1 I2C Operation - Page 20 - LSM303DLHC Data Sheet</p>
</blockquote>
<!-- 
The other part of the documentation relevant to this book is the description of the registers. That
part is in:
 -->
<p>この本に関連するドキュメンテーションがある他の部分は、レジスタの記述です。
その情報がある部分は、次のセクションです。</p>
<blockquote>
<p>Section 7 Register description - Page 25 - LSM303DLHC Data Sheet</p>
</blockquote>
<!-- # Read a single register -->
<h1><a class="header" href="#1つのレジスタを読む" id="1つのレジスタを読む">1つのレジスタを読む</a></h1>
<!-- Let's put all that theory into practice! -->
<p>理論を実践してみましょう！</p>
<!-- 
Just like with the USART peripheral, I've taken care of initializing everything before you reach
`main` so you'll only have to deal with the following registers:
 -->
<p>USARTペリフェラルと同様に、<code>main</code>に到達する前に全てを初期化しています。
下記レジスタを取り扱うだけで済みます。</p>
<!-- 
- `CR2`. Control register 2.
- `ISR`. Interrupt and status register.
- `TXDR`. Transmit data register.
- `RXDR`. Receive data register.
 -->
<ul>
<li><code>CR2</code>. コントロールレジスタ2</li>
<li><code>ISR</code>. 割込み、ステータスレジスタ</li>
<li><code>TXDR</code>. 送信データレジスタ</li>
<li><code>RXDR</code>. 受信データレジスタ</li>
</ul>
<!-- These registers are documented in the following section of the Reference Manual: -->
<p>これらのレジスタは、リファレンスマニュアルの下記セクションに記載されています。</p>
<blockquote>
<p>Section 28.7 I2C registers - Page 873 - Reference Manual</p>
</blockquote>
<!-- We'll be using the `I2C1` peripheral in conjunction with pins `PB6` (`SCL`) and `PB7` (`SDA`). -->
<p><code>PB6</code>（<code>SCL</code>）と<code>PB7</code>（<code>SDA</code>）ピンにつながっている<code>I2C1</code>ペリフェラルを使います。</p>
<!-- 
You won't have to wire anything this time because the sensor is on the board and it's already
connected to the microcontroller. However, I would recommend that you disconnect the serial /
Bluetooth module from the F3 to make it easier to manipulate. Later on, we'll be moving the board
around quite a bit.
 -->
<p>今回は、何も配線する必要がありません。センサはボード上にあり、既にマイクロコントローラと接続されているからです。
しかし、ボードを動かしやすくするために、シリアル / BluetoothモジュールをF3から外すことをお勧めします。
後ほど、ボードをかなり動かします。</p>
<!-- 
Your task is to write a program that reads the contents of the magnetometer's `IRA_REG_M` register.
This register is read only and always contains the value `0b01001000`.
 -->
<p>あなたのタスクは、磁力計の<code>IRA_REG_M</code>レジスタの内容を読み取るプログラムを書くことです。
このレジスタは読み込み専用で、常に<code>0b01001000</code>という値が入っています。</p>
<!-- 
The microcontroller will be taking the role of the I2C master and the magnetometer inside the
LSM303DLHC will be the I2C slave.
 -->
<p>マイクロコントローラは、I2Cマスターの役割を果たします。そしてLSM303DLHC内の磁力計は、I2Cスレーブになります。</p>
<!-- Here's the starter code. You'll have to implement the `TODO`s. -->
<p>スターターコードはこちらです。<code>TODO</code>の部分を実装しなければなりません。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux14::{entry, iprint, iprintln, prelude::*};

// スレーブアドレス
const MAGNETOMETER: u8 = 0b001_1110;

// 磁力計レジスタのアドレス
const OUT_X_H_M: u8 = 0x03;
const IRA_REG_M: u8 = 0x0A;

#[entry]
fn main() -&gt; ! {
    let (i2c1, _delay, mut itm) = aux14::init();

    // ステージ1：読みたいレジスタのアドレスを磁力計に送信します。
    {
        // TODO STARTをブロードキャストします

        // TODO 磁力計のアドレスをR/WビットをWriteに設定して、ブロードキャストします

        // TODO 読みたい`IRA_REG_M`レジスタのアドレスを送信します
    }

    // ステージ2：要求したレジスタの内容を受信します
    let byte = {
        // TODO RESTARTをブロードキャストします

        // TODO 磁力計のアドレスをR/WビットをReadに設定して、ブロードキャストします

        // TODO レジスタの内容を受信します

        // TODO STOPをブロードキャストします
        0
    };

    // 期待する出力：0x0A - 0b01001000
    iprintln!(&amp;mut itm.stim[0], &quot;0x{:02X} - 0b{:08b}&quot;, IRA_REG_M, byte);

    loop {}
}
</code></pre></pre>
<!-- To give you some extra help, these are the exact bitfields you'll be working with: -->
<p>追加のヒントです。取り扱う正確なビットフィールドを示します。</p>
<ul>
<li><code>CR2</code>: <code>SADD1</code>, <code>RD_WRN</code>, <code>NBYTES</code>, <code>START</code>, <code>AUTOEND</code></li>
<li><code>ISR</code>: <code>TXIS</code>, <code>RXNE</code>, <code>TC</code></li>
<li><code>TXDR</code>: <code>TXDATA</code></li>
<li><code>RXDR</code>: <code>RXDATA</code></li>
</ul>
<!-- # The solution -->
<h1><a class="header" href="#解答例-3" id="解答例-3">解答例</a></h1>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux14::{entry, iprint, iprintln, prelude::*};

// スレーブアドレス
const MAGNETOMETER: u8 = 0b001_1110;

// 磁力計レジスタのアドレス
const OUT_X_H_M: u8 = 0x03;
const IRA_REG_M: u8 = 0x0A;

#[entry]
fn main() -&gt; ! {
    let (i2c1, _delay, mut itm) = aux14::init();

    // ステージ1：読みたいレジスタのアドレスを磁力計に送信します。
    {
        // STARTをブロードキャストします
        // 磁力計のアドレスをR/WビットをWriteに設定して、ブロードキャストします
        i2c1.cr2.write(|w| {
            w.start().set_bit();
            w.sadd1().bits(MAGNETOMETER);
            w.rd_wrn().clear_bit();
            w.nbytes().bits(1);
            w.autoend().clear_bit()
        });

        // 次のデータを送信できるようになるまで、待ちます
        while i2c1.isr.read().txis().bit_is_clear() {}

        // 読みたい`IRA_REG_M`レジスタのアドレスを送信します
        i2c1.txdr.write(|w| w.txdata().bits(IRA_REG_M));

        // 前のバイトが送信されるまで待ちます
        while i2c1.isr.read().tc().bit_is_clear() {}
    }

    // ステージ2：要求したレジスタの内容を受信します
    let byte = {
        // RESTARTをブロードキャストします
        // 磁力計のアドレスをR/WビットをReadに設定して、ブロードキャストします
        i2c1.cr2.modify(|_, w| {
            w.start().set_bit();
            w.nbytes().bits(1);
            w.rd_wrn().set_bit();
            w.autoend().set_bit()
        });

        // レジスタの内容を受信するまで待ちます
        while i2c1.isr.read().rxne().bit_is_clear() {}

        // STOPをブロードキャストします（`AUTOEND = 1`なので自動です）

        i2c1.rxdr.read().rxdata().bits()
    };

    // 期待する出力：0x0A - 0b01001000
    iprintln!(&amp;mut itm.stim[0], &quot;0x{:02X} - 0b{:08b}&quot;, IRA_REG_M, byte);

    loop {}
}
</code></pre></pre>
<!-- # Read several registers -->
<h1><a class="header" href="#複数のレジスタを読む" id="複数のレジスタを読む">複数のレジスタを読む</a></h1>
<!-- 
Reading the `IRA_REG_M` register was a good test of our understanding of the I2C protocol but that
register contains uninteresting information.
 -->
<p><code>IRA_REG_M</code>レジスタを読むことは、I2Cプロトコルの理解を試すには良いものでした。
しかし、レジスタの内容はおもしろみのない情報です。</p>
<!-- 
This time, we'll read the registers of the magnetometer that actually expose the sensor readings.
Six contiguous registers are involved and they start with `OUT_X_H_M` at address `0x03`.
 -->
<p>今回は、実際のセンサの測定値がわかる磁力計のレジスタを読みます。
6つの連続したレジスタが関係しており、そのレジスタは<code>0x03</code>番地の<code>OUT_X_H_M</code>から始まります。</p>
<!-- 
We'll modify our previous program to read these six registers. Only a few modifications are needed.
 -->
<p>前のプログラムを、これら6つのレジスタを読むように修正します。ほんの少しの修正だけで済みます。</p>
<!-- 
We'll need to change the address we request from the magnetometer from `IRA_REG_M` to `OUT_X_H_M`.
 -->
<p>磁力計に要求するアドレスを、<code>IRA_REG_M</code>から<code>OUT_X_H_M</code>に変更します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // 読みたい`OUT_X_H_M`レジスタのアドレスを送信します
    i2c1.txdr.write(|w| w.txdata().bits(OUT_X_H_M));
<span class="boring">}
</span></code></pre></pre>
<!-- We'll have to request the slave for six bytes rather than just one. -->
<p>1バイトだけではなく、6バイトを要求します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // RESTARTをブロードキャストします
    // 磁力計のアドレスをR/WビットをReadに設定して、ブロードキャストします
    i2c1.cr2.modify(|_, w| {
        w.start().set_bit();
        w.nbytes().bits(6);
        w.rd_wrn().set_bit();
        w.autoend().set_bit()
    });
<span class="boring">}
</span></code></pre></pre>
<!-- And fill a buffer rather than read just one byte: -->
<p>1バイトだけ読むのではなく、バッファを埋めます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut buffer = [0u8; 6];
    for byte in &amp;mut buffer {
        // レジスタの内容を受信するまで待ちます
        while i2c1.isr.read().rxne().bit_is_clear() {}

        *byte = i2c1.rxdr.read().rxdata().bits();
    }

    // STOPをブロードキャストします（`AUTOEND = 1`なので自動です）
<span class="boring">}
</span></code></pre></pre>
<!-- 
Putting it all together inside a loop alongside a delay to reduce the data throughput:
 -->
<p>データのスループットを減らすための遅延と共に、これらをループ内にまとめると、次のようになります。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux14::{entry, iprint, iprintln, prelude::*};

// スレーブアドレス
const MAGNETOMETER: u8 = 0b001_1110;

// 磁力計レジスタのアドレス
const OUT_X_H_M: u8 = 0x03;
const IRA_REG_M: u8 = 0x0A;

#[entry]
fn main() -&gt; ! {
    let (i2c1, mut delay, mut itm) = aux14::init();

    loop {
        // STARTをブロードキャストします
        // 磁力計のアドレスをR/WビットをWriteに設定して、ブロードキャストします
        i2c1.cr2.write(|w| {
            w.start().set_bit();
            w.sadd1().bits(MAGNETOMETER);
            w.rd_wrn().clear_bit();
            w.nbytes().bits(1);
            w.autoend().clear_bit()
        });

        // 次のデータを送信できるようになるまで、待ちます
        while i2c1.isr.read().txis().bit_is_clear() {}

        // 読みたい`OUT_X_H_M`レジスタのアドレスを送信します
        i2c1.txdr.write(|w| w.txdata().bits(OUT_X_H_M));

        // 前のバイトが送信されるまで待ちます
        while i2c1.isr.read().tc().bit_is_clear() {}

        // RESTARTをブロードキャストします
        // 磁力計のアドレスをR/WビットをReadに設定して、ブロードキャストします
        i2c1.cr2.modify(|_, w| {
            w.start().set_bit();
            w.nbytes().bits(6);
            w.rd_wrn().set_bit();
            w.autoend().set_bit()
        });

        let mut buffer = [0u8; 6];
        for byte in &amp;mut buffer {
            // レジスタの内容を受信するまで待ちます
            while i2c1.isr.read().rxne().bit_is_clear() {}

            *byte = i2c1.rxdr.read().rxdata().bits();
        }
        // STOPをブロードキャストします（`AUTOEND = 1`なので自動です）

        iprintln!(&amp;mut itm.stim[0], &quot;{:?}&quot;, buffer);

        delay.delay_ms(1_000_u16);
    }
}
</code></pre></pre>
<!-- 
If you run this, you should printed in the `itmdump`'s console a new array of six bytes every
second. The values within the array should change if you move around the board.
 -->
<p>これを実行すると、毎秒新しい6バイトの配列が<code>itmdump</code>のコンソールに表示されるはずです。
配列内の値は、ボードを動かすと変化するはずです。</p>
<pre><code class="language-console">$ # itmdump terminal
(..)
[0, 45, 255, 251, 0, 193]
[0, 44, 255, 249, 0, 193]
[0, 49, 255, 250, 0, 195]
</code></pre>
<!-- But these bytes don't make much sense like that. Let's turn them into actual readings: -->
<p>しかし、これらのバイト列は、それほど意味がありません。実際の測定値に変換しましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let x_h = u16::from(buffer[0]);
        let x_l = u16::from(buffer[1]);
        let z_h = u16::from(buffer[2]);
        let z_l = u16::from(buffer[3]);
        let y_h = u16::from(buffer[4]);
        let y_l = u16::from(buffer[5]);

        let x = ((x_h &lt;&lt; 8) + x_l) as i16;
        let y = ((y_h &lt;&lt; 8) + y_l) as i16;
        let z = ((z_h &lt;&lt; 8) + z_l) as i16;

        iprintln!(&amp;mut itm.stim[0], &quot;{:?}&quot;, (x, y, z));
<span class="boring">}
</span></code></pre></pre>
<!-- Now it should look better: -->
<p>これで、より見やすくなるはずです。</p>
<pre><code class="language-console">$ # `itmdump terminal
(..)
(44, 196, -7)
(45, 195, -6)
(46, 196, -9)
</code></pre>
<!-- 
This is the Earth's magnetic field decomposed alongside the XYZ axis of the magnetometer.
 -->
<p>これは、磁力計のXYZ軸で分解された地球磁場です。</p>
<!-- In the next section, we'll learn how to make sense of these numbers. -->
<p>次のセクションでは、これらの数字を理解する方法を学びます。</p>
<!-- # LED compass -->
<h1><a class="header" href="#ledコンパス" id="ledコンパス">LEDコンパス</a></h1>
<!-- 
In this section, we'll implement a compass using the LEDs on the F3. Like proper compasses, our LED
compass must point north somehow. It will do that by turning on one of its eight LEDs; the on LED
should point towards north.
 -->
<p>このセクションでは、F3のLEDを使ったコンパスを実装します。通常のコンパスのように、LEDコンパスは、どうにかして北を向かなければなりません。
これは、8個のLEDの1つを点灯することで達成します。点灯しているLEDが北の方法を指します。</p>
<!-- 
Magnetic fields have both a magnitude, measured in Gauss or Teslas, and a *direction*. The
magnetometer on the F3 measures both the magnitude and the direction of an external magnetic field
but it reports back the *decomposition* of said field along *its axes*.
 -->
<p>磁場は、ガウスまたはテスラで測定された大きさと、<em>方向</em>の両方を持ちます。
F3の磁力計は、外部磁界の大きさと方向とを測定します。しかし、<em>ボードの軸</em>に沿って磁場を<em>分解</em>したものを報告します。</p>
<!-- See below, the magnetometer has three axes associated to it. -->
<p>下記の通り、磁力計は関連する3つの軸を持ちます。</p>
<p align="center">
<img height=480 title="Magnetometer axes" src="15-led-compass/../assets/f3-lsm303dlhc.png">
</p>
<!-- Only the X and Y axes are shown above. The Z axis is pointing "out" of your screen. -->
<p>上図では、XとY軸だけが描かれています。Z軸は、スクリーンの「外」を向いています。</p>
<!-- 
Let's get familiar with the readings of the magnetometer by running the following starter code:
 -->
<p>次のスターターコードを実行して、磁力計の読み取り方に詳しくなりましょう。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*};

#[entry]
fn main() -&gt; ! {
    let (_leds, mut lsm303dlhc, mut delay, mut itm) = aux15::init();

    loop {
        iprintln!(&amp;mut itm.stim[0], &quot;{:?}&quot;, lsm303dlhc.mag().unwrap());
        delay.delay_ms(1_000_u16);
    }
}
</code></pre></pre>
<!-- 
This `lsm303dlhc` module provides high level API over the LSM303DLHC. Under the hood it does the
same I2C routine that you implemented in the last section but it reports the X, Y and Z values in a
`I16x3` struct instead of a tuple.
 -->
<p>この<code>lsm303dlhc</code>モジュールは、LSM303DLHCの高レベルなAPIを提供します。内部では、前回のセクションで実装したI2Cルーチンと同じことをやっています。
しかし、このモジュールは、タプルの代わりに<code>I16x3</code>構造体でX、Y、Zの値を報告します。</p>
<!-- 
Locate where north is at your current location. Then rotate the board such that it's aligned
"towards north": the North LED (LD3) should be pointing towards north.
 -->
<p>現在地の北がどこにあるかを探します。その後、ボードを「北に向かって」いるように回転させます。
北のLED（LD3）が北を向いているはずです。</p>
<!-- Now run the starter code and observe the output. What X, Y and Z values do you see? -->
<p>ここで、スターターコードを実行し、その出力を観察します。X、Y、Zの値はどのようなっていますか？</p>
<pre><code class="language-console">$ # itmdump terminal
(..)
I16x3 { x: 45, y: 194, z: -3 }
I16x3 { x: 46, y: 195, z: -8 }
I16x3 { x: 47, y: 197, z: -2 }
</code></pre>
<!-- 
Now rotate the board 90 degrees while keeping it parallel to the ground. What X, Y and Z values do
you see this time? Then rotate it 90 degrees again. What values do you see?
 -->
<p>次に、地面と平行に保ちながら、ボードを90度回転します。今回は、X、Y、Zの値はどうなりましたか？
さらに90度回転します。値はどうなりましたか？</p>
<!-- # Take 1 -->
<h1><a class="header" href="#第一弾" id="第一弾">第一弾</a></h1>
<!-- What's the simplest way in which we can implement the LED compass? Even if it's not perfect. -->
<p>LEDをコンパスを実装する最も単純な方法はどのようなものでしょうか？例えそれが完璧でなかったとしても。</p>
<!-- 
For starters, we'd only care about the X and Y components of the magnetic field because when you
look at a compass you always hold it in horizontal position thus the compass is in the XY plane.
 -->
<p>初心者のために、磁場のXとYの要素だけを取り扱います。なぜならコンパスを見る時、常にコンパスを水平に保ちます。
従って、コンパスはXY平面にあると考えます。</p>
<!-- 
For example, what LED would you turn on in the following case. EMF stands for Earth's Magnetic Field
and green arrow has the direction of the EMF (it points north).
 -->
<p>例えば、次の場合に、どのLEDを点灯するでしょうか。EMFは地球磁場を意味しており、緑の矢印はEMFの方向です（北を向いています）。</p>
<p align="center">
<img title="Quadrant I" src="15-led-compass/../assets/quadrant-i.png">
</p
<!-- The `Southeast` LED, right? -->
<p><code>南東</code>のLEDで良いでしょうか？</p>
<!-- 
What *signs* do the X and Y components of the magnetic field have in that scenario? Both are
positive.
 -->
<p>この場合、磁場のXとY要素の<em>符号</em>は何になっているでしょうか？両方ともに正数です。</p>
<!-- 
If we only looked at the signs of the X and Y components we could determine to which quadrant the
magnetic field belongs to.
 -->
<p>XとY要素の符号だけを見る場合、磁場が4象限のどこに属しているか、を決定できます。</p>
<p align="center">
<img title="Quadrants" src="15-led-compass/../assets/quadrants.png">
</p>
<!-- 
In the previous example, the magnetic field was in the first quadrant (x and y were positive) and it
made sense to turn on the `SouthEast` LED. Similarly, we could turn a different LED if the magnetic
field was in a different quadrant.
 -->
<p>前の例では、磁場は第一象限に属していました（xとyは正）。そして、<code>南東</code>のLEDを点灯することがわかりました。
同様に、磁場が別の象限に属している場合に、別のLEDを点灯します。</p>
<!-- Let's try that logic. Here's the starter code: -->
<p>このロジックを試してみましょう。スターターコードは、次の通りです。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, Direction, I16x3};

#[entry]
fn main() -&gt; ! {
    let (mut leds, mut lsm303dlhc, mut delay, _itm) = aux15::init();

    loop {
        let I16x3 { x, y, .. } = lsm303dlhc.mag().unwrap();

        // 磁場がどの象限に属するか決めるため、XとY要素の符号を見ます。
        let dir = match (x &gt; 0, y &gt; 0) {
            // 第???象限
            (true, true) =&gt; Direction::Southeast,
            // 第???象限
            (false, true) =&gt; panic!(&quot;TODO&quot;),
            // 第???象限
            (false, false) =&gt; panic!(&quot;TODO&quot;),
            // 第???象限
            (true, false) =&gt; panic!(&quot;TODO&quot;),
        };

        leds.iter_mut().for_each(|led| led.off());
        leds[dir].on();

        delay.delay_ms(1_000_u16);
    }
}
</code></pre></pre>
<!-- 
There's a `Direction` enum in the `led` module that has 8 variants named after the cardinal points:
`North`, `East`, `Southwest`, etc. Each of these variants represent one of the 8 LEDs in the
compass. The `Leds` value can be indexed using the `Direction` `enum`; the result of indexing is the
LED that points in that `Direction`.
 -->
<p><code>led</code>モジュールには、<code>Direction</code>列挙体があります。
この列挙体は、<code>North</code>、<code>East</code>、<code>Southwest</code>のように、方位に基づいて名付けられた8個のヴァリアントがあります。
各ヴァリアントは、円形に並んだ8個のLEDを表しています。
<code>Leds</code>の値は、<code>Direction</code> <code>enum</code>を使ってインデックスアクセスできます。
インデックスアクセスの結果は、<code>Direction</code>を向いたLEDです。</p>
<!-- # Solution 1 -->
<h1><a class="header" href="#解答例1" id="解答例1">解答例1</a></h1>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, Direction, I16x3};

#[entry]
fn main() -&gt; ! {
    let (mut leds, mut lsm303dlhc, mut delay, _itm) = aux15::init();

    loop {
        let I16x3 { x, y, .. } = lsm303dlhc.mag().unwrap();

        // 磁場がどの象限に属するか決めるため、XとY要素の符号を見ます。
        let dir = match (x &gt; 0, y &gt; 0) {
            // 第I象限
            (true, true) =&gt; Direction::Southeast,
            // 第II象限
            (false, true) =&gt; Direction::Northeast,
            // 第III象限
            (false, false) =&gt; Direction::Northwest,
            // 第IV象限
            (true, false) =&gt; Direction::Southwest,
        };

        leds.iter_mut().for_each(|led| led.off());
        leds[dir].on();

        delay.delay_ms(1_000_u16);
    }
}
</code></pre></pre>
<!-- # Take 2 -->
<h1><a class="header" href="#第二弾" id="第二弾">第二弾</a></h1>
<!-- 
This time, we'll use math to get the precise angle that the magnetic field forms with the X and Y
axes of the magnetometer.
 -->
<p>今回は、磁力計のX、Y軸から、数学を使って磁場の正確な角度を求めます。</p>
<!-- 
We'll use the `atan2` function. This function returns an angle in the `-PI` to `PI` range. The
graphic below shows how this angle is measured:
 -->
<p><code>atan2</code>関数を使用します。この関数は、<code>-PI</code>から<code>PI</code>の範囲で角度を返します。
下図は、どのように角度が測定されるか、を示しています。</p>
<p align="center">
<img title="atan2" src="https://upload.wikimedia.org/wikipedia/commons/0/03/Atan2_60.svg">
</p>
<!-- 
Although not explicitly shown in this graph the X axis points to the right and the Y axis points up.
 -->
<p>図内で明示的に示されていませんが、X軸は右を向いており、Y軸は上を向いています。</p>
<!-- 
Here's the starter code. `theta`, in radians, has already been computed. You need to pick which LED
to turn on based on the value of `theta`.
 -->
<p>スターターコードは次の通りです。ラジアンの<code>theta</code>は既に計算されています。
<code>theta</code>の値を基に、どのLEDを点灯するか、を選ばなければなりません。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

// これが便利だと気づくでしょう ;-)
use core::f32::consts::PI;

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, Direction, I16x3};
// このトレイトは`atan2`メソッドを提供します
use m::Float;

#[entry]
fn main() -&gt; ! {
    let (mut leds, mut lsm303dlhc, mut delay, _itm) = aux15::init();

    loop {
        let I16x3 { x, y, .. } = lsm303dlhc.mag().unwrap();

        let _theta = (y as f32).atan2(x as f32); // ラジウス

        // FIXME `theta`を基に、指す方向を選んで下さい
        let dir = Direction::Southeast;

        leds.iter_mut().for_each(|led| led.off());
        leds[dir].on();

        delay.delay_ms(100_u8);
    }
}
</code></pre></pre>
<!-- Suggestions/tips: -->
<p>提案/ヒント：</p>
<!-- 
- A whole circle rotation equals 360 degrees.
- `PI` radians is equivalent to 180 degrees.
- If `theta` was zero, what LED would you turn on?
- If `theta` was, instead, very close to zero, what LED would you turn on?
- If `theta` kept increasing, at what value would you turn on a different LED?
 -->
<ul>
<li>円全体の回転角は、360度です。</li>
<li><code>PI</code>ラジアンは180度です。</li>
<li><code>theta</code>がゼロの場合、どのLEDを点灯しますか？</li>
<li>代わりに、<code>theta</code>がゼロに非常に近い場合、どのLEDを点灯しますか？</li>
<li><code>theta</code>が増え続けた場合、どの値で別のLEDを点灯しますか？</li>
</ul>
<!-- # Solution 2 -->
<h1><a class="header" href="#解答例2" id="解答例2">解答例2</a></h1>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

// これが便利だと気づくでしょう ;-)
use core::f32::consts::PI;

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, Direction, I16x3};
use m::Float;

#[entry]
fn main() -&gt; ! {
    let (mut leds, mut lsm303dlhc, mut delay, _itm) = aux15::init();

    loop {
        let I16x3 { x, y, .. } = lsm303dlhc.mag().unwrap();

        let theta = (y as f32).atan2(x as f32); // ラジアン

        let dir = if theta &lt; -7. * PI / 8. {
            Direction::North
        } else if theta &lt; -5. * PI / 8. {
            Direction::Northwest
        } else if theta &lt; -3. * PI / 8. {
            Direction::West
        } else if theta &lt; -PI / 8. {
            Direction::Southwest
        } else if theta &lt; PI / 8. {
            Direction::South
        } else if theta &lt; 3. * PI / 8. {
            Direction::Southeast
        } else if theta &lt; 5. * PI / 8. {
            Direction::East
        } else if theta &lt; 7. * PI / 8. {
            Direction::Northeast
        } else {
            Direction::North
        };

        leds.iter_mut().for_each(|led| led.off());
        leds[dir].on();

        delay.delay_ms(100_u8);
    }
}
</code></pre></pre>
<!-- # Magnitude -->
<h1><a class="header" href="#大きさ" id="大きさ">大きさ</a></h1>
<!-- 
We have been working with the direction of the magnetic field but what's its real magnitude? The
number that the `magnetic_field` function reports are unit-less. How can we convert those values to
Gauss?
 -->
<p>磁場の方向を取り扱ってきましたが、実際の大きさはどうなのでしょうか？
<code>magnetic_field</code>関数が報告する数字は、単位がありません。どのようにしてこの値をガウスに変換するのでしょうか？</p>
<!-- The documentation will answer that question. -->
<p>ドキュメントがその質問に答えます。</p>
<blockquote>
<p>Section 2.1 Sensor characteristics - Page 10 - LSM303DLHC Data Sheet</p>
</blockquote>
<!-- 
The table in that page shows a *magnetic gain setting* that has different values according to the
values of the GN bits. By default, those GN bits are set to `001`. That means that magnetic gain of
the X and Y axes is `1100 LSB / Gauss` and the magnetic gain of the Z axis is `980 LSB / Gauss`. LSB
stands for Least Significant Bits and the `1100 LSB / Gauss` number indicates that a reading of
`1100` is equivalent to `1 Gauss`, a reading of `2200` is equivalent to 2 Gauss and so on.
 -->
<p>上記ページの表は、GNビットの値に応じて、異なる値を取る<em>磁気のゲイン設定</em>を説明しています。
デフォルトでは、GNビットは<code>001</code>に設定されています。これは、XとY軸の磁気ゲインは、<code>1100 LSB / Gauss</code>であることを意味います。
そして、Z軸の磁気ゲインは、<code>980 LSB / Gauss</code>です。
LSBは、Least Significant Bitsを意味しており、<code>1100 LSB / Gauss</code>は、<code>1100</code>が<code>1 Gauss</code>と等価であり、
<code>2200</code>は<code>2 Gauss</code>と等価である、ということを意味しています。</p>
<!-- 
So, what we need to do is divide the X, Y and Z values that the sensor outputs by its corresponding
*gain*. Then, we'll have the X, Y and Z components of the magnetic field in Gauss.
 -->
<p>つまり、センサ出力のX、Y、Zの値を、対応する<em>ゲイン</em>で除算することが必要です。
すると、X、Y、Z要素の磁場のガウスが計算できます。</p>
<!-- 
With some extra math we can retrieve the magnitude of the magnetic field from its X, Y and Z
components:
 -->
<p>いくつか追加で計算することで、X、Y、Zの要素から磁場の大きさを取得できます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let magnitude = (x * x + y * y + z * z).sqrt();
<span class="boring">}
</span></code></pre></pre>
<!-- Putting all this together in a program: -->
<p>これらをプログラムにまとめます。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, I16x3};
use m::Float;

#[entry]
fn main() -&gt; ! {
    const XY_GAIN: f32 = 1100.; // LSB / G
    const Z_GAIN: f32 = 980.; // LSB / G

    let (_leds, mut lsm303dlhc, mut delay, mut itm) = aux15::init();

    loop {
        let I16x3 { x, y, z } = lsm303dlhc.mag().unwrap();

        let x = f32::from(x) / XY_GAIN;
        let y = f32::from(y) / XY_GAIN;
        let z = f32::from(z) / Z_GAIN;

        let mag = (x * x + y * y + z * z).sqrt();

        iprintln!(&amp;mut itm.stim[0], &quot;{} mG&quot;, mag * 1_000.);

        delay.delay_ms(500_u16);
    }
}
</code></pre></pre>
<!-- 
This program will report the magnitude (strength) of the magnetic field in milligauss (`mG`). The
magnitude of the Earth's magnetic field is in the range of `250 mG` to `650 mG` (the magnitude
varies depending on your geographical location) so you should see a value in that range or close to
that range -- I see a magnitude of around 210 mG.
 -->
<p>このプログラムは、磁場の大きさ（強さ）をミリガウス（<code>mG</code>）単位で報告します。
地球磁場の大きさは、<code>250 mG</code>から<code>650 mG</code>の範囲になります（この大きさは、地理的な場所によって変化します）。
そのため、この範囲内か、範囲に近い値が観測できるはずです。私は、約210 mGの大きさを観測しました。</p>
<!-- Some questions: -->
<p>いくつかの質問：</p>
<!-- Without moving the board, what value do you see? Do you always see the same value? -->
<p>ボードを動かさずに、どのような値を観測しましたか？常に同じ値ですか？</p>
<!-- If you rotate the board, does the magnitude change? Should it change? -->
<p>ボードを回転すると、大きさは変化しますか？変化すべきですか？</p>
<!-- # Calibration -->
<h1><a class="header" href="#キャリブレーション" id="キャリブレーション">キャリブレーション</a></h1>
<!-- 
If we rotate the board, the direction of the Earth's magnetic field with respect to the magnetometer
should change but its magnitude should not! Yet, the magnetometer indicates that the magnitude of
the magnetic field changes as the board rotates.
 -->
<p>ボードを回転すると、磁力計に対する地球磁場の方向は変わりますが、大きさは変わりません！
それでも、磁力計は、ボードが回転すると磁場の大きさが変化することを示しています。</p>
<!-- 
Why's that the case? Turns out the magnetometer needs to be calibrated to return the correct answer.
 -->
<p>それはなぜでしょうか？結局のところ、磁力計が正しい答えを返すためには、キャリブレーションが必要なのです。</p>
<!-- 
The calibration involves quite a bit of math (matrices) so we won't cover it here but this
[Application Note] describes the procedure if you are interested. Instead, what we'll do in this
section is *visualize* how off we are.
 -->
<p>キャリブレーションには、多くの数学（行列）が必要であるため、ここでは取り上げません。もし興味があるのであれば、
<a href="http://cache.freescale.com/files/sensors/doc/app_note/AN4246.pdf">アプリケーションノート</a>にその計算方法が記述されています。
代わりに、このセクションでやることは、どの程度正しい答えからずれているか、を<em>視覚化</em>することです。</p>
<!-- [Application Note]: http://cache.freescale.com/files/sensors/doc/app_note/AN4246.pdf -->
<!-- 
Let's try this experiment: Let's record the readings of the magnetometer while we slowly rotate the
board in different directions. We'll use the `iprintln` macro to format the readings as Tab
Separated Values (TSV).
 -->
<p>次の実験を試してみましょう。別方向にボードをゆっくり回転している間、磁力計から読んだ値を記録しましょう。
読んだ値をタブ区切り（TSV; Tab Separated Values）に変換するため、<code>iprintln</code>マクロを使います。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux15::{entry, iprint, iprintln, prelude::*, I16x3};

#[entry]
fn main() -&gt; ! {
    let (_leds, mut lsm303dlhc, mut delay, mut itm) = aux15::init();

    loop {
        let I16x3 { x, y, z } = lsm303dlhc.mag().unwrap();

        iprintln!(&amp;mut itm.stim[0], &quot;{}\t{}\t{}&quot;, x, y, z);

        delay.delay_ms(100_u8);
    }
}
</code></pre></pre>
<!-- You should get an output in the console that looks like this: -->
<p>コンソールに次のような出力が得られるはずです。</p>
<pre><code class="language-console">$ # itmdumpコンソール
-76     213     -54
-76     213     -54
-76     213     -54
-76     213     -54
-73     213     -55
</code></pre>
<!-- You can pipe that to a file using: -->
<p>次のコマンドを使って、ファイルにパイプできます。</p>
<pre><code class="language-console">$ # 注意！他に実行中の`itmdump`インスタンスを全て終了します
$ itmdump -F -f itm.txt &gt; emf.txt
</code></pre>
<!-- Rotate the board in many different direction while you log data for a several seconds. -->
<p>数秒間、データをログ出力している間、ボードを様々な方向に回転します。</p>
<!-- 
Then import that TSV file into a spreadsheet program (or use the Python script shown below) and plot
the first two columns as a scatter plot.
 -->
<p>その後、TSVファイルをスプレッドシートプログラムに取り込み（もしくは、下記のPythonスクリプトを使い）、
最初の2つの列を散布図としてプロットします。</p>
<pre><code class="language-python">#!/usr/bin/python

import csv
import math
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import sys

# プロット形式を適用します
sns.set()

x = []
y = []

with open(sys.argv[1], 'r') as f:
    rows = csv.reader(f, delimiter='\t')

    for row in rows:
        # データが欠けている行は捨てます
        if len(row) != 3 or not row[0] or not row[1]:
            continue

        x.append(int(row[0]))
        y.append(int(row[1]))

r = math.ceil(max(max(np.abs(x)), max(np.abs(y))) / 100) * 100

plt.plot(x, y, '.')
plt.xlim(-r, r)
plt.ylim(-r, r)
plt.gca().set_aspect(1)
plt.tight_layout()

plt.savefig('emf.svg')
plt.close
</code></pre>
<p align="center">
<img title="Earth's magnetic field" src="15-led-compass/../assets/emf.svg">
</p>
<!-- 
If you rotated the board on a flat horizontal surface, the Z component of the magnetic field should
have remained relatively constant and this plot should have been a circumference (not a ellipse)
centered at the origin. If you rotated the board in random directions, which was the case of plot
above, then you should have gotten a circle made of a bunch of points centered at the origin.
Deviations from the circle shape indicate that the magnetometer needs to be calibrated.
 -->
<p>ボードを水平な平面上で回転した場合、磁場のZ要素は、比較的同じ値を取り続けたはずです。
このプロットは、原点を中心とした円形（楕円形でない）でなければなりません。
上図のプロットのように、ボードをランダムな方向に回転した場合、多数の点からなる原点を中心とした円が得られるはずです。
円形からの偏差は、磁力計をキャリブレーションする必要があることを示しています。</p>
<!-- 
Take home message: Don't just trust the reading of a sensor. Verify it's outputting sensible values.
If it's not, then calibrate it.
 -->
<p>覚えておいてほしいこと：センサから読んだ値を単純に信用しないで下さい。適切な値が出力されていることを確認して下さい。
適切な出力でなければ、キャリブレーションして下さい。</p>
<!-- # Punch-o-meter -->
<h1><a class="header" href="#パンチングマシン" id="パンチングマシン">パンチングマシン</a></h1>
<!-- In this section we'll be playing with the accelerometer that's in the board. -->
<p>このセクションでは、ボードの加速度計で遊びます。</p>
<!-- 
What are we building this time? A punch-o-meter! We'll be measuring the power of your jabs. Well,
actually the maximum acceleration that you can reach because acceleration is what accelerometers
measure. Strength and acceleration are proportional though so it's a good approximation.
 -->
<p>今回は何を作るのでしょうか？パンチングマシンです！あなたのジャブの強さを計測します。
実際は、到達した最高の加速度を計測します。なぜなら、加速度計が計測するのは加速度だからです。
強さと加速度は比例するため、これは良い近似です。</p>
<!-- 
The accelerometer is also built inside the LSM303DLHC package. And just like the magnetometer, it
can also be accessed using the I2C bus. It also has the same coordinate system as the magnetometer.
Here's the coordinate system again:
 -->
<p>加速度計もLSM303DLHCパッケージに組み込まれています。磁力計と同様に、I2Cバスを使ってアクセスできます。
加速度計も磁力計と同じ座標系システムを持っています。座標系を再び示します。</p>
<p align="center">
<img height=480 title="Magnetometer axes" src="16-punch-o-meter/../assets/f3-lsm303dlhc.png">
</p>
<!-- 
Just like in the previous unit, we'll be using a high level API to directly get the sensor readings
in a nicely packaged `struct`.
 -->
<p>前回と同様、高レベルのAPIを使用します。センサから読み取った値を、<code>struct</code>で良い感じにパッケージして直接取得します。</p>
<!-- # Gravity is up? -->
<h1><a class="header" href="#重力は上を向いている" id="重力は上を向いている">重力は上を向いている？</a></h1>
<!-- What's the first thing we'll do? -->
<p>まず最初にやることはなんでしょうか？</p>
<!-- Perform a sanity check! -->
<p>正当性を検証します！</p>
<!-- 
The starter code prints the X, Y and Z components of the acceleration measured by the accelerometer.
The values have already been "scaled" and have units of `g`s. Where `1 g` is equal to the
acceleration of the gravity, about `9.8` meters per second squared.
 -->
<p>スターターコードは、加速度計で計測した加速度のX、Y、Z要素を表示します。
値はすでに「スケール」されており、その単位は<code>g</code>です。ここで、<code>1 g</code>は重力加速度と等しく、約<code>9.8</code>メートル毎秒毎秒です。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux16::{entry, iprint, iprintln, prelude::*, I16x3, Sensitivity};

#[entry]
fn main() -&gt; ! {
    let (mut lsm303dlhc, mut delay, _mono_timer, mut itm) = aux16::init();

    // 計測範囲を`-12g, +12g]に拡張しています
    lsm303dlhc.set_accel_sensitivity(Sensitivity::G12).unwrap();
    loop {
        const SENSITIVITY: f32 = 12. / (1 &lt;&lt; 14) as f32;

        let I16x3 { x, y, z } = lsm303dlhc.accel().unwrap();

        let x = f32::from(x) * SENSITIVITY;
        let y = f32::from(y) * SENSITIVITY;
        let z = f32::from(z) * SENSITIVITY;

        iprintln!(&amp;mut itm.stim[0], &quot;{:?}&quot;, (x, y, z));

        delay.delay_ms(1_000_u16);
    }
}
</code></pre></pre>
<!-- The output of this program with the board sitting still will be something like: -->
<p>ボードが静止している状態で、このプログラムの出力は、次のようになります。</p>
<pre><code class="language-console">$ # itmdumpコンソール
(..)
(0.0, 0.0, 1.078125)
(0.0, 0.0, 1.078125)
(0.0, 0.0, 1.171875)
(0.0, 0.0, 1.03125)
(0.0, 0.0, 1.078125)
</code></pre>
<!-- 
Which is weird because the board is not moving yet its acceleration is non-zero. What's going on?
This must be related to the gravity, right? Because the acceleration of gravity is `1 g`. But the
gravity pulls objects downwards so the acceleration along the Z axis should be negative not positive
...
 -->
<p>これは変です。ボードは動いていないのに、加速度がゼロではありません。何が起こっているのでしょう？
これは、重力と関係しているに違いありません。重力加速度は<code>1 g</code>だからです。
しかし、重力は物体を下に引っ張ります。そのため、Z軸の加速度は、正数ではなく負数でなければなりません・・・。</p>
<!-- 
Did the program get the Z axis backwards? Nope, you can test rotating the board to align the gravity
to the X or Y axis but the acceleration measured by the accelerometer is always pointing up.
 -->
<p>このプログラムはZ軸を逆方向に取得しているのでしょうか？いいえ、ボードを回転させて、重力をX軸もしくはY軸に合わせることができますが、
加速度センサで測定された加速度は常に上を向いています。</p>
<!-- 
What happens here is that the accelerometer is measuring the *proper acceleration* of the board not
the acceleration *you* are observing. This proper acceleration is the acceleration of the board as
seen from a observer that's in free fall. An observer that's in free fall is moving toward the
center of the the Earth with an acceleration of `1g`; from its point of view the board is actually
moving upwards (away from the center of the Earth) with an acceleration of `1g`. And that's why the
proper acceleration is pointing up. This also means that if the board was in free fall, the
accelerometer would report a proper acceleration of zero. Please, don't try that at home.
 -->
<!-- `proper acceleration`の意味がわからないので、そのままにしてあります -->
<p>発生している現象は、加速度計は<em>あなた</em>が観測している加速度ではなく、ボードの<em>proper acceleration</em>を測定している、ということです。
このproper accelerationとは、自由落下中の観測者から見たボードの加速度です。自由落下中の観測者は、地球の中心部に向かって、<code>1g</code>の加速度で移動しています。
この観点から見ると、ボードは上に向かって（地球の中心部から離れて）、<code>1g</code>の加速度で動いています。
そして、これがproper accelerationが上に向いている理由です。
これはボードが自由落下していると、加速度計はゼロのproper accelerationを報告する、ということを意味します。
家では試さないようにして下さい。</p>
<!-- Yes, physics is hard. Let's move on. -->
<p>物理は難しいです。次へ進みましょう。</p>
<!-- # The challenge -->
<h1><a class="header" href="#課題-1" id="課題-1">課題</a></h1>
<!-- 
To keep things simple, we'll measure the acceleration only in the X axis while the board remains
horizontal. That way we won't have to deal with subtracting that *fictitious* `1g` we observed
before which would be hard because that `1g` could have X Y Z components depending on how the board
is oriented.
 -->
<p>簡単化のために、ボードを水平にしたままX軸の加速度だけを計測します。
この方法では、前回観測した<em>架空の</em><code>1g</code>を差し引く必要がなくなります。架空の1gを扱うことは、難しいです。
なぜなら、<code>1g</code>はボードが向いている方向によって、X Y Zの要素を持つからです。</p>
<!-- Here's what the punch-o-meter must do: -->
<p>パンチングマシンがやらなければいけないことは、次の通りです。</p>
<!-- 
- By default, the app is not "observing" the acceleration of the board.
- When a significant X acceleration is detected (i.e. the acceleration goes above some threshold),
  the app should start a new measurement.
- During that measurement interval, the app should keep track of the maximum acceleration observed
- After the measurement interval ends, the app must report the maximum acceleration observed. You
  can report the value using the `iprintln` macro.
 -->
<ul>
<li>デフォルトでは、ボードは加速度を「観測」していません。</li>
<li>大きなX軸方向の加速度が検出された（つまり、加速度がしきい値を超えた）時、アプリケーションは新しい計測を開始します。</li>
<li>計測期間中、観測した最大の加速度を追跡し続ける必要があります。</li>
<li>観測期間を終えると、アプリケーションは、観測した最大加速度を報告します。<code>iprintln</code>マクロを使って最大加速度を報告できます。</li>
</ul>
<!-- Give it a try and let me know how hard you can punch `;-)`. -->
<p>パンチングマシンを試してみて、あなたのパンチがどのくらい強力か、私に教えて下さい <code>;-)</code>。</p>
<!-- # My solution -->
<h1><a class="header" href="#解答例-4" id="解答例-4">解答例</a></h1>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

#[allow(unused_imports)]
use aux16::{entry, iprint, iprintln, prelude::*, I16x3, Sensitivity};
use m::Float;

#[entry]
fn main() -&gt; ! {
    const SENSITIVITY: f32 = 12. / (1 &lt;&lt; 14) as f32;
    const THRESHOLD: f32 = 0.5;

    let (mut lsm303dlhc, mut delay, mono_timer, mut itm) = aux16::init();

    lsm303dlhc.set_accel_sensitivity(Sensitivity::G12).unwrap();

    let measurement_time = mono_timer.frequency().0; // 1秒ティック
    let mut instant = None;
    let mut max_g = 0.;
    loop {
        let g_x = f32::from(lsm303dlhc.accel().unwrap().x).abs() * SENSITIVITY;

        match instant {
            None =&gt; {
                // 加速度がしきい値を超えると、計測を開始します
                if g_x &gt; THRESHOLD {
                    iprintln!(&amp;mut itm.stim[0], &quot;START!&quot;);

                    max_g = g_x;
                    instant = Some(mono_timer.now());
                }
            }
            // まだ計測しています
            Some(ref instant) if instant.elapsed() &lt; measurement_time =&gt; {
                if g_x &gt; max_g {
                    max_g = g_x;
                }
            }
            _ =&gt; {
                // 最大値を報告します
                iprintln!(&amp;mut itm.stim[0], &quot;Max acceleration: {}g&quot;, max_g);

                // 計測を終了します
                instant = None;

                // リセットします
                max_g = 0.;
            }
        }

        delay.delay_ms(50_u8);
    }
}
</code></pre></pre>
<!-- # What's left for you to explore -->
<h1><a class="header" href="#もっと楽しむために" id="もっと楽しむために">もっと楽しむために</a></h1>
<!-- We have barely scratched the surface! There's lots of stuff left for you to explore: -->
<p>まだ上っ面をなでただけです！まだまだたくさん楽しめるものがあります。</p>
<!-- ## Multitasking -->
<h2><a class="header" href="#マルチタスク" id="マルチタスク">マルチタスク</a></h2>
<!-- 
All our programs executed a single task. How could we achieve multitasking in a system with no OS,
and thus no threads. There are two main approaches to multitasking: preemptive multitasking and
cooperative multitasking.
 -->
<p>作ったプログラムは全てシングルタスクで実行しました。OSがなく、スレッドがないシステムでマルチタスクを実現するにはどうするのでしょうか。
2つの主なアプローチがあります。プリエンプティブマルチタスクと協調的マルチタスクです。</p>
<!-- 
In preemptive multitasking a task that's currently being executed can, at any point in time, be
*preempted* (interrupted) by another task. On preemption, the first task will be suspended and the
processor will instead execute the second task. At some point the first task will be resumed.
Microcontrollers provide hardware support for preemption in the form of *interrupts*.
 -->
<p>プリエンプティブマルチタスクでは、実行されているタスクは、いつでも、他のタスクによって<em>プリエンプション</em>（割込み）されます。
プリエンプションでは、最初のタスクは一時停止され、プロセッサは2つ目のタスクを代わりに実行します。
どこかの時点で最初のタスクが再開されます。
マイクロコントローラは、プリエンプションを<em>割込み</em>という形でハードウェアサポートしています。</p>
<!-- 
In cooperative multitasking a task that's being executed will run until it reaches a *suspension
point*. When the processor reaches that suspension point it will stop executing the current task and
instead go and execute a different task. At some point the first task will be resumed. The main
difference between these two approaches to multitasking is that in cooperative multitasking *yields*
execution control at *known* suspension points instead of being forcefully preempted at any point of
its execution.
 -->
<p>協調的マルチタスクでは、実行されているタスクは<em>中断点</em>に到達するまで実行します。
プロセッサが中断点に到達すると、現在のタスクの実行を停止し、代わりに別のタスクを実行します。どこかの時点で最初のタスクが再開されます。
マルチタスクのための2つのアプローチの主な違いは、いかなるタイミングでも強制的にその実行がプリエンプションされる代わりに、
協調的マルチタスクでは<em>既知の</em>中断点で実行制御を<em>譲る</em>ことです。</p>
<h2><a class="header" href="#direct-memory-access-dma" id="direct-memory-access-dma">Direct Memory Access (DMA).</a></h2>
<!-- 
This peripheral is a kind of *asynchronous* `memcpy`. So far our programs have
been pumping data, byte by byte, into peripherals like UART and I2C. This DMA
peripheral can be used to perform bulk transfers of data. Either from RAM to
RAM, from a peripheral, like a UART, to RAM or from RAM to a peripheral. You can
schedule a DMA transfer, like read 256 bytes from USART1 into this buffer, leave
it running in the background and then poll some register to see if it has
completed so you can do other stuff while the transfer is ongoing.
 -->
<p>このペリフェラルは、<em>非同期</em>の<code>memcpy</code>です。これまでのところ、プログラムは、UARTやI2Cのようなペリフェラルに、バイトごとにデータを送信してきました。
DMAペリフェラルは、データの一括転送を行うために使用できます。RAMからRAM、UARTのようなペリフェラルからRAM、RAMからペリフェラルへ転送できます。
DMA転送をスケジュールすることもできます。
例えば256バイトをUSART1からバッファへ読み込む、という処理をバックグランドで実行しながら、転送が完了したかをレジスタをポーリングすることで、
転送を行っている間、他のことができます。</p>
<!-- ## Sleeping -->
<h2><a class="header" href="#スリープ" id="スリープ">スリープ</a></h2>
<!-- 
All our programs have been continuously polling peripherals to see if there's
anything that needs to be done. However, some times there's nothing to be done!
At those times, the microcontroller should "sleep".
 -->
<p>作った全てのプログラムは、必要な処理が終わったかどうかを見るために、ペリフェラルを継続的にポーリングしています。
しかし、なにもすることがないことがあります。
そのような場合、マイクロコントローラは「スリープ」しなければなりません。</p>
<!-- 
When the processor sleeps, it stops executing instructions and this saves power.
It's almost always a good idea to save power so your microcontroller should be
sleeping as much as possible. But, how does it know when it has to wake up to
perform some action? "Interrupts" are one of the events that wake up the
microcontroller but there are others and the `wfi` and `wfe` are the
instructions that make the processor "sleep".
 -->
<p>プロセッサがスリープしている時、命令の実行を停止し、電力を節約します。
これは、電力節約のために、多くの場合、良いことです。マイクロコントローラは可能な限りスリープしなければなりません。
しかし、何か処理を行うためにいつ目覚めるか、をどうやって知ればよいでしょうか？
「割込み」はマイクロコントローラを目覚めさせるイベントの1つですが、他の方法もあります。
<code>wfi</code>と<code>wfe</code>はプロセッサを「スリープ」させる命令です。</p>
<!-- ## Pulse Width Modulation (PWM) -->
<h2><a class="header" href="#パルス幅変調pwm" id="パルス幅変調pwm">パルス幅変調（PWM）</a></h2>
<!-- 
In a nutshell, PWM is turning on something and then turning it off periodically
while keeping some proportion ("duty cycle") between the "on time" and the "off
time". When used on a LED with a sufficiently high frequency, this can be used
to dim the LED. A low duty cycle, say 10% on time and 90% off time, will make
the LED very dim wheres a high duty cycle, say 90% on time and 10% off time,
will make the LED much brighter (almost as if it were fully powered).
 -->
<p>手短に言うと、PWMは、周期的に何かをオンにして、その後オフにすることです。
ここで、「オンの時間」と「オフの時間」の間は、ある割合（「デューティ比」）を保ち続けます。
十分周波数の高いLEDを使用すると、PWMは、LEDを薄暗くするために使用できます。
ディーティ比が低いと、つまり10%オンで90%オフだと、LEDは非常に薄暗くなります。反対に、デューティ比が高いと、
つまり90%オンで10%オフだと、LEDはかなり明るくなります（ほとんど完全に電力を供給されたように）。</p>
<!-- 
In general, PWM can be used to control how much *power* is given to some
electric device. With proper (power) electronics between a microcontroller and
an electrical motor, PWM can be used to control how much power is given to the
motor thus it can be used to control its torque and speed. Then you can add an
angular position sensor and you got yourself a closed loop controller that can
control the position of the motor at different loads.
 -->
<p>通常、PWMは電気機器にどの程度<em>電力</em>を供給するか、制御するために使われます。
マイクロコントローラと電気モータとの間に、適切な（電力）電子機器を用いて、PWMでモータにどれだけの電力供給するか制御できます。
そのため、PWMを使用してモータのトルクと速度を制御できます。
それから、角位置センサを追加し、閉ループコントローラを入手できます。
このコントローラは、様々な負荷でモータの位置を制御することができます。</p>
<!-- ## Digital input -->
<h2><a class="header" href="#デジタル入力" id="デジタル入力">デジタル入力</a></h2>
<!-- 
We have used the microcontroller pins as digital outputs, to drive LEDs. But
these pins can also be configured as digital inputs. As digital inputs, these
pins can read the binary state of switches (on/off) or buttons (pressed/not
pressed).
 -->
<p>LEDを駆動するために、マイクロコントローラのピンをデジタル出力として使用してきました。
しかし、これらのピンはデジタル入力として設定することもできます。
デジタル入力として、これらのピンは、スイッチ（オン/オフ）やボタン（押された/押されていない）の二値状態を読むことができます。</p>
<!-- 
(*spoilers* reading the binary state of switches / buttons is not as
straightforward as it sounds ;-)
 -->
<p>（<em>ネタバレ</em> スイッチ/ボタンの二値状態を読むことは、思ったほど簡単ではありません ;-)）</p>
<!-- ## Sensor fusion -->
<h2><a class="header" href="#センサフュージョン" id="センサフュージョン">センサフュージョン</a></h2>
<!-- 
The STM32F3DISCOVERY contains three motion sensors: an accelerometer, a
gyroscope and a magnetometer. On their own these measure: (proper) acceleration,
angular speed and (the Earth's) magnetic field. But these magnitudes can be
"fused" into something more useful: a "robust" measurement of the orientation of
the board. Where robust means with less measurement error than a single sensor
would be capable of.
 -->
<p>STM32F3DISCOVERYは3つのモーションセンサを搭載しています。加速度計、ジャイロスコープ、磁力計です。
彼らは(proper)加速度、角速度、（地球）磁場を計測できます。
しかし、これらの測定値は、「ロバストな」ボード向きの測定のように、もっと有用なものに「融合」することができます。
ここでロバストが意味するところは、単一のセンサで計測できるものより、計測誤差が少ないことです。</p>
<!-- 
This idea of deriving more reliable data from different sources is known as
sensor fusion.
 -->
<p>より信頼性の高いデータを、異なるソースから生み出すためのこのアイデアは、センサフュージョンと呼ばれています。</p>
<!-- ## Analog-to-Digital Converters (ADC) -->
<h2><a class="header" href="#アナログデジタルコンバータadc" id="アナログデジタルコンバータadc">アナログデジタルコンバータ（ADC）</a></h2>
<!-- 
There are a lots of digital sensors out there. You can use a protocol like I2C
and SPI to read them. But analog sensors also exist! These sensors just output a
voltage level that's proportional to the magnitude they are sensing.
 -->
<p>たくさんのデジタルセンサがあります。I2CやSPIのようなプロトコルを使って、センサからデータを読み出せます。
しかし、アナログセンサも存在しています！これらのセンサは、検知している大きさに比例した電圧レベルを出力するだけです。</p>
<!-- 
The ADC peripheral can be use to convert that "analog" voltage level, say `1.25`
Volts,into a "digital" number, say in the `[0, 65535]` range, that the processor
can use in its calculations.
 -->
<p>ADCペリフェラルは、「アナログ」電圧を変換するために使用します。
つまり<code>1.25</code>ボルトを、プロセッサが計算で使える「デジタル」な数値である<code>[0, 65535]</code>の範囲に変換します。</p>
<!-- ## Digital-to-Analog Converters (DAC) -->
<h2><a class="header" href="#デジタルアナログコンバータdac" id="デジタルアナログコンバータdac">デジタルアナログコンバータ（DAC）</a></h2>
<!-- 
As you might expect a DAC is exactly the opposite of ADC. You can write some
digital value into a register to produce a voltage in the `[0, 3.3V]` range
(assuming a `3.3V` power supply) on some "analog" pin. When this analog pin is
connected to some appropriate electronics and the register is written to at some
constant, fast rate (frequency) with the right values you can produce sounds or
even music!
 -->
<p>予想の通り、DACはADCの反対のことを行います。
何らかのデジタル値をレジスタに書き込むと、<code>[0, 3.3V]</code>の範囲の電圧を、「アナログ」ピンに出力します（電源が<code>3.3V</code>と仮定しています）。
このアナログピンが、何らかの適切な電子機器に接続されており、何らかの定数がレジスタに書き込まれると、
正しい値の速いレート（周波数）は、サウンドや音楽さえも生み出すことができます。</p>
<!-- ## Real Time Clock (RTC) -->
<h2><a class="header" href="#リアルタイムクロックrtc" id="リアルタイムクロックrtc">リアルタイムクロック（RTC）</a></h2>
<!-- 
This peripheral can be used to track time in "human format". Seconds, minutes,
hours, days, months and years. This peripheral handles the translation from
"ticks" to these human friendly units of time. It even handles leap years and
Daylight Save Time for you!
 -->
<p>このペリフェラルは、「人間の形式」で時間を追跡するために使用できます。
秒、分、時間、日、月、年の形式です。このペリフェラルは、「ティック」から人間が読みやすい時間の単位への変換を取り扱います。
RTCは、うるう年や夏時間でさえも取り扱います！</p>
<!-- ## Other communication protocols -->
<h2><a class="header" href="#他の通信プロトコル" id="他の通信プロトコル">他の通信プロトコル</a></h2>
<!-- SPI, I2S, SMBUS, CAN, IrDA, Ethernet, USB, Bluetooth, etc. -->
<p>SPI, I2S, SMBUS, CAN, IrDA, Ethernet, USB, Bluetooth,など。</p>
<!-- 
Different applications use different communication protocols. User facing
applications usually have an USB connector because USB is an ubiquitous
protocol in PCs and smartphones. Whereas inside cars you'll find plenty of CAN
"buses". Some digital sensors use SPI, others use I2C and others, SMBUS.
 -->
<p>アプリケーションごとに違う通信プロトコルを使います。ユーザーが触れるアプリケーションは、通常USBコネクターを持ちます。
なぜなら、USBは、PCやスマートフォンの至るところで使われているプロトコルだからです。
一方、車の内部では、多くのCAN「バス」を見つけられます。デジタルセンサにはSPIを使うものがあり、他のものはI2CやSMBUSを使います。</p>
<hr />
<!-- So where to next? There are several options: -->
<p>さて、次はどこでしょう？いくつかの選択肢があります。</p>
<!-- 
- You could check out the examples in the [`f3`] board support crate. All those examples work for
  the STM32F3DISCOVERY board you have.
 -->
<ul>
<li><a href="https://docs.rs/f3"><code>f3</code></a>ボードサポートクレートにある例をチェックできます。全ての例は、STM32F3DISCOVERYボードで動きます。</li>
</ul>
<!-- 
- You could try out [this motion sensors demo][madgwick]. Details about the implementation and
  source code are available in [this blog post][wd-1-2].
 -->
<ul>
<li><a href="https://mobile.twitter.com/japaricious/status/962770003325005824">このモーションセンサデモ</a>を試すことができます。実装とソースコードについての詳細は、<a href="http://blog.japaric.io/wd-1-2-l3gd20-lsm303dlhc-madgwick/">このブログ</a>にあります。</li>
</ul>
<!-- 
- You could check out [Real Time for The Masses]. A very efficient preemptive multitasking framework
  that supports task prioritization and dead lock free execution.
 -->
<ul>
<li><a href="https://docs.rs/cortex-m-rtfm">Real Time for The Masses</a>をチェックできます。非常に効率的なプリエンプティブマルチタスクフレームワークです。
これは、タスクの優先度と、デッドロックしない実行を提供します。</li>
</ul>
<!-- 
- You could try running Rust on a different development board. The easiest way to get started is to
  use the [`cortex-m-quickstart`] Cargo project template.
 -->
<ul>
<li>Rustを別の開発ボードで動かしてみることができます。最も簡単な方法は、<a href="https://docs.rs/cortex-m-quickstart/0.2.4/cortex_m_quickstart"><code>cortex-m-quickstart</code></a>のCargoプロジェクトテンプレートを使うことです。</li>
</ul>
<!-- 
- You could check out [this blog post][brave-new-io] which describes how Rust type system can
  prevent bugs in I/O configuration.
 -->
<ul>
<li><a href="http://blog.japaric.io/brave-new-io/">このブログ</a>をチェックできます。このブログは、Rustの型システムがI/O設定のバグを防ぐ方法を説明しています。</li>
</ul>
<!-- - You could check out my [blog] for miscellaneous topics about embedded development with Rust. -->
<ul>
<li>私の<a href="http://blog.japaric.io">ブログ</a>をチェックできます。Rustを使った組込み開発について、様々なトピックを書いています。</li>
</ul>
<!-- 
- You could check out the [`embedded-hal`] project which aims to build abstractions (traits) for all
  the embedded I/O functionality commonly found on microcontrollers.
 -->
<ul>
<li><a href="https://github.com/rust-embedded/embedded-hal"><code>embedded-hal</code></a>プロジェクトをチェックできます。このプロジェクトは、
マイクロコントローラで一般的に用いられる組込みI/O機能に対して、抽象化（トレイト）を構築することを目指しています。</li>
</ul>
<!-- 
- You could join the [Weekly driver initiative] and help us write generic drivers on top of the
  `embedded-hal` traits and that work for all sorts of platforms (ARM Cortex-M, AVR, MSP430, RISCV,
  etc.)
 -->
<ul>
<li><a href="https://github.com/rust-lang-nursery/embedded-wg/issues/39">Weekly driver initiative</a>に参加して、<code>embedded-hal</code>トレイト上で汎用ドライバを書く手伝いができます。
この汎用ドライバは、あらゆる種類のプラットフォーム（ARM Cortex-M、AVR、MSP430、RISCVなど）で動作します。</li>
</ul>
<!-- # General troubleshooting -->
<h1><a class="header" href="#トラブルシューティング" id="トラブルシューティング">トラブルシューティング</a></h1>
<!-- ## OpenOCD problems -->
<h2><a class="header" href="#openocdの問題" id="openocdの問題">OpenOCDの問題</a></h2>
<!-- ### can't connect to OpenOCD - "Error: open failed" -->
<h3><a class="header" href="#openocdに接続できません---error-open-failed" id="openocdに接続できません---error-open-failed">OpenOCDに接続できません - &quot;Error: open failed&quot;</a></h3>
<!-- #### Symptoms -->
<h4><a class="header" href="#症状" id="症状">症状</a></h4>
<!-- 
Upon trying to establish a *new connection* with the device you get an error
that looks like this:
 -->
<p>デバイスと<em>新しい接続</em>を確立しようとするときに、次のようなエラーが発生します。</p>
<pre><code>$ openocd -f (..)
(..)
Error: open failed
in procedure 'init'
in procedure 'ocd_bouncer'
</code></pre>
<!-- #### Cause + Fix -->
<h4><a class="header" href="#原因と解決策" id="原因と解決策">原因と解決策</a></h4>
<!-- 
- All: The device is not (properly) connected. Check the USB connection using
  `lsusb` or the Device Manager.
- Linux: You may not have enough permission to open the device. Try again with
  `sudo`. If that works, you can use [these instructions] to make OpenOCD work
  without root privilege.
- Windows: You are probably missing the ST-LINK USB driver. Installation
  instructions [here].
 -->
<ul>
<li>全員：デバイスが（正しく）接続されていません。<code>lsusb</code>かデバイスマネージャでUSB接続を確認して下さい。</li>
<li>Linux：デバイスを開くためのパーミッションがないかもしれません。<code>sudo</code>をつけてもう1度試して下さい。
もしこれがうまくいくようであれば、OpenOCDをroot権限なしで実行するために、<a href="appendix/1-general-troubleshooting/../../03-setup/linux.html#udev-rules">これらの手順</a>が使えます。</li>
<li>Windows：ST-LINK USBドライバがない可能性があります。インストール手順は<a href="appendix/1-general-troubleshooting/../../03-setup/windows.html#st-link-usb-driver">こちら</a>です。</li>
</ul>
<!-- 
[these instructions]: ../../03-setup/linux.md#udev-rules
[here]: ../../03-setup/windows.md#st-link-usb-driver
 -->
<!-- ### can't connect to OpenOCD - "Polling again in X00ms" -->
<h3><a class="header" href="#openocdに接続できません---polling-again-in-x00ms" id="openocdに接続できません---polling-again-in-x00ms">OpenOCDに接続できません - &quot;Polling again in X00ms&quot;</a></h3>
<!-- #### Symptoms -->
<h4><a class="header" href="#症状-1" id="症状-1">症状</a></h4>
<!-- 
Upon trying to establish a *new connection* with the device you get an error
that looks like this:
 -->
<p>デバイスと<em>新しい接続</em>を確立しようとするときに、次のようなエラーが発生します。</p>
<pre><code>$ openocd -f (..)
(..)
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 100ms
Info : Previous state query failed, trying to reconnect
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 300ms
Info : Previous state query failed, trying to reconnect
</code></pre>
<!-- #### Cause -->
<h4><a class="header" href="#原因" id="原因">原因</a></h4>
<!-- 
The microcontroller may have get stuck in some tight infinite loop or it may be
continuously raising an exception, e.g. the exception handler is raising an
exception.
 -->
<p>マイクロコントローラは、短い無限ループに陥っているか、継続的に例外が発生している可能性があります。
例えば、例外ハンドラが例外を発生させています。</p>
<!-- #### Fix -->
<h4><a class="header" href="#解決策" id="解決策">解決策</a></h4>
<!-- 
- Close OpenOCD, if running
- Press and hold the reset (black) button
- Launch the OpenOCD command
- Now, release the reset button
 -->
<ul>
<li>もし実行中であれば、OpenOCDを終了します</li>
<li>（黒い）リセットボタンを押したままにします</li>
<li>OpenOCDコマンドを実行します</li>
<li>ここで、リセットボタンを離します</li>
</ul>
<!-- ### OpenOCD connection lost - "Polling again in X00ms" -->
<h3><a class="header" href="#openocd接続切れ---polling-again-in-x00ms" id="openocd接続切れ---polling-again-in-x00ms">OpenOCD接続切れ - &quot;Polling again in X00ms&quot;</a></h3>
<!-- #### Symptoms -->
<h4><a class="header" href="#症状-2" id="症状-2">症状</a></h4>
<!-- A *running* OpenOCD session suddenly errors with: -->
<p><em>実行中の</em>OpenOCDセッションが、急にエラーになります。</p>
<pre><code># openocd -f (..)
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 100ms
Info : Previous state query failed, trying to reconnect
Error: jtag status contains invalid mode value - communication failure
Polling target stm32f3x.cpu failed, trying to reexamine
Examination failed, GDB will be halted. Polling again in 300ms
Info : Previous state query failed, trying to reconnect
</code></pre>
<!-- #### Cause -->
<h4><a class="header" href="#原因-1" id="原因-1">原因</a></h4>
<!-- The USB connection was lost. -->
<p>USB接続が切断されました。</p>
<!-- #### Fix -->
<h4><a class="header" href="#解決方法" id="解決方法">解決方法</a></h4>
<!-- 
- Close OpenOCD
- Disconnect and re-connect the USB cable.
- Re-launch OpenOCD
 -->
<ul>
<li>OpenOCDを終了します</li>
<li>USBケーブルを抜き、再度接続します</li>
<li>OpenOCDを再起動します</li>
</ul>
<!-- ### Can't flash the device - "Ignoring packet error, continuing..." -->
<h3><a class="header" href="#デバイスのflashに書き込めません---ignoring-packet-error-continuing" id="デバイスのflashに書き込めません---ignoring-packet-error-continuing">デバイスのFlashに書き込めません - &quot;Ignoring packet error, continuing...&quot;</a></h3>
<!-- #### Symptoms -->
<h4><a class="header" href="#症状-3" id="症状-3">症状</a></h4>
<!-- While flashing the device, you get: -->
<p>デバイスのFlashに書き込んでいる間に、次のエラーが発生します。</p>
<pre><code>$ arm-none-eabi-gdb $file
Start address 0x8000194, load size 31588
Transfer rate: 22 KB/sec, 5264 bytes/write.
Ignoring packet error, continuing...
Ignoring packet error, continuing...
</code></pre>
<!-- #### Cause -->
<h4><a class="header" href="#原因-2" id="原因-2">原因</a></h4>
<!-- 
Closed `itmdump` while a program that "printed" to the ITM was running. The
current GDB session will appear to work normally, just without ITM output but
the next GDB session will error with the message that was shown in the previous
section.
 -->
<p>ITMに「表示する」プログラムが実行している間に<code>itmdump</code>を終了したことです。
現在のGDBセッションは、ITM出力なしに、通常通り動きますが、次のGDBセッションは先程お見せしたメッセージと共にエラーになります。</p>
<!-- 
Or, `itmdump` was called **after** the `monitor tpiu` was issued thus making
`itmdump` delete the file / named-pipe that OpenOCD was writing to.
 -->
<p>もしくは、<code>monitor tpiu</code>が発行された<em>後に</em><code>itmdump</code>を実行したことです。
そのため、<code>itmdump</code>はOpenOCDが書き込んでいたファイル / 名前付きのパイプを削除します。</p>
<!-- #### Fix -->
<h4><a class="header" href="#解決策-1" id="解決策-1">解決策</a></h4>
<!-- 
- Close/kill GDB, OpenOCD and `itmdump`
- Remove the file / named-pipe that `itmdump` was using (for example,
  `itm.txt`).
- Launch OpenOCD
- Then, launch `itmdump`
- Then, launch the GDB session that executes the `monitor tpiu` command.
 -->
<ul>
<li>GDB、OpenOCD、<code>itmdump</code>を終了/killします。</li>
<li><code>itmdump</code>が使っていたファイル / 名前付きのパイプ（例えば、<code>itm.txt</code>）を削除します。</li>
<li>OpenOCDを起動します。</li>
<li>次に、<code>itmdump</code>を起動します。</li>
<li>次に、<code>monitor tpiu</code>コマンドを実行するGDBセッションを起動します。</li>
</ul>
<!-- ## Cargo problems -->
<h2><a class="header" href="#cargoの問題" id="cargoの問題">Cargoの問題</a></h2>
<h3><a class="header" href="#cant-find-crate-for-core" id="cant-find-crate-for-core">&quot;can't find crate for <code>core</code>&quot;</a></h3>
<!-- #### Symptoms -->
<h4><a class="header" href="#症状-4" id="症状-4">症状</a></h4>
<pre><code>   Compiling volatile-register v0.1.2
   Compiling rlibc v1.0.0
   Compiling r0 v0.1.0
error[E0463]: can't find crate for `core`

error: aborting due to previous error

error[E0463]: can't find crate for `core`

error: aborting due to previous error

error[E0463]: can't find crate for `core`

error: aborting due to previous error

Build failed, waiting for other jobs to finish...
Build failed, waiting for other jobs to finish...
error: Could not compile `r0`.

To learn more, run the command again with --verbose.
</code></pre>
<!-- #### Cause -->
<h4><a class="header" href="#原因-3" id="原因-3">原因</a></h4>
<!-- 
You are using a toolchain older than `nightly-2018-04-08` and forgot to call `rustup target add
thumbv7em-none-eabihf`.
 -->
<p><code>nightly-2018-04-08</code>より古いツールチェインを使っており、<code>rustup target add thumbv7em-none-eabihf</code>の実行を忘れています。</p>
<!-- #### Fix -->
<h4><a class="header" href="#解決策-2" id="解決策-2">解決策</a></h4>
<!-- Update your nightly and install the `thumbv7em-none-eabihf` target. -->
<p>nightlyを更新し、<code>thumbv7em-none-eabihf</code>ターゲットをインストールします。</p>
<pre><code class="language-console">$ rustup update nightly

$ rustup target add thumbv7em-none-eabihf
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
